---
layout:     post
title:      Spark源码分析——deploy模块
---
<div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post">
								            <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f76675cdea.css">
						<div class="htmledit_views" id="content_views">
                
<div class="content">
<h3 id="background">Background</h3>
<p>在前文<a href="http://jerryshao.me/Architecture/2013/04/21/Spark%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B-scheduler%E6%A8%A1%E5%9D%97/" rel="nofollow">Spark源码分析之-scheduler模块</a>中提到了Spark在资源管理和调度上采用了Hadoop
<a href="http://hadoop.apache.org/docs/current/hadoop-yarn/hadoop-yarn-site/YARN.html" rel="nofollow">
<strong>YARN</strong></a>的方式：外层的资源管理器和应用内的任务调度器；并且分析了Spark应用内的任务调度模块。本文就Spark的外层资源管理器-deploy模块进行分析，探究Spark是如何协调应用之间的资源调度和管理的。</p>
<p>Spark最初是交由<a href="http://incubator.apache.org/mesos/" rel="nofollow"><strong>Mesos</strong></a>进行资源管理，为了使得更多的用户，包括没有接触过Mesos的用户使用Spark，Spark的开发者添加了Standalone的部署方式，也就是deploy模块。因此deploy模块只针对不使用Mesos进行资源管理的部署方式。</p>
<h1 id="deploy">Deploy模块整体架构</h1>
<p><strong>deploy</strong>模块主要包含3个子模块：<strong>master</strong>, <strong>worker</strong>,
<strong>client</strong>。他们继承于<code>Actor</code>，通过actor实现互相之间的通信。</p>
<ul><li><strong>Master</strong>：master的主要功能是接收worker的注册并管理所有的worker，接收client提交的application，(FIFO)调度等待的application并向worker提交。</li><li><strong>Worker</strong>：worker的主要功能是向master注册自己，根据master发送的application配置进程环境，并启动<code>StandaloneExecutorBackend</code>。</li><li><strong>Client</strong>：client的主要功能是向master注册并监控application。当用户创建<code>SparkContext</code>时会实例化<code>SparkDeploySchedulerBackend</code>，而实例化<code>SparkDeploySchedulerBackend</code>的同时就会启动client，通过向client传递启动参数和application有关信息，client向master发送请求注册application并且在slave
 node上启动<code>StandaloneExecutorBackend</code>。</li></ul><p>下面来看一下deploy模块的类图：</p>
<p><img alt="Deploy moduler class chart" src="http://jerryshao.me/img/2013-04-30-deploy/deploy_uml.png" width="640"></p>
<h1 id="deploy_2">Deploy模块通信消息</h1>
<p>Deploy模块并不复杂，代码也不多，主要集中在各个子模块之间的消息传递和处理上，因此在这里列出了各个模块之间传递的主要消息：</p>
<ul><li>
<p><strong>client</strong> to <strong>master</strong></p>
<ol><li><code>RegisterApplication</code> (向master注册application)</li></ol></li><li>
<p><strong>master</strong> to <strong>client</strong></p>
<ol><li><code>RegisteredApplication</code> (作为注册application的reply，回复给client)</li><li><code>ExecutorAdded</code> (通知client worker已经启动了Executor环境，当向worker发送<code>LaunchExecutor</code>后通知client)</li><li><code>ExecutorUpdated</code> (通知client Executor状态已经发生变化了，包括结束、异常退出等，当worker向master发送<code>ExecutorStateChanged</code>后通知client)</li></ol></li><li>
<p><strong>master</strong> to <strong>worker</strong></p>
<ol><li><code>LaunchExecutor</code> (发送消息启动Executor环境)</li><li><code>RegisteredWorker</code> (作为worker向master注册的reply)</li><li><code>RegisterWorkerFailed</code> (作为worker向master注册失败的reply)</li><li><code>KillExecutor</code> (发送给worker请求停止executor环境)</li></ol></li><li>
<p><strong>worker</strong> to <strong>master</strong></p>
<ol><li><code>RegisterWorker</code> (向master注册自己)</li><li><code>Heartbeat</code> (定期向master发送心跳信息)</li><li><code>ExecutorStateChanged</code> (向master发送Executor状态改变信息)</li></ol></li></ul><h1 id="deploy_3">Deploy模块代码详解</h1>
<p>Deploy模块相比于scheduler模块简单，因此对于deploy模块的代码并不做十分细节的分析，只针对application的提交和结束过程做一定的分析。</p>
<h2 id="clientapplication">Client提交application</h2>
<p>Client是由<code>SparkDeploySchedulerBackend</code>创建被启动的，因此client是被嵌入在每一个application中，只为这个applicator所服务，在client启动时首先会先master注册application：</p>
<pre class="prettyprint linenums prettyprinted" style="overflow:auto;"></pre><ol class="linenums"><li class="L0"><code><span class="kwd">def</span><span class="pln"> start</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span></code></li><li class="L1"><code><span class="pln">  </span><span class="com">// Just launch an actor; it will call back into the listener.</span></code></li><li class="L2"><code><span class="pln">  actor </span><span class="pun">=</span><span class="pln"> actorSystem</span><span class="pun">.</span><span class="pln">actorOf</span><span class="pun">(</span><span class="typ">Props</span><span class="pun">(</span><span class="kwd">new</span><span class="pln"> </span><span class="typ">ClientActor</span><span class="pun">))</span></code></li><li class="L3"><code><span class="pun">}</span></code></li><li class="L4"><code></code>
</li><li class="L5"><code><span class="kwd">override</span><span class="pln"> </span><span class="kwd">def</span><span class="pln"> preStart</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span></code></li><li class="L6"><code><span class="pln">  logInfo</span><span class="pun">(</span><span class="str">"Connecting to master "</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> masterUrl</span><span class="pun">)</span></code></li><li class="L7"><code><span class="pln">  </span><span class="kwd">try</span><span class="pln"> </span><span class="pun">{</span></code></li><li class="L8"><code><span class="pln">    master </span><span class="pun">=</span><span class="pln"> context</span><span class="pun">.</span><span class="pln">actorFor</span><span class="pun">(</span><span class="typ">Master</span><span class="pun">.</span><span class="pln">toAkkaUrl</span><span class="pun">(</span><span class="pln">masterUrl</span><span class="pun">))</span></code></li><li class="L9"><code><span class="pln">    masterAddress </span><span class="pun">=</span><span class="pln"> master</span><span class="pun">.</span><span class="pln">path</span><span class="pun">.</span><span class="pln">address</span></code></li><li class="L0"><code><span class="pln">    master </span><span class="pun">!</span><span class="pln"> </span><span class="typ">RegisterApplication</span><span class="pun">(</span><span class="pln">appDescription</span><span class="pun">)</span><span class="pln"> </span><span class="com">//向master注册application</span></code></li><li class="L1"><code><span class="pln">    context</span><span class="pun">.</span><span class="pln">system</span><span class="pun">.</span><span class="pln">eventStream</span><span class="pun">.</span><span class="pln">subscribe</span><span class="pun">(</span><span class="kwd">self</span><span class="pun">,</span><span class="pln"> classOf</span><span class="pun">[</span><span class="typ">RemoteClientLifeCycleEvent</span><span class="pun">])</span></code></li><li class="L2"><code><span class="pln">    context</span><span class="pun">.</span><span class="pln">watch</span><span class="pun">(</span><span class="pln">master</span><span class="pun">)</span><span class="pln">  </span><span class="com">// Doesn't work with remote actors, but useful for testing</span></code></li><li class="L3"><code><span class="pln">  </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">catch</span><span class="pln"> </span><span class="pun">{</span></code></li><li class="L4"><code><span class="pln">    </span><span class="kwd">case</span><span class="pln"> e</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Exception</span><span class="pln"> </span><span class="pun">=&gt;</span></code></li><li class="L5"><code><span class="pln">      logError</span><span class="pun">(</span><span class="str">"Failed to connect to master"</span><span class="pun">,</span><span class="pln"> e</span><span class="pun">)</span></code></li><li class="L6"><code><span class="pln">      markDisconnected</span><span class="pun">()</span></code></li><li class="L7"><code><span class="pln">      context</span><span class="pun">.</span><span class="pln">stop</span><span class="pun">(</span><span class="kwd">self</span><span class="pun">)</span></code></li><li class="L8"><code><span class="pln">  </span><span class="pun">}</span></code></li><li class="L9"><code><span class="pun">}</span></code></li></ol>
<p>Master在收到<code>RegisterApplication</code>请求后会把application加到等待队列中，等待调度：</p>
<pre class="prettyprint linenums prettyprinted" style="overflow:auto;"></pre><ol class="linenums"><li class="L0"><code><span class="kwd">case</span><span class="pln"> </span><span class="typ">RegisterApplication</span><span class="pun">(</span><span class="pln">description</span><span class="pun">)</span><span class="pln"> </span><span class="pun">=&gt;</span><span class="pln"> </span><span class="pun">{</span></code></li><li class="L1"><code><span class="pln">  logInfo</span><span class="pun">(</span><span class="str">"Registering app "</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> description</span><span class="pun">.</span><span class="pln">name</span><span class="pun">)</span></code></li><li class="L2"><code><span class="pln">  val app </span><span class="pun">=</span><span class="pln"> addApplication</span><span class="pun">(</span><span class="pln">description</span><span class="pun">,</span><span class="pln"> sender</span><span class="pun">)</span></code></li><li class="L3"><code><span class="pln">  logInfo</span><span class="pun">(</span><span class="str">"Registered app "</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> description</span><span class="pun">.</span><span class="pln">name </span><span class="pun">+</span><span class="pln"> </span><span class="str">" with ID "</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> app</span><span class="pun">.</span><span class="pln">id</span><span class="pun">)</span></code></li><li class="L4"><code><span class="pln">  waitingApps </span><span class="pun">+=</span><span class="pln"> app</span></code></li><li class="L5"><code><span class="pln">  context</span><span class="pun">.</span><span class="pln">watch</span><span class="pun">(</span><span class="pln">sender</span><span class="pun">)</span><span class="pln">  </span><span class="com">// This doesn't work with remote actors but helps for testing</span></code></li><li class="L6"><code><span class="pln">  sender </span><span class="pun">!</span><span class="pln"> </span><span class="typ">RegisteredApplication</span><span class="pun">(</span><span class="pln">app</span><span class="pun">.</span><span class="pln">id</span><span class="pun">)</span></code></li><li class="L7"><code><span class="pln">  schedule</span><span class="pun">()</span></code></li><li class="L8"><code><span class="pun">}</span></code></li></ol>
<p>Master会在每次操作后调用<code>schedule()</code>函数，以确保等待的application能够被及时调度。</p>
<p>在前面提到deploy模块是资源管理模块，那么Spark的deploy管理的是什么资源，资源以什么单位进行调度的呢？在当前版本的Spark中，集群的cpu数量是Spark资源管理的一个标准，每个提交的application都会标明自己所需要的资源数(也就是cpu的core数)，Master以FIFO的方式管理所有的application请求，当资源数量满足当前任务执行需求的时候该任务就会被调度，否则就继续等待，当然如果master能给予当前任务部分资源则也会启动该application。<code>schedule()</code>函数实现的就是此功能。</p>
<pre class="prettyprint linenums prettyprinted" style="overflow:auto;"></pre><ol class="linenums"><li class="L0"><code><span class="kwd">def</span><span class="pln"> schedule</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span></code></li><li class="L1"><code><span class="pln">  </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">spreadOutApps</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span></code></li><li class="L2"><code><span class="pln">    </span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="pln">app </span><span class="pun">&lt;-</span><span class="pln"> waitingApps </span><span class="kwd">if</span><span class="pln"> app</span><span class="pun">.</span><span class="pln">coresLeft </span><span class="pun">&gt;</span><span class="pln"> </span><span class="lit">0</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span></code></li><li class="L3"><code><span class="pln">      val usableWorkers </span><span class="pun">=</span><span class="pln"> workers</span><span class="pun">.</span><span class="pln">toArray</span><span class="pun">.</span><span class="pln">filter</span><span class="pun">(</span><span class="pln">_</span><span class="pun">.</span><span class="pln">state </span><span class="pun">==</span><span class="pln"> </span><span class="typ">WorkerState</span><span class="pun">.</span><span class="pln">ALIVE</span><span class="pun">)</span></code></li><li class="L4"><code><span class="pln">                                 </span><span class="pun">.</span><span class="pln">filter</span><span class="pun">(</span><span class="pln">canUse</span><span class="pun">(</span><span class="pln">app</span><span class="pun">,</span><span class="pln"> _</span><span class="pun">)).</span><span class="pln">sortBy</span><span class="pun">(</span><span class="pln">_</span><span class="pun">.</span><span class="pln">coresFree</span><span class="pun">).</span><span class="pln">reverse</span></code></li><li class="L5"><code><span class="pln">      val numUsable </span><span class="pun">=</span><span class="pln"> usableWorkers</span><span class="pun">.</span><span class="pln">length</span></code></li><li class="L6"><code><span class="pln">      val assigned </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">Array</span><span class="pun">[</span><span class="typ">Int</span><span class="pun">](</span><span class="pln">numUsable</span><span class="pun">)</span><span class="pln"> </span><span class="com">// Number of cores to give on each node</span></code></li><li class="L7"><code><span class="pln">      </span><span class="kwd">var</span><span class="pln"> toAssign </span><span class="pun">=</span><span class="pln"> math</span><span class="pun">.</span><span class="pln">min</span><span class="pun">(</span><span class="pln">app</span><span class="pun">.</span><span class="pln">coresLeft</span><span class="pun">,</span><span class="pln"> usableWorkers</span><span class="pun">.</span><span class="pln">map</span><span class="pun">(</span><span class="pln">_</span><span class="pun">.</span><span class="pln">coresFree</span><span class="pun">).</span><span class="pln">sum</span><span class="pun">)</span></code></li><li class="L8"><code><span class="pln">      </span><span class="kwd">var</span><span class="pln"> pos </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span></code></li><li class="L9"><code><span class="pln">      </span><span class="kwd">while</span><span class="pln"> </span><span class="pun">(</span><span class="pln">toAssign </span><span class="pun">&gt;</span><span class="pln"> </span><span class="lit">0</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span></code></li><li class="L0"><code><span class="pln">        </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">usableWorkers</span><span class="pun">(</span><span class="pln">pos</span><span class="pun">).</span><span class="pln">coresFree </span><span class="pun">-</span><span class="pln"> assigned</span><span class="pun">(</span><span class="pln">pos</span><span class="pun">)</span><span class="pln"> </span><span class="pun">&gt;</span><span class="pln"> </span><span class="lit">0</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span></code></li><li class="L1"><code><span class="pln">          toAssign </span><span class="pun">-=</span><span class="pln"> </span><span class="lit">1</span></code></li><li class="L2"><code><span class="pln">          assigned</span><span class="pun">(</span><span class="pln">pos</span><span class="pun">)</span><span class="pln"> </span><span class="pun">+=</span><span class="pln"> </span><span class="lit">1</span></code></li><li class="L3"><code><span class="pln">        </span><span class="pun">}</span></code></li><li class="L4"><code><span class="pln">        pos </span><span class="pun">=</span><span class="pln"> </span><span class="pun">(</span><span class="pln">pos </span><span class="pun">+</span><span class="pln"> </span><span class="lit">1</span><span class="pun">)</span><span class="pln"> </span><span class="pun">%</span><span class="pln"> numUsable</span></code></li><li class="L5"><code><span class="pln">      </span><span class="pun">}</span></code></li><li class="L6"><code><span class="pln">      </span><span class="com">// Now that we've decided how many cores to give on each node, let's actually give them</span></code></li><li class="L7"><code><span class="pln">      </span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="pln">pos </span><span class="pun">&lt;-</span><span class="pln"> </span><span class="lit">0</span><span class="pln"> </span><span class="kwd">until</span><span class="pln"> numUsable</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span></code></li><li class="L8"><code><span class="pln">        </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">assigned</span><span class="pun">(</span><span class="pln">pos</span><span class="pun">)</span><span class="pln"> </span><span class="pun">&gt;</span><span class="pln"> </span><span class="lit">0</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span></code></li><li class="L9"><code><span class="pln">          val </span><span class="kwd">exec</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> app</span><span class="pun">.</span><span class="pln">addExecutor</span><span class="pun">(</span><span class="pln">usableWorkers</span><span class="pun">(</span><span class="pln">pos</span><span class="pun">),</span><span class="pln"> assigned</span><span class="pun">(</span><span class="pln">pos</span><span class="pun">))</span></code></li><li class="L0"><code><span class="pln">          launchExecutor</span><span class="pun">(</span><span class="pln">usableWorkers</span><span class="pun">(</span><span class="pln">pos</span><span class="pun">),</span><span class="pln"> </span><span class="kwd">exec</span><span class="pun">,</span><span class="pln"> app</span><span class="pun">.</span><span class="pln">desc</span><span class="pun">.</span><span class="pln">sparkHome</span><span class="pun">)</span></code></li><li class="L1"><code><span class="pln">          app</span><span class="pun">.</span><span class="pln">state </span><span class="pun">=</span><span class="pln"> </span><span class="typ">ApplicationState</span><span class="pun">.</span><span class="pln">RUNNING</span></code></li><li class="L2"><code><span class="pln">        </span><span class="pun">}</span></code></li><li class="L3"><code><span class="pln">      </span><span class="pun">}</span></code></li><li class="L4"><code><span class="pln">    </span><span class="pun">}</span></code></li><li class="L5"><code><span class="pln">  </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">else</span><span class="pln"> </span><span class="pun">{</span></code></li><li class="L6"><code><span class="pln">    </span><span class="com">// Pack each app into as few nodes as possible until we've assigned all its cores</span></code></li><li class="L7"><code><span class="pln">    </span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="pln">worker </span><span class="pun">&lt;-</span><span class="pln"> workers </span><span class="kwd">if</span><span class="pln"> worker</span><span class="pun">.</span><span class="pln">coresFree </span><span class="pun">&gt;</span><span class="pln"> </span><span class="lit">0</span><span class="pln"> </span><span class="pun">&amp;&amp;</span><span class="pln"> worker</span><span class="pun">.</span><span class="pln">state </span><span class="pun">==</span><span class="pln"> </span><span class="typ">WorkerState</span><span class="pun">.</span><span class="pln">ALIVE</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span></code></li><li class="L8"><code><span class="pln">      </span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="pln">app </span><span class="pun">&lt;-</span><span class="pln"> waitingApps </span><span class="kwd">if</span><span class="pln"> app</span><span class="pun">.</span><span class="pln">coresLeft </span><span class="pun">&gt;</span><span class="pln"> </span><span class="lit">0</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span></code></li><li class="L9"><code><span class="pln">        </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">canUse</span><span class="pun">(</span><span class="pln">app</span><span class="pun">,</span><span class="pln"> worker</span><span class="pun">))</span><span class="pln"> </span><span class="pun">{</span></code></li><li class="L0"><code><span class="pln">          val coresToUse </span><span class="pun">=</span><span class="pln"> math</span><span class="pun">.</span><span class="pln">min</span><span class="pun">(</span><span class="pln">worker</span><span class="pun">.</span><span class="pln">coresFree</span><span class="pun">,</span><span class="pln"> app</span><span class="pun">.</span><span class="pln">coresLeft</span><span class="pun">)</span></code></li><li class="L1"><code><span class="pln">          </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">coresToUse </span><span class="pun">&gt;</span><span class="pln"> </span><span class="lit">0</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span></code></li><li class="L2"><code><span class="pln">            val </span><span class="kwd">exec</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> app</span><span class="pun">.</span><span class="pln">addExecutor</span><span class="pun">(</span><span class="pln">worker</span><span class="pun">,</span><span class="pln"> coresToUse</span><span class="pun">)</span></code></li><li class="L3"><code><span class="pln">            launchExecutor</span><span class="pun">(</span><span class="pln">worker</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">exec</span><span class="pun">,</span><span class="pln"> app</span><span class="pun">.</span><span class="pln">desc</span><span class="pun">.</span><span class="pln">sparkHome</span><span class="pun">)</span></code></li><li class="L4"><code><span class="pln">            app</span><span class="pun">.</span><span class="pln">state </span><span class="pun">=</span><span class="pln"> </span><span class="typ">ApplicationState</span><span class="pun">.</span><span class="pln">RUNNING</span></code></li><li class="L5"><code><span class="pln">          </span><span class="pun">}</span></code></li><li class="L6"><code><span class="pln">        </span><span class="pun">}</span></code></li><li class="L7"><code><span class="pln">      </span><span class="pun">}</span></code></li><li class="L8"><code><span class="pln">    </span><span class="pun">}</span></code></li><li class="L9"><code><span class="pln">  </span><span class="pun">}</span></code></li><li class="L0"><code><span class="pun">}</span></code></li></ol>
<p>当application得到调度后就会调用<code>launchExecutor()</code>向worker发送请求，同时向client汇报状态：</p>
<pre class="prettyprint linenums prettyprinted" style="overflow:auto;"></pre><ol class="linenums"><li class="L0"><code><span class="kwd">def</span><span class="pln"> launchExecutor</span><span class="pun">(</span><span class="pln">worker</span><span class="pun">:</span><span class="pln"> </span><span class="typ">WorkerInfo</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">exec</span><span class="pun">:</span><span class="pln"> </span><span class="typ">ExecutorInfo</span><span class="pun">,</span><span class="pln"> sparkHome</span><span class="pun">:</span><span class="pln"> </span><span class="typ">String</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span></code></li><li class="L1"><code><span class="pln">  worker</span><span class="pun">.</span><span class="pln">addExecutor</span><span class="pun">(</span><span class="kwd">exec</span><span class="pun">)</span></code></li><li class="L2"><code><span class="pln">  worker</span><span class="pun">.</span><span class="pln">actor </span><span class="pun">!</span><span class="pln"> </span><span class="typ">LaunchExecutor</span><span class="pun">(</span><span class="kwd">exec</span><span class="pun">.</span><span class="pln">application</span><span class="pun">.</span><span class="pln">id</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">exec</span><span class="pun">.</span><span class="pln">id</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">exec</span><span class="pun">.</span><span class="pln">application</span><span class="pun">.</span><span class="pln">desc</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">exec</span><span class="pun">.</span><span class="pln">cores</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">exec</span><span class="pun">.</span><span class="pln">memory</span><span class="pun">,</span><span class="pln"> sparkHome</span><span class="pun">)</span></code></li><li class="L3"><code><span class="pln">  </span><span class="kwd">exec</span><span class="pun">.</span><span class="pln">application</span><span class="pun">.</span><span class="pln">driver </span><span class="pun">!</span><span class="pln"> </span><span class="typ">ExecutorAdded</span><span class="pun">(</span><span class="kwd">exec</span><span class="pun">.</span><span class="pln">id</span><span class="pun">,</span><span class="pln"> worker</span><span class="pun">.</span><span class="pln">id</span><span class="pun">,</span><span class="pln"> worker</span><span class="pun">.</span><span class="pln">host</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">exec</span><span class="pun">.</span><span class="pln">cores</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">exec</span><span class="pun">.</span><span class="pln">memory</span><span class="pun">)</span></code></li><li class="L4"><code><span class="pun">}</span></code></li></ol>
<p>至此client与master的交互已经转向了master与worker的交互，worker需要配置application启动环境</p>
<pre class="prettyprint linenums prettyprinted" style="overflow:auto;"></pre><ol class="linenums"><li class="L0"><code><span class="kwd">case</span><span class="pln"> </span><span class="typ">LaunchExecutor</span><span class="pun">(</span><span class="pln">appId</span><span class="pun">,</span><span class="pln"> execId</span><span class="pun">,</span><span class="pln"> appDesc</span><span class="pun">,</span><span class="pln"> cores_</span><span class="pun">,</span><span class="pln"> memory_</span><span class="pun">,</span><span class="pln"> execSparkHome_</span><span class="pun">)</span><span class="pln"> </span><span class="pun">=&gt;</span></code></li><li class="L1"><code><span class="pln">  val manager </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">ExecutorRunner</span><span class="pun">(</span></code></li><li class="L2"><code><span class="pln">    appId</span><span class="pun">,</span><span class="pln"> execId</span><span class="pun">,</span><span class="pln"> appDesc</span><span class="pun">,</span><span class="pln"> cores_</span><span class="pun">,</span><span class="pln"> memory_</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">self</span><span class="pun">,</span><span class="pln"> workerId</span><span class="pun">,</span><span class="pln"> ip</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">File</span><span class="pun">(</span><span class="pln">execSparkHome_</span><span class="pun">),</span><span class="pln"> workDir</span><span class="pun">)</span></code></li><li class="L3"><code><span class="pln">  executors</span><span class="pun">(</span><span class="pln">appId </span><span class="pun">+</span><span class="pln"> </span><span class="str">"/"</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> execId</span><span class="pun">)</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> manager</span></code></li><li class="L4"><code><span class="pln">  manager</span><span class="pun">.</span><span class="pln">start</span><span class="pun">()</span></code></li><li class="L5"><code><span class="pln">  coresUsed </span><span class="pun">+=</span><span class="pln"> cores_</span></code></li><li class="L6"><code><span class="pln">  memoryUsed </span><span class="pun">+=</span><span class="pln"> memory_</span></code></li><li class="L7"><code><span class="pln">  master </span><span class="pun">!</span><span class="pln"> </span><span class="typ">ExecutorStateChanged</span><span class="pun">(</span><span class="pln">appId</span><span class="pun">,</span><span class="pln"> execId</span><span class="pun">,</span><span class="pln"> </span><span class="typ">ExecutorState</span><span class="pun">.</span><span class="pln">RUNNING</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">None</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">None</span><span class="pun">)</span></code></li></ol>
<p>Worker在接收到<code>LaunchExecutor</code>消息后创建<code>ExecutorRunner</code>实例，同时汇报master executor环境启动。</p>
<p><code>ExecutorRunner</code>在启动的过程中会创建线程，配置环境，启动新进程：</p>
<pre class="prettyprint linenums prettyprinted" style="overflow:auto;"></pre><ol class="linenums"><li class="L0"><code><span class="kwd">def</span><span class="pln"> start</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span></code></li><li class="L1"><code><span class="pln">  workerThread </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">Thread</span><span class="pun">(</span><span class="str">"ExecutorRunner for "</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> fullId</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span></code></li><li class="L2"><code><span class="pln">    </span><span class="kwd">override</span><span class="pln"> </span><span class="kwd">def</span><span class="pln"> run</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> fetchAndRunExecutor</span><span class="pun">()</span><span class="pln"> </span><span class="pun">}</span></code></li><li class="L3"><code><span class="pln">  </span><span class="pun">}</span></code></li><li class="L4"><code><span class="pln">  workerThread</span><span class="pun">.</span><span class="pln">start</span><span class="pun">()</span></code></li><li class="L5"><code></code>
</li><li class="L6"><code><span class="pln">  </span><span class="com">// Shutdown hook that kills actors on shutdown.</span></code></li><li class="L7"><code><span class="pln">  </span><span class="pun">...</span></code></li><li class="L8"><code><span class="pun">}</span></code></li><li class="L9"><code></code>
</li><li class="L0"><code><span class="kwd">def</span><span class="pln"> fetchAndRunExecutor</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span></code></li><li class="L1"><code><span class="pln">  </span><span class="kwd">try</span><span class="pln"> </span><span class="pun">{</span></code></li><li class="L2"><code><span class="pln">    </span><span class="com">// Create the executor's working directory</span></code></li><li class="L3"><code><span class="pln">    val executorDir </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">File</span><span class="pun">(</span><span class="pln">workDir</span><span class="pun">,</span><span class="pln"> appId </span><span class="pun">+</span><span class="pln"> </span><span class="str">"/"</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> execId</span><span class="pun">)</span></code></li><li class="L4"><code><span class="pln">    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(!</span><span class="pln">executorDir</span><span class="pun">.</span><span class="pln">mkdirs</span><span class="pun">())</span><span class="pln"> </span><span class="pun">{</span></code></li><li class="L5"><code><span class="pln">      </span><span class="kwd">throw</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">IOException</span><span class="pun">(</span><span class="str">"Failed to create directory "</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> executorDir</span><span class="pun">)</span></code></li><li class="L6"><code><span class="pln">    </span><span class="pun">}</span></code></li><li class="L7"><code></code>
</li><li class="L8"><code><span class="pln">    </span><span class="com">// Launch the process</span></code></li><li class="L9"><code><span class="pln">    val command </span><span class="pun">=</span><span class="pln"> buildCommandSeq</span><span class="pun">()</span></code></li><li class="L0"><code><span class="pln">    val builder </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">ProcessBuilder</span><span class="pun">(</span><span class="pln">command</span><span class="pun">:</span><span class="pln"> _</span><span class="pun">*).</span><span class="pln">directory</span><span class="pun">(</span><span class="pln">executorDir</span><span class="pun">)</span></code></li><li class="L1"><code><span class="pln">    val env </span><span class="pun">=</span><span class="pln"> builder</span><span class="pun">.</span><span class="pln">environment</span><span class="pun">()</span></code></li><li class="L2"><code><span class="pln">    </span><span class="kwd">for</span><span class="pln"> </span><span class="pun">((</span><span class="pln">key</span><span class="pun">,</span><span class="pln"> value</span><span class="pun">)</span><span class="pln"> </span><span class="pun">&lt;-</span><span class="pln"> appDesc</span><span class="pun">.</span><span class="pln">command</span><span class="pun">.</span><span class="pln">environment</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span></code></li><li class="L3"><code><span class="pln">      env</span><span class="pun">.</span><span class="pln">put</span><span class="pun">(</span><span class="pln">key</span><span class="pun">,</span><span class="pln"> value</span><span class="pun">)</span></code></li><li class="L4"><code><span class="pln">    </span><span class="pun">}</span></code></li><li class="L5"><code><span class="pln">    env</span><span class="pun">.</span><span class="pln">put</span><span class="pun">(</span><span class="str">"SPARK_MEM"</span><span class="pun">,</span><span class="pln"> memory</span><span class="pun">.</span><span class="pln">toString </span><span class="pun">+</span><span class="pln"> </span><span class="str">"m"</span><span class="pun">)</span></code></li><li class="L6"><code><span class="pln">    </span><span class="com">// In case we are running this from within the Spark Shell, avoid creating a "scala"</span></code></li><li class="L7"><code><span class="pln">    </span><span class="com">// parent process for the executor command</span></code></li><li class="L8"><code><span class="pln">    env</span><span class="pun">.</span><span class="pln">put</span><span class="pun">(</span><span class="str">"SPARK_LAUNCH_WITH_SCALA"</span><span class="pun">,</span><span class="pln"> </span><span class="str">"0"</span><span class="pun">)</span></code></li><li class="L9"><code><span class="pln">    process </span><span class="pun">=</span><span class="pln"> builder</span><span class="pun">.</span><span class="pln">start</span><span class="pun">()</span></code></li><li class="L0"><code></code>
</li><li class="L1"><code><span class="pln">    </span><span class="com">// Redirect its stdout and stderr to files</span></code></li><li class="L2"><code><span class="pln">    redirectStream</span><span class="pun">(</span><span class="pln">process</span><span class="pun">.</span><span class="pln">getInputStream</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">File</span><span class="pun">(</span><span class="pln">executorDir</span><span class="pun">,</span><span class="pln"> </span><span class="str">"stdout"</span><span class="pun">))</span></code></li><li class="L3"><code><span class="pln">    redirectStream</span><span class="pun">(</span><span class="pln">process</span><span class="pun">.</span><span class="pln">getErrorStream</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">File</span><span class="pun">(</span><span class="pln">executorDir</span><span class="pun">,</span><span class="pln"> </span><span class="str">"stderr"</span><span class="pun">))</span></code></li><li class="L4"><code></code>
</li><li class="L5"><code><span class="pln">    </span><span class="com">// Wait for it to exit; this is actually a bad thing if it happens, because we expect to run</span></code></li><li class="L6"><code><span class="pln">    </span><span class="com">// long-lived processes only. However, in the future, we might restart the executor a few</span></code></li><li class="L7"><code><span class="pln">    </span><span class="com">// times on the same machine.</span></code></li><li class="L8"><code><span class="pln">    val exitCode </span><span class="pun">=</span><span class="pln"> process</span><span class="pun">.</span><span class="pln">waitFor</span><span class="pun">()</span></code></li><li class="L9"><code><span class="pln">    val message </span><span class="pun">=</span><span class="pln"> </span><span class="str">"Command exited with code "</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> exitCode</span></code></li><li class="L0"><code><span class="pln">    worker </span><span class="pun">!</span><span class="pln"> </span><span class="typ">ExecutorStateChanged</span><span class="pun">(</span><span class="pln">appId</span><span class="pun">,</span><span class="pln"> execId</span><span class="pun">,</span><span class="pln"> </span><span class="typ">ExecutorState</span><span class="pun">.</span><span class="pln">FAILED</span><span class="pun">,</span><span class="pln"> </span><span class="typ">Some</span><span class="pun">(</span><span class="pln">message</span><span class="pun">),</span></code></li><li class="L1"><code><span class="pln">                                  </span><span class="typ">Some</span><span class="pun">(</span><span class="pln">exitCode</span><span class="pun">))</span></code></li><li class="L2"><code><span class="pln">  </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">catch</span><span class="pln"> </span><span class="pun">{</span></code></li><li class="L3"><code><span class="pln">    </span><span class="kwd">case</span><span class="pln"> interrupted</span><span class="pun">:</span><span class="pln"> </span><span class="typ">InterruptedException</span><span class="pln"> </span><span class="pun">=&gt;</span></code></li><li class="L4"><code><span class="pln">      logInfo</span><span class="pun">(</span><span class="str">"Runner thread for executor "</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> fullId </span><span class="pun">+</span><span class="pln"> </span><span class="str">" interrupted"</span><span class="pun">)</span></code></li><li class="L5"><code></code>
</li><li class="L6"><code><span class="pln">    </span><span class="kwd">case</span><span class="pln"> e</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Exception</span><span class="pln"> </span><span class="pun">=&gt;</span><span class="pln"> </span><span class="pun">{</span></code></li><li class="L7"><code><span class="pln">      logError</span><span class="pun">(</span><span class="str">"Error running executor"</span><span class="pun">,</span><span class="pln"> e</span><span class="pun">)</span></code></li><li class="L8"><code><span class="pln">      </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">process </span><span class="pun">!=</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span></code></li><li class="L9"><code><span class="pln">        process</span><span class="pun">.</span><span class="pln">destroy</span><span class="pun">()</span></code></li><li class="L0"><code><span class="pln">      </span><span class="pun">}</span></code></li><li class="L1"><code><span class="pln">      val message </span><span class="pun">=</span><span class="pln"> e</span><span class="pun">.</span><span class="pln">getClass </span><span class="pun">+</span><span class="pln"> </span><span class="str">": "</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> e</span><span class="pun">.</span><span class="pln">getMessage</span></code></li><li class="L2"><code><span class="pln">      worker </span><span class="pun">!</span><span class="pln"> </span><span class="typ">ExecutorStateChanged</span><span class="pun">(</span><span class="pln">appId</span><span class="pun">,</span><span class="pln"> execId</span><span class="pun">,</span><span class="pln"> </span><span class="typ">ExecutorState</span><span class="pun">.</span><span class="pln">FAILED</span><span class="pun">,</span><span class="pln"> </span><span class="typ">Some</span><span class="pun">(</span><span class="pln">message</span><span class="pun">),</span><span class="pln"> </span><span class="kwd">None</span><span class="pun">)</span></code></li><li class="L3"><code><span class="pln">    </span><span class="pun">}</span></code></li><li class="L4"><code><span class="pln">  </span><span class="pun">}</span></code></li><li class="L5"><code><span class="pun">}</span></code></li></ol>
<p>在<code>ExecutorRunner</code>启动后worker向master汇报<code>ExecutorStateChanged</code>，而master则将消息重新pack成为<code>ExecutorUpdated</code>发送给client。</p>
<p>至此整个application提交过程基本结束，提交的过程并不复杂，主要涉及到的消息的传递。</p>
<h2 id="application">Application的结束</h2>
<p>由于各种原因(包括正常结束，异常返回等)会造成application的结束，我们现在就来看看applicatoin结束的整个流程。</p>
<p>application的结束往往会造成client的结束，而client的结束会被master通过<code>Actor</code>检测到，master检测到后会调用<code>removeApplication()</code>函数进行操作：</p>
<pre class="prettyprint linenums prettyprinted" style="overflow:auto;"></pre><ol class="linenums"><li class="L0"><code><span class="kwd">def</span><span class="pln"> removeApplication</span><span class="pun">(</span><span class="pln">app</span><span class="pun">:</span><span class="pln"> </span><span class="typ">ApplicationInfo</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span></code></li><li class="L1"><code><span class="pln">  </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">apps</span><span class="pun">.</span><span class="pln">contains</span><span class="pun">(</span><span class="pln">app</span><span class="pun">))</span><span class="pln"> </span><span class="pun">{</span></code></li><li class="L2"><code><span class="pln">    logInfo</span><span class="pun">(</span><span class="str">"Removing app "</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> app</span><span class="pun">.</span><span class="pln">id</span><span class="pun">)</span></code></li><li class="L3"><code><span class="pln">    apps </span><span class="pun">-=</span><span class="pln"> app</span></code></li><li class="L4"><code><span class="pln">    idToApp </span><span class="pun">-=</span><span class="pln"> app</span><span class="pun">.</span><span class="pln">id</span></code></li><li class="L5"><code><span class="pln">    actorToApp </span><span class="pun">-=</span><span class="pln"> app</span><span class="pun">.</span><span class="pln">driver</span></code></li><li class="L6"><code><span class="pln">    addressToWorker </span><span class="pun">-=</span><span class="pln"> app</span><span class="pun">.</span><span class="pln">driver</span><span class="pun">.</span><span class="pln">path</span><span class="pun">.</span><span class="pln">address</span></code></li><li class="L7"><code><span class="pln">    completedApps </span><span class="pun">+=</span><span class="pln"> app   </span><span class="com">// Remember it in our history</span></code></li><li class="L8"><code><span class="pln">    waitingApps </span><span class="pun">-=</span><span class="pln"> app</span></code></li><li class="L9"><code><span class="pln">    </span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">exec</span><span class="pln"> </span><span class="pun">&lt;-</span><span class="pln"> app</span><span class="pun">.</span><span class="pln">executors</span><span class="pun">.</span><span class="pln">values</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span></code></li><li class="L0"><code><span class="pln">      </span><span class="kwd">exec</span><span class="pun">.</span><span class="pln">worker</span><span class="pun">.</span><span class="pln">removeExecutor</span><span class="pun">(</span><span class="kwd">exec</span><span class="pun">)</span></code></li><li class="L1"><code><span class="pln">      </span><span class="kwd">exec</span><span class="pun">.</span><span class="pln">worker</span><span class="pun">.</span><span class="pln">actor </span><span class="pun">!</span><span class="pln"> </span><span class="typ">KillExecutor</span><span class="pun">(</span><span class="kwd">exec</span><span class="pun">.</span><span class="pln">application</span><span class="pun">.</span><span class="pln">id</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">exec</span><span class="pun">.</span><span class="pln">id</span><span class="pun">)</span></code></li><li class="L2"><code><span class="pln">    </span><span class="pun">}</span></code></li><li class="L3"><code><span class="pln">    app</span><span class="pun">.</span><span class="pln">markFinished</span><span class="pun">(</span><span class="typ">ApplicationState</span><span class="pun">.</span><span class="pln">FINISHED</span><span class="pun">)</span><span class="pln">  </span><span class="com">// TODO: Mark it as FAILED if it failed</span></code></li><li class="L4"><code><span class="pln">    schedule</span><span class="pun">()</span></code></li><li class="L5"><code><span class="pln">  </span><span class="pun">}</span></code></li><li class="L6"><code><span class="pun">}</span></code></li></ol>
<p><code>removeApplicatoin()</code>首先会将application从master自身所管理的数据结构中删除，其次它会通知每一个work，请求其<code>KillExecutor</code>。worker在收到<code>KillExecutor</code>后调用<code>ExecutorRunner</code>的<code>kill()</code>函数：</p>
<pre class="prettyprint linenums prettyprinted" style="overflow:auto;"></pre><ol class="linenums"><li class="L0"><code><span class="kwd">case</span><span class="pln"> </span><span class="typ">KillExecutor</span><span class="pun">(</span><span class="pln">appId</span><span class="pun">,</span><span class="pln"> execId</span><span class="pun">)</span><span class="pln"> </span><span class="pun">=&gt;</span></code></li><li class="L1"><code><span class="pln">  val fullId </span><span class="pun">=</span><span class="pln"> appId </span><span class="pun">+</span><span class="pln"> </span><span class="str">"/"</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> execId</span></code></li><li class="L2"><code><span class="pln">  executors</span><span class="pun">.</span><span class="kwd">get</span><span class="pun">(</span><span class="pln">fullId</span><span class="pun">)</span><span class="pln"> match </span><span class="pun">{</span></code></li><li class="L3"><code><span class="pln">    </span><span class="kwd">case</span><span class="pln"> </span><span class="typ">Some</span><span class="pun">(</span><span class="pln">executor</span><span class="pun">)</span><span class="pln"> </span><span class="pun">=&gt;</span></code></li><li class="L4"><code><span class="pln">      logInfo</span><span class="pun">(</span><span class="str">"Asked to kill executor "</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> fullId</span><span class="pun">)</span></code></li><li class="L5"><code><span class="pln">      executor</span><span class="pun">.</span><span class="pln">kill</span><span class="pun">()</span></code></li><li class="L6"><code><span class="pln">    </span><span class="kwd">case</span><span class="pln"> </span><span class="kwd">None</span><span class="pln"> </span><span class="pun">=&gt;</span></code></li><li class="L7"><code><span class="pln">      logInfo</span><span class="pun">(</span><span class="str">"Asked to kill unknown executor "</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> fullId</span><span class="pun">)</span></code></li><li class="L8"><code><span class="pln">  </span><span class="pun">}</span></code></li></ol>
<p>在<code>ExecutorRunner</code>内部，它会结束监控线程，同时结束监控线程所启动的进程，并且向worker汇报<code>ExecutorStateChanged</code>：</p>
<pre class="prettyprint linenums prettyprinted" style="overflow:auto;"></pre><ol class="linenums"><li class="L0"><code><span class="kwd">def</span><span class="pln"> kill</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span></code></li><li class="L1"><code><span class="pln">  </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">workerThread </span><span class="pun">!=</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span></code></li><li class="L2"><code><span class="pln">    workerThread</span><span class="pun">.</span><span class="pln">interrupt</span><span class="pun">()</span></code></li><li class="L3"><code><span class="pln">    workerThread </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">null</span></code></li><li class="L4"><code><span class="pln">    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">process </span><span class="pun">!=</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span></code></li><li class="L5"><code><span class="pln">      logInfo</span><span class="pun">(</span><span class="str">"Killing process!"</span><span class="pun">)</span></code></li><li class="L6"><code><span class="pln">      process</span><span class="pun">.</span><span class="pln">destroy</span><span class="pun">()</span></code></li><li class="L7"><code><span class="pln">      process</span><span class="pun">.</span><span class="pln">waitFor</span><span class="pun">()</span></code></li><li class="L8"><code><span class="pln">    </span><span class="pun">}</span></code></li><li class="L9"><code><span class="pln">    worker </span><span class="pun">!</span><span class="pln"> </span><span class="typ">ExecutorStateChanged</span><span class="pun">(</span><span class="pln">appId</span><span class="pun">,</span><span class="pln"> execId</span><span class="pun">,</span><span class="pln"> </span><span class="typ">ExecutorState</span><span class="pun">.</span><span class="pln">KILLED</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">None</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">None</span><span class="pun">)</span></code></li><li class="L0"><code><span class="pln">    </span><span class="typ">Runtime</span><span class="pun">.</span><span class="pln">getRuntime</span><span class="pun">.</span><span class="pln">removeShutdownHook</span><span class="pun">(</span><span class="pln">shutdownHook</span><span class="pun">)</span></code></li><li class="L1"><code><span class="pln">  </span><span class="pun">}</span></code></li><li class="L2"><code><span class="pun">}</span></code></li></ol>
<p>Application结束的同时清理了master和worker上的关于该application的所有信息，这样关于application结束的整个流程就介绍完了，当然在这里我们对于许多异常处理分支没有细究，但这并不影响我们对主线的把握。</p>
<h1 id="end">End</h1>
<p>至此对于deploy模块的分析暂告一个段落。deploy模块相对来说比较简单，也没有特别复杂的逻辑结构，正如前面所说的deploy模块是为了能让更多的没有部署Mesos的集群的用户能够使用Spark而实现的一种方案。</p>
<p>当然现阶段看来还略微简陋，比如application的调度方式(FIFO)是否会造成小应用长时间等待大应用的结束，是否有更好的调度策略；资源的衡量标准是否可以更多更合理，而不单单是cpu数量，因为现实场景中有的应用是disk intensive，有的是network intensive，这样就算cpu资源有富余，调度新的application也不一定会很有意义。</p>
<p>总的来说作为Mesos的一种简单替代方式，deploy模块对于推广Spark还是有积极意义的。</p>
</div>
            </div>
                </div>