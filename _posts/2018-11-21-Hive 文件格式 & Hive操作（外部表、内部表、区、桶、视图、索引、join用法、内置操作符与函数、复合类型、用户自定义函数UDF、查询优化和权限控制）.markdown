---
layout:     post
title:      Hive 文件格式 & Hive操作（外部表、内部表、区、桶、视图、索引、join用法、内置操作符与函数、复合类型、用户自定义函数UDF、查询优化和权限控制）
---
<div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post">
								            <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f76675cdea.css">
						<div class="htmledit_views" id="content_views">
                <p><span style="color:#0000ff;"><strong>本博文的主要内容如下:</strong></span></p><p><span style="color:#0000ff;">　　<strong>Hive文件存储格式</strong></span></p><p><span style="color:#0000ff;">　　<strong>Hive 操作之表操作：创建外、内部表</strong></span></p><p><span style="color:#0000ff;"><strong>　　Hive操作之表操作：表查询</strong></span></p><p><span style="color:#0000ff;"><strong>　　<strong>Hive操作之表操作：数据加载</strong></strong></span></p><p><span style="color:#0000ff;"><strong><strong>　　<strong><strong>Hive操作之表操作：插入单表、插入多表</strong></strong></strong></strong></span></p><p><span style="color:#0000ff;"><strong><strong><strong><strong>　　Hive语法结构：<strong>where 查询、<strong>all 和 distinct 选项、<strong>基于 Partition 的查询、<strong>基于 HAVING 的查询、<strong> LIMIT 限制查询、<strong> GROUP BY 分组查询、<strong> ORDER 　　　　　　　　　  BY 排序查询、<strong>SORT BY 查询、<strong>DISTRIBUTE BY 排序查询、<strong>CLUSTER BY 查询</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></span></p><p><span style="color:#0000ff;"><strong>　　Hive操作之视图操作</strong></span></p><p><span style="color:#0000ff;"><strong>　　Hive操作之索引操作</strong></span></p><p><span style="color:#0000ff;"><strong>　　Hive操作之分区操作：创建分区</strong></span></p><p><span style="color:#0000ff;"><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>　　<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>Hive操作之分区操作：插入数据</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></span></p><p><span style="color:#0000ff;"><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>　　<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>Hive操作之分区操作：动态分区</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></span></p><p><span style="color:#0000ff;"><strong>　　Hive操作之桶操作</strong></span></p><p><span style="color:#0000ff;"><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>　　Hive操作之符合类型：<strong>Struct使用</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></span></p><p><span style="color:#0000ff;"><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>　　<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>Hive操作之符合类型：</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>Array使用</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></span></p><p><span style="color:#0000ff;"><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>　　<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>Hive操作之符合类型：</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>Map使用</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></span></p><p><span style="color:#0000ff;"><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>　　<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>Hive操作之join用法：<strong>等连接</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></span></p><p><span style="color:#0000ff;"><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>　　<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>Hive操作之join用法：</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>多表连接</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></span></p><p><span style="color:#0000ff;"><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>　　<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>Hive操作之join用法：join的缓存和任务转换</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></span></p><p><span style="color:#0000ff;">　　<strong>Hive操作之join用法：join的结果</strong></span></p><p><span style="color:#0000ff;"> 　 <strong>Hive操作之join用法：join的过滤</strong></span></p><p><span style="color:#0000ff;">　　<strong>Hive操作之join用法：join的顺序</strong></span></p><p><span style="color:#0000ff;">　　<strong>Hive操作之join用法：map 端 join</strong></span></p><p><span style="color:#0000ff;"> 　  <strong>Hive操作之Hive 内置操作符与函数：字符串函数</strong></span></p><p><span style="color:#0000ff;"><strong>　　<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>Hive操作之</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>Hive 内置操作符与函数：集合统计函数</strong></strong></span></p><p><span style="color:#0000ff;"><strong><strong>　　<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>Hive操作之复合类型操作：Map类型构建</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></span></p><p><span style="color:#0000ff;"><strong>　　Hive操作之复合类型操作：Struct 类型构建</strong></span></p><p><span style="color:#0000ff;"><strong>　　Hive操作之复合类型操作： Array 类型构建</strong></span></p><p><span style="color:#0000ff;">  　<strong>Hive操作之用户自定义函数 UDF</strong></span></p><p><span style="color:#0000ff;"> 　 <strong>Hive操作之Hive 查询优化：join优化</strong></span></p><p><span style="color:#0000ff;"><strong>　  <strong>Hive操作之Hive 查询优化：<strong>group by 优化</strong></strong></strong></span></p><p><span style="color:#0000ff;"> 　<strong> <strong>Hive操作之Hive 查询优化：</strong>合并小文件</strong></span></p><p><span style="color:#0000ff;"> 　  <strong>Hive操作之Hive 查询优化：Hive实现(not) in</strong></span></p><p><span style="color:#0000ff;"><strong><strong><strong><strong>　　<strong><strong>Hive操作之Hive 查询优化：</strong>排序优化</strong></strong></strong></strong></strong></span></p><p><span style="color:#0000ff;"><strong><strong><strong><strong>　　<strong><strong><strong><strong><strong><strong>Hive操作之Hive 查询优化：<strong>使用分区</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></span></p><p><span style="color:#0000ff;"> 　  <strong>Hive操作之Hive 查询优化：Distinct 使用</strong></span></p><p><span style="color:#0000ff;"><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>　　Hive操作之Hive 查询优化：<strong>Hql使用自定义的mapred脚本</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></span></p><p><span style="color:#0000ff;">　　<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>Hive操作之Hive 查询优化：<strong>UDTF</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></span></p><p><span style="color:#0000ff;"><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>　　<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>Hive操作之Hive 查询优化：</strong></strong></strong></strong></strong></strong></strong></strong></strong> 聚合函数count和sum</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></span></p><p><span style="color:#0000ff;"><strong>　　Hive操作之Hive的权限控制</strong></span></p><p><span style="color:#0000ff;"><strong>　　Hive操作之角色的创建和删除</strong></span></p><p><span style="color:#0000ff;"><strong>　　Hive操作之角色的授权和撤销</strong></span></p><p><span style="color:#0000ff;"><strong>　　Hive操作之Hive支持的权限控制</strong></span></p><p><span style="color:#0000ff;"><strong>　　Hive操作之超级管理权限</strong></span></p><p><span style="color:#0000ff;"><strong>　　Hive操作之Hive与JDBC示例</strong></span></p><p><span style="color:#0000ff;"><strong>　　Hive操作之Hive案例分析</strong></span></p><p> </p><p> </p><p> </p><p><strong>Hive文件存储格式包括以下几类：</strong></p><p>        1、<span style="color:#ff0000;"><strong>TEXTFILE</strong></span></p><p>        2、<span style="color:#ff0000;"><strong>SEQUENCEFILE</strong></span></p><p>        3、<span style="color:#ff0000;"><strong>RCFILE</strong></span></p><p>        4、<span style="color:#ff0000;"><strong>ORCFILE(0.11以后出现)</strong></span></p><p>     其中<span style="color:#0000ff;"><strong>TEXTFILE为</strong></span>默认格式，建表时不指定默认为这个格式，导入数据时会直接把数据文件拷贝到hdfs上不进行处理。</p><p>     <span style="color:#0000ff;"><strong>SEQUENCEFILE，RCFILE，ORCFILE格式的表不能</strong></span>直接从本地文件导入数据，数据要先导入到textfile格式的表中， 然后再从TextFile表中用insert导入SequenceFile,RCFile,ORCFile表中。</p><p>     <span style="color:#0000ff;"><strong>当用户的数据文件格式不能被当前Hive所识别的时候，可以自定义文件格式</strong>。</span>用户可以通过实现InputFormat和OutputFormat来自定义输入、输出格式。</p><p>　　</p><p>　　《其实，这些，都可以看Hadoop应用开发技术详解  刘刚》</p><p>更多用法，一定要去看官网啊！！！ </p><p><strong><a href="https://cwiki.apache.org/confluence/display/Hive/LanguageManual+DDL" rel="nofollow">https://cwiki.apache.org/confluence/display/Hive/LanguageManual+DDL</a></strong></p><p>  </p><p><span style="color:#0000ff;"><strong>一、TEXTFILE 格式</strong></span></p><p>     <span style="color:#0000ff;"><strong>默认格式</strong></span>，数据不做压缩，磁盘开销大，数据解析开销大。 可结合Gzip、Bzip2使用(系统自动检查，执行查询时自动解压)，但使用这种方式，Hive不会对数据进行切分， 从而无法对数据进行并行操作。</p><p> </p><p>示例：</p><div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a title="复制代码"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a title="复制代码"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div><pre>create table if not exists textfile_table(
site string,
url  string,
pv   bigint,
label string)
row format delimited
fields terminated by '\t'
stored as textfile;</pre><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a title="复制代码"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a title="复制代码"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div></div><pre>插入数据操作：</pre><div class="cnblogs_code"><pre>Hive&gt; set Hive.exec.compress.output=true;  
Hive&gt; set mapred.output.compress=true;  
Hive&gt; set mapred.output.compression.codec=org.apache.hadoop.io.compress.GzipCodec;  
Hive&gt; set io.compression.codecs=org.apache.hadoop.io.compress.GzipCodec;  
Hive&gt; insert overwrite table textfile_table select * from textfile_table; </pre></div><p> </p><p><span style="color:#0000ff;"><strong>二、SEQUENCEFILE 格式</strong></span></p><p> 　　SequenceFile是Hadoop API提供的一种二进制文件支持，其具有使用方便、可分割、可压缩的特点。 SequenceFile支持三种压缩选择：NONE，RECORD，BLOCK。Record压缩率低，一般建议使用BLOCK压缩。</p><p> </p><p>　　示例：</p><div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a title="复制代码"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a title="复制代码"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div><pre>create table if not exists seqfile_table(
site string,
url  string,
pv   bigint,
label string)
row format delimited
fields terminated by '\t'
stored as sequencefile;</pre><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a title="复制代码"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a title="复制代码"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div></div><p> </p><pre>插入数据操作：</pre><div class="cnblogs_code"><pre>Hive&gt; set Hive.exec.compress.output=true;  
Hive&gt; set mapred.output.compress=true;  
Hive&gt; set mapred.output.compression.codec=org.apache.hadoop.io.compress.GzipCodec;  
Hive&gt; set io.compression.codecs=org.apache.hadoop.io.compress.GzipCodec;  
Hive&gt; SET mapred.output.compression.type=BLOCK;
Hive&gt; insert overwrite table seqfile_table select * from textfile_table;  </pre></div><p> </p><p><span style="color:#0000ff;"><strong>三、RCFILE 文件格式</strong></span></p><p>　　RCFILE是一种行列存储相结合的存储方式。首先，其将数据按行分块，保证同一个record在一个块上，避免读一个记录需要读取多个block。其次，块数据列式存储，有利于数据压缩和快速的列存取。</p><p> </p><p>　　示例：</p><div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a title="复制代码"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a title="复制代码"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div><pre>create table if not exists rcfile_table(
site string,
url  string,
pv   bigint,
label string)
row format delimited
fields terminated by '\t'
stored as rcfile;</pre><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a title="复制代码"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a title="复制代码"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div></div><p> </p><pre>插入数据操作：</pre><div class="cnblogs_code"><pre>Hive&gt; set Hive.exec.compress.output=true;  
Hive&gt; set mapred.output.compress=true;  
Hive&gt; set mapred.output.compression.codec=org.apache.hadoop.io.compress.GzipCodec;  
Hive&gt; set io.compression.codecs=org.apache.hadoop.io.compress.GzipCodec;  
Hive&gt; insert overwrite table rcfile_table select * from textfile_table;</pre></div><p> </p><p><span style="color:#0000ff;"><strong>四、ORCFILE()</strong></span></p><p>　　省略</p><p><span style="color:#0000ff;"><strong>五、再看TEXTFILE、SEQUENCEFILE、RCFILE三种文件的存储情况：</strong></span></p><div><div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a title="复制代码"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a title="复制代码"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div><pre>[hadoop@hadoop1 ~]$ hadoop dfs -dus /user/Hive/warehouse/*
hdfs://hadoop@hadoop1:19000/user/Hive/warehouse/hbase_table_1    0
hdfs://hadoop@hadoop1:19000/user/Hive/warehouse/hbase_table_2    0
hdfs://hadoop@hadoop1:19000/user/Hive/warehouse/orcfile_table    0
hdfs://hadoop@hadoop1:19000/user/Hive/warehouse/rcfile_table    102638073
hdfs://hadoop@hadoop1:9000/user/Hive/warehouse/seqfile_table   112497695
hdfs://hadoop@hadoop1:19000/user/Hive/warehouse/testfile_table  536799616
hdfs://hadoop@hadoop1:19000/user/Hive/warehouse/textfile_table  107308067
[hadoop@hadoop1 ~]$ hadoop dfs -ls /user/Hive/warehouse/*/
-rw-r--r--   2 hadoop supergroup   51328177 2014-03-20 00:42 /user/Hive/warehouse/rcfile_table/000000_0
-rw-r--r--   2 hadoop supergroup   51309896 2014-03-20 00:43 /user/Hive/warehouse/rcfile_table/000001_0
-rw-r--r--   2 hadoop supergroup   56263711 2014-03-20 01:20 /user/Hive/warehouse/seqfile_table/000000_0
-rw-r--r--   2 hadoop supergroup   56233984 2014-03-20 01:21 /user/Hive/warehouse/seqfile_table/000001_0
-rw-r--r--   2 hadoop supergroup  536799616 2014-03-19 23:15 /user/Hive/warehouse/testfile_table/weibo.txt
-rw-r--r--   2 hadoop supergroup   53659758 2014-03-19 23:24 /user/Hive/warehouse/textfile_table/000000_0.gz
-rw-r--r--   2 hadoop supergroup   53648309 2014-03-19 23:26 /user/Hive/warehouse/textfile_table/000001_1.gz</pre><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a title="复制代码"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a title="复制代码"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div></div></div><p>　　<strong><span style="color:#ff0000;">总结</span>：</strong> 相比TEXTFILE和SEQUENCEFILE，RCFILE由于列式存储方式，数据加载时性能消耗较大，但是具有较好的压缩比和查询响应。数据仓库的特点是一次写入、多次读取，因此，整体来看，RCFILE相比其余两种格式具有较明显的优势。</p><p> </p><p> </p><p><span style="color:#ff0000;"><strong>Hive 操作</strong></span></p><p><span style="color:#0000ff;"><strong>1、表操作</strong></span></p><p><strong> 　　</strong>Hive 和 Mysql 的表操作语句类似，如果熟悉 Mysql，学习Hive 的表操作就非常容易了，下面对 Hive 的表操作进行深入讲解。</p><p><strong>　　<span style="color:#0000ff;">1.1</span></strong><span style="color:#0000ff;"><strong>、创建表</strong></span></p><p>　　　　Hive 的数据表分为两种，内部表和外部表。</p><p><strong>　　　　内部表</strong>：Hive 创建并通过 LOAD DATA INPATH 进数据库的表，<span style="color:#99cc00;">这种表可以理解为数据和表结构都保存在一起的数据表</span>。当通过 DROP TABLE table_name 删除元数据中表结构的同时，表中的数据也同样会从 HDFS 中被删除。</p><p><strong>　　　　外部表</strong>：<span style="color:#ff0000;"><span style="color:#99cc00;">在表结构创建以前，数据已经保存在 HDFS 中，通过创建表结构，将数据格式化到表的结果里</span>。</span>当进行 DROP TABLE table_name 操作的时候，Hive 仅仅删除元数据的表结构，而不删除 HDFS 上的文件，所以，相比内部表，外部表可以更放心大胆地使用。</p><p> </p><p>　　　　下面详细介绍对表操作的命令及使用方法:</p><p>　　　　1)       创建内部表使用 CREATE TABLE 命令。与Mysql 创建表的命令一样，<span style="color:#ff0000;"><strong>COMMENT 是对字段的注释</strong></span>。例如</p><div><div class="cnblogs_code"><pre>Hive&gt; <span style="color:#ff0000;"><strong>CREATE TABLE</strong></span> IF NOT EXISTS table1(id INT COMMENT 'comment1',name STRING COMMENT 'comment2',no INT COMMENT 'comment3')</pre></div></div><p>　　　</p><p>　　　2)       创建外部表使用 EXTERNAL 关键字。IF NOT EXISTS 表示如果 table2 表不存在就创建，存在就不创建。例如</p><div><div class="cnblogs_code"><pre>　Hive&gt; <span style="color:#ff0000;"><strong>CREATE EXTERNAL TABLE</strong> </span>IF NOT EXISTS table2(id INT COMMENT 'comment1',name STRING COMMENT 'comment2',no INT COMMENT 'comment3');</pre></div><p> </p></div><p>　　　　3)       删除表。数据表在删除的时候，内部表会连数据一起删除，而外部表只删除表结构，数据还是保留的。删除表的命令如下。</p><div><div class="cnblogs_code"><pre>Hive&gt; <span style="color:#ff0000;"><strong>DROP TABLE</strong> </span>table1;
Hive&gt; DROP TABLE table1 cascade; //当table里有数据的时候上面的命令行是无法删除table的。加上cascade强制删除</pre></div><p> </p></div><p>　　　　4)       改表结构。例如对 table2 表添加两个字段 data_time 和 password，操作命令如下。</p><div><div class="cnblogs_code"><pre>　　　　Hive&gt; <span style="color:#ff0000;"><strong>ALTER TABLE</strong> </span>table2 <span style="color:#ff0000;"><strong>ADD COLUMNS</strong></span>(data_time STRING <span style="color:#ff0000;"><strong>COMMENT </strong></span>'comment1',password STRING <span style="color:#ff0000;"><strong>COMMENT</strong> </span>'comment2');</pre></div><pre><strong>　　<span style="color:#0000ff;">COMMENT是注释作用</span></strong></pre><p> </p></div><p>　　　　5)       修改表名。例如把 table2 表重命名为 table3 ，操作命令如下。</p><div><div class="cnblogs_code"><pre>　Hive&gt; <span style="color:#ff0000;"><strong>ALTER TABLE</strong></span> table2 <span style="color:#ff0000;"><strong>RENAME TO</strong> </span>table3;</pre></div></div><p>　　　　　　这个命令可以让用户为表更名，数据所在的位置和分区名并不改变。换而言之，<strong><span style="color:#ff0000;">旧的表名并未“释放” ，对旧表的更改会改变新表的数据</span></strong>。</p><p> </p><p>　　　　6)       创建与已知表相同结构的表。例如<span style="color:#0000ff;">创<strong>建一个与 table2 表结构相同的表</strong></span>，表名为</p><p>　　　　　　copy_table2，这里要用到 LIKE 关键字，操作命令如下。</p><div><div class="cnblogs_code"><pre>Hive&gt; CREATE TABLE copy_table2 <strong><span style="color:#ff0000;">LIKE</span> </strong>table2;</pre></div><p> </p><p>　　其实啊，如果是对旧表的复制，将<span style="color:#0000ff;"><strong>旧表的结构和数据一起复制</strong>，</span>来得到新表，则</p><div class="cnblogs_code"><pre>CREATE TABLE djt_user_copy 
<strong><span style="color:#ff0000;">as</span></strong>
<span style="color:#ff0000;"><strong>SELECT * FROM</strong></span> djt_user</pre></div><p> </p><p>　　其实啊，如果是对旧表的复制，<span style="color:#0000ff;"><strong>只将旧表的结构复制</strong></span>，来得到新表，则</p><div class="cnblogs_code"><pre>CREATE TABLE djt_user_copy <strong><span style="color:#ff0000;">as</span></strong> SELECT * FROM djt_user <strong>WHERE 1=2</strong>;</pre></div><pre>　　djt_user是旧表，djt_user_copy是新表。<strong><span style="color:#ff0000;">跟like的用法相同</span></strong></pre></div><p><strong>　　<span style="color:#0000ff;">1.2</span></strong><span style="color:#0000ff;"><strong>、表查询</strong></span></p><p>　　　　Hive 的查询语句与标准 SQL 语句类似，具体的语法如下。</p><div><div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a title="复制代码"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a title="复制代码"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div><pre>　SELECT [ALL | DISTINCT] select_expr,select_expr,...
　　　　FROM table_reference
　　　　[WHERE where_condition]
　　　　[GROUP BY col_list]
　　　　[
　　　　CLUSTER BY col_list|[DISTRIBUTE BY col_list]
　　　　[SORT BY col_list]
　　　　]
　　　　[LIMIT number]</pre><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a title="复制代码"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a title="复制代码"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div></div></div><p>　　　　<strong>一个 SELECT 语句可以是</strong>一个 union 查询或一个子查询的一部分；<span style="color:#ff0000;"><strong>table_reference 是</strong></span>查询的输入，可以是一个普通表、视图、join或子查询。</p><p> </p><p>　　　　首先创建一个 TextFile 格式的表 table1，并指定数据分隔符。</p><div><div class="cnblogs_code"><pre>　　　Hive&gt; <strong><span style="color:#ff0000;">create table</span> </strong>table1(id INT,name STRING,no INT) row format delimited fields terminated by '\t'  STORED AS TEXTFILE;</pre></div><p> </p></div><p>　　　　先将 /home/hadoop/zhouls/data.txt 插入表 table1 中。</p><div><div class="cnblogs_code"><pre>　　Hive&gt; LOAD DATA <span style="color:#ff0000;"><strong>LOCAL </strong></span>INPATH '/home/hadoop/zhouls/data.txt' INTO TABLE table1;</pre></div></div><p>　　　　1)       查询 table1 表的<strong>所有</strong>内容，查询语句如下：</p><div><div class="cnblogs_code"><pre>　　Hive&gt; <span style="color:#ff0000;"><strong>select * from</strong></span> table1;</pre></div><pre>　　　　OK</pre><pre>　　　　1       liugang 1000</pre><pre>　　　　2       lisi    1001</pre><pre>　　　　3       wangwu  1002</pre><pre>　　　　Time taken: 0.075 seconds, Fetched: 3 row(s)</pre></div><p>　　　　SELECT * 查询没有开启 MapReduce 任务，这是 Hive 查询语句中唯一没有把 Hive 查询语句解释为 MapReduce 任务执行。</p><p> </p><p>　　　　2)       查询 table1 表的<strong> <span style="color:#0000ff;">name 属性</span></strong>，查询语句如下</p><div><div class="cnblogs_code"><pre>　Hive&gt; <span style="color:#ff0000;"><strong>SELECT name FROM</strong> </span>table1;</pre></div><pre>　　　　OK</pre><pre>　　　　liugang</pre><pre>　　　　lisi</pre><pre>　　　　wangwu</pre><pre>　　　　Time taken: 0.095 seconds, Fetched: 3 row(s)</pre></div><p> 　　　　"SELECT name FROM table1;" 被解释成了一个 MapReduce 任务执行。</p><p> </p><p><strong>　　<span style="color:#0000ff;">1.3</span></strong><span style="color:#0000ff;"><strong>、 数据加载</strong></span></p><p>　　首先创建一个表 table2，table4，必须声明文件格式STORED AS TEXTFILE，否则数据无法加载。</p><div><div class="cnblogs_code"><pre>　Hive&gt; <strong>create table </strong>table2(uid STRING,gender STRING,ip STRING) row format delimited fields terminated by '\t'  STORED AS TEXTFILE;
　Hive&gt; <strong>create table</strong> table4(uid STRING,gender STRING,ip STRING) row format delimited fields terminated by '\t'  STORED AS TEXTFILE;</pre></div></div><p>  　　　　(1) 加载本地数据</p><p>  　　　　加载本地数据使用 LOCAL 关键字，操作如下。</p><div><div class="cnblogs_code"><pre>　Hive&gt; LOAD DATA <span style="color:#ff0000;"><strong>LOCAL</strong></span> INPATH '/home/hadoop/djt/user.txt' INTO TABLE table2;</pre></div><p> </p></div><p><strong>　<span style="color:#0000ff;">　1.4</span></strong><span style="color:#0000ff;"><strong>、 插入表</strong></span></p><p><strong>　　　　<span style="color:#339966;">(1) </span></strong><span style="color:#339966;"><strong>单表插入</strong></span></p><p>　　　　创建一个表 insert_table，表结构和 table2 的结构相同，把 table2 表中的数据插入到新建的表 insert_table 中，代码如下。</p><div><div class="cnblogs_code"><pre>　　Hive&gt; create table insert_table <strong>like </strong>table2;----复制表结构（不包括旧表的数据）
　　Hive&gt; insert overwrite table insert_table select * from table2;</pre></div></div><p>　　　　overwrite 关键字表示如果 insert_table 表中有数据就删除。(覆盖的意思)</p><p> </p><p> </p><p><strong>　　　　<span style="color:#339966;">(2) </span></strong><span style="color:#339966;"><strong>多表插入</strong></span></p><p>　　　　在table2中，<strong>查询字段 uid 并插入</strong> test_insert1<strong> 表</strong>，查询字段 uid 并插入 test_insert2 表。操作命令如下。</p><div><div class="cnblogs_code"><pre>　　Hive&gt;<strong> create table </strong>test_insert1<strong>(num INT)</strong>;
　　Hive&gt; create table test_insert2(num INT);</pre></div><div class="cnblogs_code"><pre>　from table2 <span style="color:#ff0000;"><strong>insert overwrite table test_insert1 select uid insert overwrite table test_insert2 select uid</strong></span>;</pre></div></div><p> 　　　　insert 操作的时候，from 子句既可以放在 select 子句后面，也可以放在 insert 子句前面。</p><p> 　　　　Hive 不支持用 insert 语句一条一条地进行插入操作，也不支持 update 操作。数据是以 load 的方式加载到建立好的表中。数据一旦导入就不可以修改。</p><p> 　　　　</p><p>           通过查询将数据保存到 HDFS ，directory 为 HDFS 文件系统的目录。操作命令如下。</p><div><div class="cnblogs_code"><pre>Hive&gt; insert overwrite directory '/advance/Hive' select * from table2;</pre></div><p> </p></div><p>  　　　　导入数据到本地目录，操作命令如下。</p><div><div class="cnblogs_code"><pre>　　　　Hive&gt; <strong>insert overwrite local directory </strong>'/home/hadoop/djt/test2' select * from table2;</pre></div></div><p>　　　　产生的文件会覆盖指定目录中的其它文件，即将目录中已经存在的文件进行删除。</p><p>　　　　同一个查询结果可以同时插入到多个表或者多个目录中，命令如下。</p><div><div class="cnblogs_code"><pre>　from table2 insert overwrite local directory '/home/hadoop/djt/test2' <span style="color:#ff0000;"><strong>select *</strong></span> insert overwrite directory '/advance/Hive' <strong><span style="color:#ff0000;">select ip</span></strong>;</pre></div></div><p>　　　　select * 表示把 table2 表中的所有数据复制到本地 /home/hadoop/djt/test2 目录下面，select ip 表示把 table2 的 ip 字段内容复制到 HDFS 文件系统的 /advance/Hive 目录下。</p><p> </p><p>　　　　下面我们逐一学习 Hive 的语法结构，很easy的哦。</p><p><span style="color:#0000ff;"><strong>2、Hive 的语法结构</strong></span></p><p><strong>　　<span style="color:#008000;">(1) where </span></strong><span style="color:#008000;"><strong>查询</strong></span></p><p>　　where 查询是一个布尔表达式。例如，下面的查询语句只返回销售记录大于10，且归属地属于北京的销售代表。Hive 不支持在 where 子句中的 in，exist或子查询。</p><div><div class="cnblogs_code"><pre>　Hive&gt; select * from sales <span style="color:#ff0000;"><strong>where amount &gt;10 and region = "beijing"</strong></span>;</pre></div><p> </p></div><p><strong>　　<span style="color:#008000;">(2) all </span></strong><span style="color:#008000;"><strong>和 distinct 选项</strong></span></p><p>　　<strong>使用 all 和 distinct 选项区分对重复记录的处理。</strong>默认是 all，表示查询所有记录，distinct 表示去掉重复的记录。</p><div><div class="cnblogs_code"><pre>　Hive&gt; select * from sales where amount &gt;10 and region = "beijing";</pre></div><p> </p></div><p>　　　　1)       查询 table1 表中的所有 age、grade 的内容，等同于如下操作。</p><div><div class="cnblogs_code"><pre>　　Hive&gt; select <strong>all </strong>age,grade from table1;</pre></div><p> </p></div><p>　　　　2)       查询去掉 age 和 grade 重复的记录，操作如下。</p><div><div class="cnblogs_code"><pre>　Hive&gt; select <span style="color:#ff0000;"><strong>distinct </strong></span>age ,grade from table1;</pre></div><p> </p></div><p>　　　　3)       查询去掉 age 重复的记录，操作如下。</p><div><div class="cnblogs_code"><pre>　　Hive&gt; select distinct age from table1;</pre></div><p> </p></div><p><strong>　<span style="color:#008000;">　(3) </span></strong><span style="color:#008000;"><strong>基于 Partition 的查询</strong></span></p><p>　　　　一般 SELECT 查询会扫描整个表（除非是为了抽样查询）。但是如果一个表使用 PARTITIONED BY 子句建表，查询就可以利用分区剪枝（input pruning）的特性，只扫描一个表中它关心的那一部分。Hive 当前的实现是，<span style="color:#0000ff;"><strong>只有分区断言出现在离 FROM 子句最近的那个 WHERE 子句中，才会启用分区剪枝。</strong></span>例如，page_views 表使用 date 列分区，以下语句只会读取分区为 ‘2013-08-01’ 的数据。</p><div><div class="cnblogs_code"><pre><strong>select page_views.* from page_views where page_views.date between '2013-08-01' and  '2013-08-31'</strong>;</pre></div><p> </p></div><p><strong>　　<span style="color:#008000;">(4) </span></strong><span style="color:#008000;"><strong>基于 HAVING 的查询</strong></span></p><p>  　　　Hive 不支持 HAVING 子句，可以将 HAVING 子句转化为一个子查询。例如以下这条语句 Hive 不支持。</p><div><div class="cnblogs_code"><pre>　select col1 from table1 group by coll having sum(col2) &gt; 10;</pre></div><p> </p></div><p>    可以用以下查询来表达。</p><div><div class="cnblogs_code"><pre><strong>select col1 from <span style="color:#0000ff;">(select col1,sum(col2) as col2sum from table1 group by col1)</span> table2 where table2.col2sum &gt; 10</strong>;</pre></div><p> </p></div><p><strong>　　<span style="color:#008000;">(5) LIMIT </span></strong><span style="color:#008000;"><strong>限制查询</strong></span></p><p> 　　limit 可以限制查询的记录数，查询的结果是随机选择的。下面的语句用来从 table1 表中随机查询 5 条记录。</p><div><div class="cnblogs_code"><pre>select * from table1 <strong>limit 5</strong>;</pre></div><p> </p></div><p><strong>　<span style="color:#008000;">　(6) GROUP BY </span></strong><span style="color:#008000;"><strong>分组查询</strong></span></p><p>　　group by 分组查询在数据统计时比较常用，接下来讲解 group by 的使用。</p><p>　　　　1)       创建一个表 group_test，表的内容如下。</p><div><div class="cnblogs_code"><pre>　Hive&gt; <strong>create table </strong>group_test(uid STRING,gender STRING,ip STRING) row format delimited fields terminated by '\t'  STORED AS TEXTFILE;</pre></div><p> </p></div><p>　　　　向 group_test 表中导入数据。</p><div><div class="cnblogs_code"><pre>　Hive&gt; LOAD DATA <strong>LOCAL </strong>INPATH '/home/hadoop/djt/user.txt'  INTO TABLE group_test;</pre></div><p> </p></div><p>　　　　2)       计算表的行数命令如下。</p><div><div class="cnblogs_code"><pre>Hive&gt; select <span style="color:#0000ff;"><strong>count(*)</strong> </span>from group_test;</pre></div><p> </p></div><p>　　　　3) 根据性别计算去重用户数。</p><p>　　　　首先创建一个表 group_gender_sum</p><div><div class="cnblogs_code"><pre>　Hive&gt; create table group_gender_sum(gender STRING,sum INT);</pre></div><p> </p></div><p>　　　　将表 group_test 去重后的数据导入表 group_gender_sum。</p><div><div class="cnblogs_code"><pre>　Hive&gt; insert overwrite table group_gender_sum select group_test.gender,<span style="color:#ff0000;">count(distinct group_test.uid)</span> from group_test <span style="color:#0000ff;"><strong>group by</strong></span> <span style="color:#800080;">group_test.gender</span>;</pre></div></div><p>　　　　</p><p>　　同时可以做<span style="color:#ff0000;">多个聚合操作</span>，但是<span style="color:#ff0000;">不能有两个聚合操作有不同的 distinct 列</span>。下面正确合法的聚合操作语句。</p><p>　　　　首先创建一个表 group_gender_agg</p><div><div class="cnblogs_code"><pre>　Hive&gt; create table group_gender_agg(gender STRING,sum1 INT,sum2 INT,sum3 INT);</pre></div><p> </p></div><p>　　　　将表 group_test 聚合后的数据插入表 group_gender_agg。</p><div><div class="cnblogs_code"><pre>Hive&gt; insert overwrite table group_gender_agg select group_test.gender,count(distinct group_test.uid),count(*),sum(distinct group_test.uid) from group_test group by group_test.gender;</pre></div><p> </p></div><p>  　　　　但是，不允许在同一个查询内有多个 distinct 表达式。下面的查询是不允许的。</p><div><div class="cnblogs_code"><pre>　Hive&gt; insert overwrite table group_gender_agg select group_test.gender,count(<strong>distinct group_test.uid</strong>),count(<strong>distinct group_test.ip</strong>) from group_test <strong>group by group_test.gender</strong>;</pre></div></div><p>  　　　　这条查询语句是不合法的，因为 distinct group_test.uid 和 distinct group_test.ip 操作了uid 和 ip 两个不同的列。</p><p> </p><p><span style="color:#008000;">　　  <strong> (7) ORDER BY 排序查询</strong></span></p><p> 　　　　<span style="color:#ff0000;">ORDER BY 会对输入做全局排序，因此只有一个 Reduce</span>（多个 Reduce 无法保证全局有序）会导致当输入规模较大时，需要较长的计算时间。<strong><span style="color:#0000ff;">使用 ORDER BY 查询的时候，为了优化查询的速度，使用 Hive.mapred.mode 属性。</span></strong></p><div><div class="cnblogs_code"><pre>　　Hive.mapred.mode = nonstrict;(default value/默认值)
　　Hive.mapred.mode=strict;</pre></div><p> </p></div><p>  　　<span style="color:#0000ff;">与数据库中 ORDER BY 的区别在于，在 Hive.mapred.mode=strict 模式下必须指定limit ，否则执行会报错。</span></p><div><div class="cnblogs_code"><pre>Hive&gt; set Hive.mapred.mode=strict;
Hive&gt; select * from group_test <strong>order by uid limit 5</strong>;</pre></div><pre>　　Total jobs = 1</pre><pre>　　..............</pre><pre>　　Total MapReduce CPU Time Spent: 4 seconds 340 msec</pre><pre>　　OK</pre><pre>　　01      male    192.168.1.2</pre><pre>　　01      male    192.168.1.32</pre><pre>　　01      male    192.168.1.26</pre><pre>　　01      male    192.168.1.22</pre><pre>　　02      female  192.168.1.3</pre><pre>　　Time taken: 58.04 seconds, Fetched: 5 row(s)


</pre></div><p><strong>　<span style="color:#008000;">　(8) SORT BY </span></strong><span style="color:#008000;"><strong>查询</strong></span></p><p> 　　sort by 不受 Hive.mapred.mode 的值是否为 strict 和 nostrict 的影响。sort by 的数据只能保证在同一个 Reduce 中的数据可以按指定字段排序。</p><p> 　　使用 sort by 可以指定执行的 Reduce 个数（set mapred.reduce.tasks=&lt; number&gt;）这样可以输出更多的数据。对输出的数据再执行归并排序，即可以得到全部结果。</p><div><div class="cnblogs_code"><pre>　Hive&gt; set Hive.mapred.mode=strict;
　Hive&gt; select * from group_test <strong>sort by uid </strong>;</pre></div><pre>　　Total MapReduce CPU Time Spent: 4 seconds 450 msec</pre><pre>　　OK</pre><pre>　　01      male    192.168.1.2</pre><pre>　　01      male    192.168.1.32</pre><pre>　　01      male    192.168.1.26</pre><pre>　　01      male    192.168.1.22</pre><pre>　　02      female  192.168.1.3</pre><pre>　　03      male    192.168.1.23</pre><pre>　　03      male    192.168.1.5</pre><pre>　　04      male    192.168.1.9</pre><pre>　　05      male    192.168.1.8</pre><pre>　　05      male    192.168.1.29</pre><pre>　　06      female  192.168.1.201</pre><pre>　　06      female  192.168.1.52</pre><pre>　　06      female  192.168.1.7</pre><pre>　　07      female  192.168.1.11</pre><pre>　　08      female  192.168.1.21</pre><pre>　　08      female  192.168.1.62</pre><pre>　　08      female  192.168.1.88</pre><pre>　　08      female  192.168.1.42</pre><pre>　　Time taken: 77.875 seconds, Fetched: 18 row(s)


</pre></div><p>  　　 <strong>(9) DISTRIBUTE BY 排序查询</strong></p><p>  　　 按照指定的字段对数据划分到不同的输出 Reduce 文件中，操作如下。</p><div><div class="cnblogs_code"><pre>Hive&gt; insert overwrite local directory '/home/hadoop/djt/test' select * from group_test <strong>distribute by length(gender)</strong>;</pre></div><p> </p></div><p>　　此方法根据 gender 的长度划分到不同的 Reduce 中，最终输出到不同的文件中。length 是内建函数，也可以指定其它的函数或者使用自定义函数。</p><div><div class="cnblogs_code"><pre>Hive&gt; insert overwrite local directory '/home/hadoop/djt/test' select * from group_test order by gender  distribute by length(gender);</pre></div></div><p>　　order by gender 与 distribute by length(gender) 不能共用。</p><p> </p><p> </p><p><strong>　　(10) CLUSTER BY 查询</strong></p><p>　　cluster by 除了具有 distribute by 的功能外还兼具 sort by 的功能。</p><p> </p><p> </p><p> </p><p><strong>3、视图操作</strong></p><p><strong>　　1)       创建一个测试表。</strong></p><div><div class="cnblogs_code"><pre>　Hive&gt; create table test(id int,name string);</pre></div><pre>　　OK</pre><pre>　　Time taken: 0.385 seconds

</pre><div class="cnblogs_code"><pre>　　Hive&gt; desc test;</pre></div><pre>　　OK</pre><pre>　　id                      int                                         </pre><pre>　　name                    string                                      </pre><pre>　　Time taken: 0.261 seconds, Fetched: 2 row(s)

</pre></div><p><strong>　　2)       基于表 test 创建一个 test_view 视图。</strong></p><div><div class="cnblogs_code"><pre>Hive&gt; <strong>create view </strong>test_view(id,name_length) <strong>as select id,length(name) from test</strong>;</pre></div><p> </p></div><p><strong>　　3)       查看 test_view 视图属性。</strong></p><div><div class="cnblogs_code"><pre>　Hive&gt; desc test_view;</pre></div><p> </p></div><p><strong>　　4) 查看视图结果。</strong></p><div><div class="cnblogs_code"><pre>　　Hive&gt; select * from test_view;</pre></div><p> </p><p>　　更详细，请移步</p><p><strong>    <a href="http://blog.csdn.net/wuyujian11/article/details/53337416" rel="nofollow">mysql视图使用总</a></strong></p></div><p>      视图是指计算机<a class="replace_word" title="MySQL知识库" href="http://lib.csdn.net/base/14" rel="nofollow">数据库</a>中的视图，<strong>是一个虚拟表</strong>，即不是实实在在的，其内容由查询定义。同真实的表一样，视图包含一系列带有名称的列和行数据。但是，视图并不在<a class="replace_word" title="MySQL知识库" href="http://lib.csdn.net/base/mysql" rel="nofollow">数据库</a>中以存储的数据值集形式存在。行和列数据来自由定义视图的查询所引用的表，并且在引用视图时动态生成。</p><p> 　　一般情况，是多表关联查询的时候，才用视图　</p><div> 　　对一个表来说，视图是横向的，一般创建视图查询语句都要加条件的 </div><div> 　　索引是作用列上面的 </div><p>　　 索引是为了提高查询速度的，视图是在查询sql的基础上的。</p><div> 　　比如一个表很多字段，你查询的时候，只是想取得其中一部分字段，并且包含一些特定条件的数据 ，这个时候最好用视图。</div><p> </p><p> </p><p><strong>4、索引操作</strong></p><p><strong>　　1)  Hive 创建索引。</strong></p><p><strong>　　2) 更新数据。</strong></p><div><div class="cnblogs_code"><pre>　　Hive&gt; <strong>alter index </strong>user_index <strong>o</strong>n <strong>user</strong> rebu<strong>ild</strong>;</pre></div><p> </p></div><p><strong>　　3) 删除索引</strong></p><div><div class="cnblogs_code"><pre>　　Hive&gt; <strong>drop index</strong> user_index <strong>on user</strong>;</pre></div><p> </p></div><p><strong>　　4)       查看索引</strong></p><div><div class="cnblogs_code"><pre>　Hive&gt; <strong>show index on user</strong>;</pre></div><p> </p></div><p><strong>　　5)       创建表和索引案例</strong></p><div><div class="cnblogs_code"><pre>　　Hive&gt; create table index_test(id INT,name STRING) PARTITIONED BY (dt STRING) ROW FORMAT DELIMITED FILEDS TERMINATED BY ',';</pre></div></div><p>　　创建一个索引测试表 index_test，dt作为分区属性，“ROW FORMAT DELIMITED FILEDS TERMINATED BY ','” 表示用逗号分割字符串，默认为‘\001’。</p><p> </p><p><strong>　　6)       创建一个临时索引表 index_tmp。</strong></p><div><div class="cnblogs_code"><pre>　Hive&gt; create table index_tmp(id INT,name STRING,dt STRING) ROW FORMAT DELIMITED FILEDS TERMINATED BY ',';</pre></div><p> </p></div><p><strong>　　7)       加载本地数据到 index_tmp 表中。</strong></p><div><div class="cnblogs_code"><pre>Hive&gt; load data local inpath '/home/hadoop/djt/test.txt' into table index_tmp;</pre></div><p> </p></div><p>　　设置 Hive 的索引属性来优化索引查询，命令如下。</p><div><div class="cnblogs_code"><pre>　Hive&gt; set Hive.exec.dynamic.partition.mode=nonstrict;----设置所有列为 dynamic partition
　Hive&gt; set Hive.exec.dynamic.partition=true;----使用动态分区</pre></div><p> </p></div><p><strong>　　8)       查询index_tmp 表中的数据，插入 table_test 表中。</strong></p><div><div class="cnblogs_code"><pre>Hive&gt; insert overwrite table index_test partition(dt) select id,name,dt from index_tmp;</pre></div><p> </p></div><p><strong>　　9)       使用 index_test 表，在属性 id 上创建一个索引 index1_index_test 。</strong></p><div><div class="cnblogs_code"><pre>Hive&gt; <strong>create index </strong>index1_index_test <strong>on table index_test(id)</strong> as 'org.apache.hadoop.Hive.ql.index.compact.CompactIndexHandler' WITH DEFERERD REBUILD;</pre></div><p> </p></div><p><strong>　　10)   填充索引数据。</strong></p><div><div class="cnblogs_code"><pre>Hive&gt; <strong>alter index</strong> index1_index_test <strong>on</strong> index_test <strong>rebuild</strong>;</pre></div><p> </p></div><p><strong>　　11)   查看创建的索引。</strong></p><div><div class="cnblogs_code"><pre>Hive&gt; <strong>show index on </strong>index_test</pre></div><p> </p></div><p><strong>　　12)   查看分区信息。</strong></p><div><div class="cnblogs_code"><pre>　Hive&gt; <strong>show partitions</strong> index_test;</pre></div><p> </p></div><p><strong>　　13)   查看索引数据。</strong></p><div><div class="cnblogs_code"><pre>　$ hadoop fs -ls <strong>/usr/Hive/warehouse/</strong>default_index_test_index1_index_test_</pre></div><p> </p></div><p><strong>　　14)   删除索引。</strong></p><div><div class="cnblogs_code"><pre>Hive&gt;<strong> drop index</strong> index1_index_test <strong>on </strong>index_test;</pre><pre>Hive&gt; show index on index_test;</pre></div><p> </p></div><p><strong>　　15)   索引数据也被删除。</strong></p><div><div class="cnblogs_code"><pre>$ hadoop fs -ls /usr/Hive/warehouse/default_index_test_index1_index_test_</pre></div><pre>　　no such file or directory

</pre></div><p><strong>　　16)   修改配置文件信息。</strong></p><div><div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a title="复制代码"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a title="复制代码"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div><pre>　　&lt;property&gt;
　　 　　&lt;name&gt;Hive.optimize.index.filter&lt;/name&gt;
　　　　&lt;value&gt;true&lt;/value&gt;
　　&lt;/property&gt;
　　&lt;property&gt;
　　　　 &lt;name&gt;Hive.optimize.index.groupby&lt;/name&gt;
　　 　　&lt;value&gt;true&lt;/value&gt;
　　&lt;/property&gt;
　　&lt;property&gt;
　　　　&lt;name&gt;Hive.optimize.index.filter.compact.minsize&lt;/name&gt;
　　　　&lt;value&gt;5120&lt;/value&gt;
　　&lt;/property&gt;</pre><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a title="复制代码"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a title="复制代码"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div></div></div><p>　　Hive.optimize.index.filter 和 Hive.optimize.index.groupby 参数默认是 false。使</p><p>　　用索引的时候必须把这两个参数开启，才能起到作用。</p><p>　　Hive.optimize.index.filter.compact.minsize 参数为输入一个紧凑的索引将被自动采用</p><p>　　最小尺寸、默认5368709120（以字节为单位）。</p><p>                             </p><p> </p><p><strong>5、分区操作</strong></p><p><strong>　　注意：<strong>注意：普通表（外部表、内部表）、分区表这三个都是对应HDFS上的目录，桶表对应是目录里的文件</strong></strong></p><p>     　　Hive 的分区通过<strong>在创建表时启动 PARTITION BY 实现</strong>，用来分区的维度并不是实际数据的某一列，具体分区的标志是由插入内容时给定的。当要查询某一分区的内容时可以采用 WHERE 语句， 例如使用 “WHERE tablename.partition_key&gt;a” 创建含分区的表。创建分区语法如下。</p><div><div class="cnblogs_code"><pre>　　CREATE TABLE table_name(
　　...
　　)
　　PARTITION BY (dt STRING,country STRING)</pre></div><p> </p></div><p> </p><p><strong>　　5.1、 创建分区</strong></p><p>     Hive 中创建分区表没有什么复杂的分区类型（范围分区、列表分区、hash 分区，混合分区等）。<strong>分区列也不是表中的一个实际的字段，而是一个或者多个伪列</strong>。意思是说，在表的数据文件中实际并不保存分区列的信息与数据。</p><p>     创建一个简单的分区表。</p><div><div class="cnblogs_code"><pre>Hive&gt; <strong>create table </strong>partition_test(member_id string,name string)<strong> partitioned by</strong> (stat_date string,province string) row format delimited fields terminated by ',';</pre></div></div><p>     这个例子中创建了 stat_date 和 province 两个字段作为分区列。</p><p> </p><p>　　通常情况下需要预先创建好分区，然后才能使用该分区。例如：</p><div><div class="cnblogs_code"><pre>Hive&gt;<strong> alter table</strong> partition_test <strong>add partition</strong> (stat_date='2015-01-18',province='beijing');</pre></div></div><p>　　这样就创建了一个分区。</p><p> </p><p>　　这时会看到 Hive 在HDFS 存储中创建了一个相应的文件夹。</p><div><div class="cnblogs_code"><pre>$ hadoop fs -ls /user/Hive/warehouse/partition_test/stat_date=2015-01-18</pre></div><pre>/user/Hive/warehouse/partition_test/stat_date=2015-01-18/province=beijing----显示刚刚创建的分区</pre></div><p>   <strong>每一个分区都会有一个独立的文件夹（目录），在上面例子中，stat_date 是主层次，province 是 副层次。</strong></p><p> </p><p><strong>　　5.2、 插入数据</strong></p><p>   使用一个辅助的非分区表 partition_test_input 准备向 partition_test 中插入数据，实现步骤如下。</p><p>1)       查看 partition_test_input 表的结构，命令如下。</p><div><div class="cnblogs_code"><pre>Hive&gt; desc partition_test_input;</pre></div><p> </p></div><p>2)       查看 partition_test_input 的数据，命令如下。</p><div><div class="cnblogs_code"><pre>Hive&gt; select * from partition_test_input;</pre></div><p> </p></div><p> </p><p>3)       向 partition_test 的分区中插入数据，命令如下。</p><div><div class="cnblogs_code"><pre><strong>insert overwrite table partition_test partition(stat_date='2015-01-18',province='jiangsu')</strong> select member_id,name from partition_test_input where stat_date='2015-01-18' and province='jiangsu';</pre></div><p> </p></div><p>　　向多个分区插入数据，命令如下。</p><div><div class="cnblogs_code"><pre>Hive&gt; from partition_test_input</pre></div><pre>insert overwrite table partition_test partition(stat_date='2015-01-18',province='jiangsu') select member_id,name from partition_test_input where stat_date='2015-01-18' and province='jiangsu'</pre><pre>insert overwrite table partition_test partition(stat_date='2015-01-28',province='sichuan') select member_id,name from partition_test_input where stat_date='2015-01-28' and province='sichuan'</pre><pre>insert overwrite table partition_test partition(stat_date='2015-01-28',province='beijing') select member_id,name from partition_test_input where stat_date='2015-01-28' and province='beijing';</pre></div><p><strong>　　</strong></p><p><strong>　　5.3、 动态分区</strong></p><p>　　按照上面的方法向分区表中插入数据，如果数据源很大，针对一个分区就要写一个 insert ，非常麻烦。使用动态分区可以很好地解决上述问题。动态分区可以根据查询得到的数据自动匹配到相应的分区中去。</p><p> </p><p>　　动态分区可以通过下面的设置来打开：</p><div><div class="cnblogs_code"><pre>set Hive.exec.dynamic.partition=true;  
set Hive.exec.dynamic.partition.mode=nonstrict; </pre></div></div><p> 　　</p><p>　　动态分区的使用方法很简单，假设向 stat_date='2015-01-18' 这个分区下插入数据，至于 province 插到哪个子分区下让数据库自己来判断。stat_date 叫做静态分区列，province 叫做动态分区列。</p><div><div class="cnblogs_code"><pre>Hive&gt; <strong>insert overwrite table partition_test partition(stat_date='2015-01-18',province)</strong></pre></div><pre>select member_id,name province from partition_test_input where stat_date='2015-01-18';</pre></div><p>     </p><p>　　 <strong>注意，</strong>动态分区不允许主分区采用动态列而副分区采用静态列，这样将导致所有的主分区都要创建副分区静态列所定义的分区。</p><p>   Hive.exec.max.dynamic.partitions.pernode：每一个 MapReduce Job 允许创建的分区的最大数量，如果超过这个数量就会报错（默认值100）。</p><p>   Hive.exec.max.dynamic.partitions：一个 dml 语句允许创建的所有分区的最大数量（默认值100）。</p><p>   Hive.exec.max.created.files：所有 MapReduce Job 允许创建的文件的最大数量（默认值10000）。</p><p>  </p><p>　　尽量让分区列的值相同的数据在同一个 MapReduce 中，这样每一个 MapReduce 可以尽量少地产生新的文件夹，可以通过 DISTRIBUTE BY 将分区列值相同的数据放到一起，命令如下。</p><div><div class="cnblogs_code"><pre>Hive&gt; insert overwrite table partition_test partition(stat_date,province)</pre></div><pre>select memeber_id,name,stat_date,province from partition_test_input distribute by stat_date,province;</pre></div><p><strong> </strong></p><p> </p><p> </p><p><strong>6、桶操作</strong></p><p><strong>　　Hive 中 table 可以拆分成 Partition table 和 桶（BUCKET），桶操作是通过 Partition 的 CLUSTERED BY 实现的，BUCKET 中的数据可以通过 SORT BY 排序。</strong></p><p><strong>　　BUCKET 主要作用如下</strong>。</p><p>　　1)数据 sampling；</p><p>　　2)提升某些查询操作效率，例如 Map-Side Join。</p><p>　　需要特别主要的是，CLUSTERED BY 和 SORT BY 不会影响数据的导入，这意味着，用户必须自己负责数据的导入，包括数据额分桶和排序。 'set Hive.enforce.bucketing=true' 可以自动控制上一轮 Reduce 的数量从而适配 BUCKET 的个数，当然，用户也可以自主设置 mapred.reduce.tasks 去适配 BUCKET 个数，推荐使用：</p><div><div class="cnblogs_code"><pre>　　Hive&gt; set Hive.enforce.bucketing=true;</pre></div><p> </p></div><p>　　操作示例如下。</p><p>　　　　1)       创建临时表 student_tmp，并导入数据。</p><div><div class="cnblogs_code"><pre>　　　Hive&gt; desc student_tmp;

　　　Hive&gt; select * from student_tmp;</pre></div><p> </p></div><p>　　　　2)       创建 student 表。</p><div><div class="cnblogs_code"><pre>　Hive&gt; create table student(id int,age int,name string)
　　　　partitioned by (stat_date string)
　　　　clustered by (id) sorted by(age) into 2 bucket
　　　　row format delimited fields terminated by ',';</pre></div><p> </p></div><p>　　　　3)       设置环境变量。</p><div><div class="cnblogs_code"><pre>　　　Hive&gt; set Hive.enforce.bucketing=true;</pre></div><p> </p></div><p>　　　　4)       插入数据。</p><div><div class="cnblogs_code"><pre>Hive&gt; from student_tmp
　　　　insert overwrite table student partition(stat_date='2015-01-19')
　　　　select id,age,name where stat_date='2015-01-18' sort by age;</pre></div><p> </p></div><p>　　　　5)       查看文件目录。</p><div><div class="cnblogs_code"><pre>　$ hadoop fs -ls /usr/Hive/warehouse/student/stat_date=2015-01-19/</pre></div><p> </p></div><p>　　　　6)       查看 sampling 数据。</p><div><div class="cnblogs_code"><pre>　Hive&gt; select * from student tablesample(bucket 1 out of 2 on id);</pre></div><p> </p></div><p>  　　　　   tablesample 是抽样语句，语法如下。</p><div><pre>　　　　tablesample(bucket x out of y)</pre></div><p>　　　　y 必须是 table 中 BUCKET 总数的倍数或者因子。</p><p> </p><p> </p><p> </p><p><strong>7、Hive 复合类型</strong></p><p>　　Hive提供了复合数据类型：</p><p>　　 1)Structs： structs内部的数据可以通过DOT（.）来存取。例如，表中一列c的类型为STRUCT{a INT; b INT}，我们可以通过c.a来访问域a。</p><p>　　2)Map（K-V对）：访问指定域可以通过["指定域名称"]进行。例如，一个Map M包含了一个group-》gid的kv对，gid的值可以通过M['group']来获取。</p><p>   　3)Array：array中的数据为相同类型。例如，假如array A中元素['a','b','c']，则A[1]的值为'b'</p><p> </p><p>　　<strong>7.1、Struct使用</strong></p><p>　　1) 建表</p><div><div class="cnblogs_code"><pre>　Hive&gt; create table student_test(id INT, info struct&lt; name:STRING, age:INT&gt;)  
　　  &gt; ROW FORMAT DELIMITED FIELDS TERMINATED BY ','                         
　　  &gt; COLLECTION ITEMS TERMINATED BY ':';</pre></div></div><p>　　'FIELDS TERMINATED BY' ：字段与字段之间的分隔符。'COLLECTION ITEMS TERMINATED BY' ：一个字段各个item的分隔符。</p><p> </p><p>　　2)       导入数据</p><div><div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a title="复制代码"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a title="复制代码"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div><pre>　　$ cat test5.txt   
　　1,zhou:30  
　　2,yan:30  
　　3,chen:20  
　　4,li:80  

　　Hive&gt; LOAD DATA LOCAL INPATH '/home/hadoop/djt/test5.txt' INTO TABLE student_test;</pre><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a title="复制代码"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a title="复制代码"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div></div><p> </p></div><p>　　3）查询数据</p><div><div class="cnblogs_code"><pre>　Hive&gt; select info.age from student_test;  </pre></div><p> </p></div><p>　　<strong>7.2、Array使用</strong></p><p>　　1) 建表</p><div><div class="cnblogs_code"><pre>　Hive&gt; create table class_test(name string, student_id_list array&lt; INT&gt;)  
　　  &gt; ROW FORMAT DELIMITED                                              
　　  &gt; FIELDS TERMINATED BY ','                                          
　　  &gt; COLLECTION ITEMS TERMINATED BY ':';</pre></div><p> </p></div><p>　　2) 导入数据</p><div><div class="cnblogs_code"><pre>　　$ cat test6.txt   
　　034,1:2:3:4  
　　035,5:6  
　　036,7:8:9:10  
　　Hive&gt;  LOAD DATA LOCAL INPATH '/home/work/data/test6.txt' INTO TABLE class_test ; </pre></div><p> </p></div><p>　　3)       查询</p><div><div class="cnblogs_code"><pre>　　Hive&gt; select student_id_list[3] from class_test; </pre></div><p> </p></div><p>　　<strong>7.3、Map使用</strong></p><p>　　1）    建表</p><div><div class="cnblogs_code"><pre>　Hive&gt; create table employee(id string, perf map&lt; string, int&gt;)       
　　&gt; ROW FORMAT DELIMITED                                          
　　&gt; FIELDS TERMINATED BY '\t'                                
　　&gt; COLLECTION ITEMS TERMINATED BY ','                       
　　&gt; MAP KEYS TERMINATED BY ':';  </pre></div></div><p>　　‘MAP KEYS TERMINATED BY’ ：key value分隔符</p><p> </p><p> </p><p>　　2）导入数据</p><div><div class="cnblogs_code"><pre>　　$ cat test7.txt   
　　1       job:80,team:60,person:70  
　　2       job:60,team:80  
　　3       job:90,team:70,person:100  
　　Hive&gt;  LOAD DATA LOCAL INPATH '/home/work/data/test7.txt' INTO TABLE employee;  </pre></div><p> </p></div><p>　　3）查询</p><div><div class="cnblogs_code"><pre>　Hive&gt; select perf['person'] from employee;</pre></div><p> </p></div><p> </p><p> </p><p><strong>8、Hive 的 JOIN 用法</strong></p><p>      Hive只支持等连接，外连接，左半连接。Hive不支持非相等的join条件（通过其他方式实现，如left outer join），因为它很难在map/reduce job实现这样的条件。而且，Hive可以join两个以上的表。</p><p>　　<strong>8.1、等连接</strong></p><p>　　只有等连接才允许</p><div><div class="cnblogs_code"><pre>　　Hive&gt; SELECT a.* FROM a <strong>JOIN </strong>b ON (a.id = b.id)  
　　Hive&gt; SELECT a.* FROM a JOIN b ON (a.id = b.id AND a.department = b.department) </pre></div><p> </p></div><p>　　<strong>8.2、多表连接</strong></p><p>　　同个查询，可以join两个以上的表</p><div><div class="cnblogs_code"><pre>Hive&gt; SELECT a.val, b.val, c.val FROM a JOIN b ON (a.key = b.key1) JOIN c ON (c.key = b.key2) </pre></div><p> </p></div><p>　　<strong>8.3、join的缓存和任务转换</strong></p><p>　　Hive转换多表join时，如果每个表在join字句中，使用的都是同一个列，只会转换为一个单独的map/reduce。</p><div><div class="cnblogs_code"><pre>　Hive&gt; SELECT a.val, b.val, c.val FROM a JOIN b ON (a.key = b.key1) JOIN c ON (c.key = b.key1)</pre></div><p> </p></div><p>　　被转换为两个map/reduce任务，因为b的key1列在第一个join条件使用，而b表的key2列在第二个join条件使用。第一个map/reduce任务join a和b。第二个任务是第一个任务的结果join c。</p><div><div class="cnblogs_code"><pre>　Hive&gt; SELECT a.val, b.val, c.val FROM a JOIN b ON (a.key = b.key1) JOIN c ON (c.key = b.key2) </pre></div><p> </p></div><p>　　在join的每个map/reduce阶段，序列中的最后一个表，当其他被缓存时，它会流到reducers。所以，reducers需要缓存join关键字的特定值组成的行，通过组织最大的表出现在序列的最后，有助于减少reducers的内存。</p><div><div class="cnblogs_code"><pre>　Hive&gt; SELECT a.val, b.val, c.val FROM a JOIN b ON (a.key = b.key1) JOIN c ON (c.key = b.key1)</pre></div><p> </p></div><p>　　三个表，在同一个独立的map/reduce任务做join。a和b的key对应的特定值组成的行，会缓存在reducers的内存。然后reducers接受c的每一行，和缓存的每一行做join计算。</p><div><div class="cnblogs_code"><pre>　Hive&gt; SELECT a.val, b.val, c.val FROM a JOIN b ON (a.key = b.key1) JOIN c ON (c.key = b.key2) </pre></div><p> </p></div><p>　　这里有两个map/reduce任务在join计算被调用。第一个是a和b做join，然后reducers缓存a的值，另一边，从流接收b的值。第二个阶段，reducers缓存第一个join的结果，另一边从流接收c的值。</p><p>　　在join的每个map/reduce阶段，通过关键字，可以指定哪个表从流接收。</p><div><div class="cnblogs_code"><pre>　　Hive&gt; SELECT /*+ STREAMTABLE(a) */ a.val, b.val, c.val FROM a JOIN b ON (a.key = b.key1) JOIN c ON </pre></div></div><p>　　三个表的连接，会转换为一个map/reduce任务，reducer会把b和c的key的特定值缓存在内存里，然后从流接收a的每一行，和缓存的行做join。</p><p> </p><p><strong>　　8.4、join的结果</strong></p><p>　　LEFT，RIGHT，FULL OUTER连接存在是为了提供ON语句在没有匹配时的更多控制。例如，这个查询：</p><div><div class="cnblogs_code"><pre>Hive&gt; SELECT a.val, b.val FROM a LEFT OUTER JOIN b ON (a.key=b.key)  </pre></div><p> </p></div><p>　　将会返回a的每一行。如果b.key等于a.key,输出将是a.val,b.val,如果a没有和b.key匹配，输出的行将是 a.val,NULL。如果b的行没有和a.key匹配上，将被抛弃。语法"FROM a LEFT OUTER JOIN b"必须写在一行，为了理解它如何工作——这个查询，a是b的左边，a的所有行会被保持；RIGHT OUTER JOIN将保持b的所有行， FULL OUTER JOIN将会保存a和b的所有行。OUTER JOIN语义应该符合标准的SQL规范。</p><p> </p><p><strong>　　8.5、join的过滤</strong></p><p>　　Joins发生在where字句前，所以，如果要限制join的输出，需要写在where字句，否则写在JOIN字句。现在讨论的一个混乱的大点，就是分区表</p><div><div class="cnblogs_code"><pre>　　Hive&gt; SELECT a.val, b.val FROM a LEFT OUTER JOIN b ON (a.key=b.key)  WHERE a.ds='2009-07-07' AND b.ds='2009-07-07'  </pre></div><p> </p></div><p>　　将会连接a和b，产生a.val和b.val的列表。WHERE字句，也可以引用join的输出列，然后过滤他们。 但是，无论何时JOIN的行找到a的key，但是找不到b的key时，b的所有列会置成NULL，包括ds列。这就是说，将过滤join输出的所有行，包括没有合法的b.key的行。然后你会在LEFT OUTER的要求扑空。 也就是说，如果你在WHERE字句引用b的任何列，LEFT OUTER的部分join结果是不相关的。所以，当外连接时，使用这个语句</p><div><div class="cnblogs_code"><pre>Hive&gt; SELECT a.val, b.val FROM a LEFT OUTER JOIN b ON (a.key=b.key AND b.ds='2009-07-07' AND a.ds='2009-0</pre></div></div><p>    join的输出会预先过滤，然后你不用对有a.key而没有b.key的行做过滤。RIGHT和FULL join也是一样的逻辑。</p><p> </p><p><strong>　　8.6、join的顺序</strong></p><p>　　join是不可替换的，连接是从左到右，不管是LEFT或RIGHT join。</p><div><div class="cnblogs_code"><pre>Hive&gt;  SELECT a.val1, a.val2, b.val, c.val  FROM a  JOIN b ON (a.key = b.key)  LEFT OUTER JOIN c ON (a.key = c.key)</pre></div><p> </p></div><p>　　首先，连接a和b，扔掉a和b中没有匹配的key的行。结果表再连接c。这提供了直观的结果，如果有一个键都存在于A和C，但不是B：完整行(包括 a.val1,a.val2,a.key)会在"a jOIN b"步骤，被丢弃，因为它不在b中。结果没有a.key，所以当它和c做LEFT OUTER JOIN,c.val也无法做到，因为没有c.key匹配a.key(因为a的行都被移除了)。类似的，RIGHT OUTER JOIN(替换为LEFT),我们最终会更怪的效果,NULL, NULL, NULL, c.val。因为尽管指定了join key是a.key=c.key，我们已经在第一个JOIN丢弃了不匹配的a的所有行。      </p><p>    为了达到更直观的效果，相反，我们应该从Hive&gt; FROM c LEFT OUTER JOIN a ON (c.key = a.key) LEFT OUTER JOIN b ON (c.key = b.key).</p><p>LEFT SEMI JOIN实现了相关的IN / EXISTS的子查询语义的有效途径。由于Hive目前不支持IN / EXISTS的子查询，所以你可以用 LEFT SEMI JOIN 重写你的子查询语句。LEFT SEMI JOIN 的限制是， JOIN 子句中右边的表只能在 ON 子句中设置过滤条件，在 WHERE 子句、SELECT 子句或其他地方过滤都不行。</p><div><div class="cnblogs_code"><pre>Hive&gt; SELECT a.key, a.value FROM a WHERE a.key in (SELECT b.key FROM B); </pre></div><p> </p></div><p>  可以重写为</p><div><div class="cnblogs_code"><pre>　Hive&gt; SELECT a.key, a.val FROM a LEFT SEMI JOIN b on (a.key = b.key)  </pre></div><p> </p></div><p>　　<strong>8.7、map 端 join</strong></p><p>　　但如果所有被连接的表是小表，join可以被转换为只有一个map任务。查询是</p><div><div class="cnblogs_code"><pre>　　Hive&gt; SELECT /*+ MAPJOIN(b) */ a.key, a.value FROM a join b on a.key = b.key</pre></div><p> </p></div><p>　　不需要reducer。对于每一个mapper,A和B已经被完全读出。限制是a FULL/RIGHT OUTER JOIN b不能使用。</p><p>　　如果表在join的列已经分桶了，其中一张表的桶的数量，是另一个表的桶的数量的整倍，那么两者可以做桶的连接。如果A有4个桶，表B有4个桶，下面的连接：</p><div><div class="cnblogs_code"><pre>　　Hive&gt; SELECT /*+ MAPJOIN(b) */ a.key, a.value FROM a join b on a.key = b.key </pre></div><p> </p></div><p>　　只能在mapper工作。为了为A的每个mapper完整抽取B。对于上面的查询，mapper处理A的桶1，只会抽取B的桶1，这不是默认行为，要使用以下参数：</p><div><div class="cnblogs_code"><pre>　　Hive&gt; set Hive.optimize.bucketmapjoin = true; </pre></div><p> </p></div><p>  　　如果表在join的列经过排序，分桶，而且他们有相同数量的桶，可以使用排序-合并 join。每个mapper，相关的桶会做连接。如果A和B有4个桶</p><div><div class="cnblogs_code"><pre>　　Hive&gt; SELECT /*+ MAPJOIN(b) */ a.key, a.value FROM A a join B b on a.key = b.key </pre></div><p> </p></div><p> 　　只能在mapper使用。使用A的桶的mapper，也会遍历B相关的桶。这个不是默认行为，需要配置以下参数：</p><div><div class="cnblogs_code"><pre>　　Hive&gt; set Hive.input.format=org.apache.hadoop.Hive.ql.io.BucketizedHiveInputFormat;  
　　Hive&gt; set Hive.optimize.bucketmapjoin = true;  
　　Hive&gt; set Hive.optimize.bucketmapjoin.sortedmerge = true;  </pre></div><p> </p></div><p> </p><p> </p><p> </p><p> </p><p><strong>9、Hive 内置操作符与函数</strong></p><p>　<strong>　9.1 字符串函数</strong></p><p>　　　　1)       字符串长度函数：length</p><div><pre>　　语法: length(string A)  </pre><pre>　　返回值: int  </pre><pre>　　说明：返回字符串A的长度  </pre><pre>　　举例：  </pre><div class="cnblogs_code"><pre>　　Hive&gt; <strong>select length</strong>(‘abcedfg’) <strong>from </strong>dual;  </pre></div><pre>　　7 

</pre></div><p>　　　　2)       字符串反转函数：reverse</p><div><pre>　　语法: reverse(string A)  </pre><pre>　　返回值: string  </pre><pre>　　说明：返回字符串A的反转结果  </pre><pre>　　举例：  </pre><div class="cnblogs_code"><pre>　　Hive&gt; <strong>select reverse</strong>(‘abcedfg’) <strong>from </strong>dual;  </pre></div><pre>　　gfdecba

</pre></div><p>　　　　3)       字符串连接函数：concat</p><div><pre>　　语法: concat(string A, string B…)  </pre><pre>　　返回值: string  </pre><pre>　　说明：返回输入字符串连接后的结果，支持任意个输入字符串  </pre><pre>　　举例：  </pre><div class="cnblogs_code"><pre>　　Hive&gt; <strong>select concat</strong>(‘abc’,'def’,'gh’) <strong>from </strong>dual;  </pre></div><pre>　　abcdefgh  

</pre></div><p>　　　　4)       带分隔符字符串连接函数：concat_ws</p><div><pre>　　语法: concat_ws(string SEP, string A, string B…)  </pre><pre>　　返回值: string  </pre><pre>　　说明：返回输入字符串连接后的结果，SEP表示各个字符串间的分隔符  </pre><pre>　　举例：  </pre><div class="cnblogs_code"><pre>　　Hive&gt; <strong>select concat_ws</strong>(‘,’,'abc’,'def’,'gh’) <strong>from </strong>dual;  </pre></div><pre>　　abc,def,gh

</pre></div><p>　　　　5)       字符串截取函数：substr,substring</p><div><pre>　　语法: substr(string A, int start),substring(string A, int start)  </pre><pre>　　返回值: string  </pre><pre>　　说明：返回字符串A从start位置到结尾的字符串  </pre><pre>　　举例：  </pre><div class="cnblogs_code"><pre>　　Hive&gt; <strong>select substr</strong>(‘abcde’,3) <strong>from </strong>dual;  </pre></div><pre>　　cde  

</pre><div class="cnblogs_code"><pre>　　Hive&gt; select <strong>substring</strong>(‘abcde’,3) from dual;  </pre></div><pre>　　cde  

</pre><div class="cnblogs_code"><pre>　　Hive&gt;  select <strong>substr</strong>(‘abcde’,-1) from dual;  （和oracle相同）  </pre></div><pre>　　e  

</pre></div><p>　　6)       字符串截取函数：substr,substring</p><div><pre>　　语法: substr(string A, int start, int len),substring(string A, int start, int len)  </pre><pre>　　返回值: string  </pre><pre>　　说明：返回字符串A从start位置开始，长度为len的字符串  </pre><pre>　　举例：  </pre><div class="cnblogs_code"><pre>　　Hive&gt; select <strong>substr</strong>(‘abcde’,3,2) from dual;  </pre></div><pre>　　cd  

</pre><div class="cnblogs_code"><pre>　　Hive&gt; select <strong>substring</strong>(‘abcde’,3,2) from dual;  </pre></div><pre>　　cd  

</pre><div class="cnblogs_code"><pre>　　Hive&gt;select <strong>substring</strong>(‘abcde’,-2,2) from dual;  </pre></div><pre>　　de

</pre></div><p>　　7)       字符串转大写函数：upper,ucase</p><div><pre>　　语法: upper(string A) ucase(string A)  </pre><pre>　　返回值: string  </pre><pre>　　说明：返回字符串A的大写格式  </pre><pre>　　举例：  </pre><div class="cnblogs_code"><pre>　　Hive&gt; select <strong>upper</strong>(‘abSEd’) from dual;  </pre></div><pre>　　ABSED  

</pre><div class="cnblogs_code"><pre>　　Hive&gt; select <strong>ucase</strong>(‘abSEd’) from dual;  </pre></div><pre>　　ABSED 

</pre></div><p>　　8)       字符串转小写函数：lower,lcase</p><div><pre>　　语法: lower(string A) lcase(string A)  </pre><pre>　　返回值: string  </pre><pre>　　说明：返回字符串A的小写格式  </pre><pre>　　举例：  </pre><div class="cnblogs_code"><pre>　　Hive&gt; select <strong>lower</strong>(‘abSEd’) from dual;  </pre></div><p> </p><pre>　　absed  </pre><div class="cnblogs_code"><pre>　　Hive&gt; select <strong>lcase</strong>(‘abSEd’) from dual;  </pre></div><pre>　　absed

</pre></div><p>　　9)       去空格函数：trim</p><div><pre>　　语法: trim(string A)  </pre><pre>　　返回值: string  </pre><pre>　　说明：去除字符串两边的空格  </pre><pre>　　举例：  </pre><div class="cnblogs_code"><pre>　　Hive&gt; select <strong>trim</strong>(‘ abc ‘) from dual;  </pre></div><pre>　　abc 

</pre></div><p>　　10)   左边去空格函数：ltrim</p><div><pre>　　语法: ltrim(string A)  </pre><pre>　　返回值: string  </pre><pre>　　说明：去除字符串左边的空格  </pre><pre>　　举例：  </pre><div class="cnblogs_code"><pre>　　Hive&gt; select <strong>ltrim</strong>(‘ abc ‘) from dual;  </pre></div><pre>　　abc

</pre></div><p>　　11)   右边去空格函数：rtrim</p><div><pre>　　语法: rtrim(string A)  </pre><pre>　　返回值: string  </pre><pre>　　说明：去除字符串右边的空格  </pre><pre>　　举例：  </pre><div class="cnblogs_code"><pre>　　Hive&gt; select <strong>rtrim</strong>(‘ abc ‘) from dual;  </pre></div><pre>　　abc </pre></div><p> </p><p><strong>　　9.2 集合统计函数</strong></p><p>　　　　1)       个数统计函数 count。</p><div><pre>　　语法：count(*),count(expr),count(distinct expr)</pre><pre>　　返回值 int。</pre><pre>　　count(*)统计检索出行的个数，包括 NULL 值的行；</pre><pre>　　count(expr)返回指定字段的非空值的个数；</pre><pre>　　count(distinct expr)返回指定字段的不同的非空值的个数。</pre><pre>　　举例：</pre><div class="cnblogs_code"><pre>　　Hive&gt; select count(*) from user;
　　Hive&gt; select count(distinct age);</pre></div><p> </p></div><p>　　　　2)       总和统计函数 sum。</p><div><pre>　　语法：sum(col),sum(distinct col)</pre><pre>　　返回值 double。</pre><pre>　　sum(col) 统计结果集中 col 的相加的结果；</pre><pre>　　sum(distinct col) 统计结果中 col 不同值相加的结果。</pre><pre>　　举例：</pre><div class="cnblogs_code"><pre>　　Hive&gt; select sum(age) from user;
　　Hive&gt; select sum(distinct age) from user;</pre></div><p> </p></div><p>　　3)       平均值统计函数avg。</p><div><pre>　　语法：avg(col),avg(distinct col)</pre><pre>　　返回值 double。</pre><pre>　　avg(col) 统计结果集中的平均值；</pre><pre>　　avg(distinct col) 统计结果中 col 不同值相加的平均值。</pre><pre>　　举例：</pre><div class="cnblogs_code"><pre>　Hive&gt; select avg(mark) from user;
  Hive&gt; select avg(distinct mark) from user</pre></div><p> </p></div><p>　　　　4）  最小值统计函数 min。统计结果集中 col 字段的最小值</p><div><pre>　　语法：min(col)</pre><pre>　　返回值double。</pre><pre>　　举例：</pre><div class="cnblogs_code"><pre>　　Hive&gt;select min(mark) from user;</pre></div><p> </p></div><p>　　　　5) 最大值统计函数 max。统计结果集中 col 字段的最大值。</p><div><pre>　　语法：max(col)</pre><pre>　　返回值 double。</pre><pre>　　举例：</pre><div class="cnblogs_code"><pre>　　Hive&gt; select max(mark) from user;</pre></div><p> </p></div><p><strong> </strong></p><p> </p><p> </p><p> </p><p><strong>10、复合类型操作</strong></p><p>　　　　1)       Map 类型构建。根据输入的 Key-Value 对构建 Map 类型。</p><div><pre>　　语法：map(key1, value1, key2, value2,...)</pre><pre>　　举例：</pre><div class="cnblogs_code"><pre>　　Hive&gt; create table map_test as select <strong>map('100','jay','200','liu')</strong> from student;
　　Hive&gt; describe map_test;
　　Hive&gt; select map_test from student;</pre></div><p> </p></div><p>　　　　2)       Struct 类型构建。根据输入的参数构建结构体 Struct 类型。</p><div><pre>　　语法：struct(val1, val2, val3, ...)</pre><pre>　　举例：</pre><div class="cnblogs_code"><pre>　Hive&gt; create table struct_test as select <strong>struct('jay','liu','gang')</strong> from student;
　Hive&gt; describe struct_test;
　Hive&gt; select struct_test from student;</pre></div><p> </p><pre>
</pre></div><p>　　　　3)       Array 类型构建。根据输入的参数构建数组 Array 类型</p><div><pre>　　语法：array(val1,val2, ...)</pre><pre>　　举例：</pre><div class="cnblogs_code"><pre>　　Hive&gt; create table array_test as select<strong> array('jay','liu','gang')</strong> from student;
　　Hive&gt; describe array_test;
　　Hive&gt; select array_test from array_test;</pre></div><p> </p></div><p> </p><p> 对于，<strong>复合类型操作。进一步学习，请移步</strong></p><h1><a class="postTitle2" href="http://www.cnblogs.com/zlslch/p/5949622.html" rel="nofollow">3 hql语法及自定义函数（含array、map讲解） + hive的java api</a></h1><p> </p><p> </p><p> </p><p> </p><p><strong>11、用户自定义函数 UDF</strong></p><p>　　UDF(User Defined Function,用户自定义函数) 对数据进行处理。UDF 函数可以直接应用于 select 语句，对查询结构做格式化处理后，再输出内容。</p><p>　　Hive可以允许用户编写自己定义的函数UDF，来在查询中使用。Hive中有3种UDF：</p><p>　　　　1) UDF：操作单个数据行，产生单个数据行。</p><p>           2) UDAF：操作多个数据行，产生一个数据行。</p><p>           3) UDTF：操作一个数据行，产生多个数据行一个表作为输出。</p><p> </p><p>　　<strong>用户构建的UDF使用过程如下：</strong></p><p>          第一步：继承UDF或者UDAF或者UDTF，实现特定的方法。</p><p>         第二步：将写好的类打包为jar。如Hivefirst.jar。</p><p>         第三步：进入到Hive外壳环境中，利用add jar /home/hadoop/Hivefirst.jar 注册该jar文件。</p><p>         第四步：为该类起一个别名，create temporary function mylength as 'com.whut.StringLength';这里注意UDF只是为这个Hive会话临时定义的。</p><p>         第五步：在select中使用mylength()。</p><p> </p><p>        <strong>自定义UDF</strong></p><div><pre>　　</pre><div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a title="复制代码"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a title="复制代码"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div><pre>package whut;
　　import org.apache.commons.lang.StringUtils;
　　import org.apache.hadoop.Hive.ql.exec.UDF;
　　import org.apache.hadoop.io.Text;

　　//UDF是作用于单个数据行，产生一个数据行
　　//用户必须要继承UDF，且必须至少实现一个evalute方法，该方法并不在UDF中
　　//但是Hive会检查用户的UDF是否拥有一个evalute方法
　　public class Strip extends UDF{
        　　 private Text result=new Text();
        　　 //自定义方法
       　　  public Text evaluate(Text str)
         　　{
                 　　if(str==null)
                 　　return null;
                 　　result.set(StringUtils.strip(str.toString()));
                 　　return result;
         　　}

         　　public Text evaluate(Text str,String stripChars)
        　　 {
                　　 if(str==null)
                 　　return null;
                　　 result.set(StringUtils.strip(str.toString(),stripChars));
                 　　return result;
        　　 }
　　}</pre><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a title="复制代码"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a title="复制代码"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div></div><p> </p></div><p>        1、一个用户UDF必须继承org.apache.hadoop.Hive.ql.exec.UDF;</p><p>        2、一个UDF必须要包含有evaluate()方法，但是该方法并不存在于UDF中。evaluate的参数个数以及类型都是用户自己定义的。在使用的时候，Hive会调用UDF的evaluate()方法。</p><p> </p><p> </p><p>      <strong>  自定义UDAF找到最大值</strong></p><div><div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a title="复制代码"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a title="复制代码"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div><pre>　  package whut;
　　import org.apache.hadoop.Hive.ql.exec.UDAF;
　　import org.apache.hadoop.Hive.ql.exec.UDAFEvaluator;
　　import org.apache.hadoop.io.IntWritable;

　　//UDAF是输入多个数据行，产生一个数据行
　　//用户自定义的UDAF必须是继承了UDAF，且内部包含多个实现了exec的静态类
　　public class MaxiNumber extends UDAF{
         　　public static class MaxiNumberIntUDAFEvaluator implements UDAFEvaluator{
         　　//最终结果
         　　private IntWritable result;
         　　//负责初始化计算函数并设置它的内部状态，result是存放最终结果的
        　　 @Override
        　　 public void init() {
               　　  result=null;
        　　 }

        　　 //每次对一个新值进行聚集计算都会调用iterate方法
         　　public boolean iterate(IntWritable value)
        　　 {
                 　　if(value==null)
                 　　         return false;
                　　 if(result==null)
                 　　         result=new IntWritable(value.get());
                　　 else
                      　　    result.set(Math.max(result.get(), value.get()));
                　　 return true;
        　　 }

          
        　　 //Hive需要部分聚集结果的时候会调用该方法
         　　//会返回一个封装了聚集计算当前状态的对象
         　　public IntWritable terminatePartial()
         　　{
         　　        return result;
         　　}

         　　//合并两个部分聚集值会调用这个方法
        　　 public boolean merge(IntWritable other)
         　　{
            　　     return iterate(other);
        　　 }

        　　 //Hive需要最终聚集结果时候会调用该方法
       　　  public IntWritable terminate()
        　　 {
            　　     return result;
        　　 }
        }

　　}
</pre><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a title="复制代码"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a title="复制代码"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div></div></div><p> 　　　<strong>　注意事项：</strong></p><p>　　　　　　　　1、用户的UDAF必须继承了org.apache.hadoop.Hive.ql.exec.UDAF。</p><p>　　　　　　　　2、用户的UDAF必须包含至少一个实现了org.apache.hadoop.Hive.ql.exec的静态类，诸如常见的实现了 UDAFEvaluator。</p><p>　　　　　　　　3、一个计算函数必须实现的5个方法的具体含义如下：</p><p> 　　　　　　　　　　init()：主要是负责初始化计算函数并且重设其内部状态，一般就是重设其内部字段。一般在静态类中定义一个内部字段来存放最终的结果。</p><p>　　　　　　　　　　iterate()：每一次对一个新值进行聚集计算时候都会调用该方法，计算函数会根据聚集计算结果更新内部状态。当输入值合法或者正确计算了，则就返回true。</p><p>　　　　　　　　　　terminatePartial()：Hive需要部分聚集结果的时候会调用该方法，必须要返回一个封装了聚集计算当前状态的对象。</p><p>　　　　　　　　　　merge()：Hive进行合并一个部分聚集和另一个部分聚集的时候会调用该方法。 terminate()：Hive最终聚集结果的时候就会调用该方法。计算函数需要把状态作为一个值返回给用户。</p><p> </p><p>　　　　　　    4、  部分聚集结果的数据类型和最终结果的数据类型可以不同。</p><p> </p><p> </p><p><strong>12、Hive 查询优化</strong></p><p><strong>　　12.1  join优化</strong></p><p>        Join查找操作的基本原则：应该<strong>将条目少的表/子查询放在 Join 操作符的左边</strong>。原因是在 Join 操作的 Reduce 阶段，位于 Join 操作符左边的表的内容会被加载进内存，将条目少的表放在左边，可以有效减少发生内存溢出错误的几率。</p><p>        Join查找操作中如果存在多个join，且所有参与join的表中其参与join的key都相同，则会将所有的join合并到一个mapred程序中。</p><p> </p><p>        案例：</p><div><div class="cnblogs_code"><pre>　SELECT a.val, b.val, c.val FROM a JOIN b ON (a.key = b.key1) JOIN c ON (c.key = b.key1)  //在一个mapre程序中执行join
　SELECT a.val, b.val, c.val FROM a JOIN b ON (a.key = b.key1) JOIN c ON (c.key = b.key2)   //在两个mapred程序中执行join</pre></div><p> </p></div><p>  　　 Map join的关键在于join操作中的某个表的数据量很小，案例：</p><div><div class="cnblogs_code"><pre>　SELECT /*+ MAPJOIN(b) */ a.key, a.value FROM a join b on a.key = b.key</pre></div><p> </p></div><p>  　　Mapjoin 的限制是无法执行a FULL/RIGHT OUTER JOIN b，和map join相关的Hive参数：</p><div><div class="cnblogs_code"><pre>　　　　Hive.join.emit.interval
　　　　Hive.mapjoin.size.key
　　　　Hive.mapjoin.cache.numrows</pre></div><p> </p></div><p>  　　 由于join操作是在where操作之前执行，所以当你在执行join时，where条件并不能起到减少join数据的作用；案例：</p><div><div class="cnblogs_code"><pre>　　　　SELECT a.val, b.val FROM a LEFT OUTER JOIN b ON (a.key=b.key) WHERE a.ds='2009-07-07' AND b.ds='2009-07-07'</pre></div><p> </p><pre>　　最好修改为：</pre><div class="cnblogs_code"><pre>　　　　SELECT a.val, b.val FROM a LEFT OUTER JOIN b ON (a.key=b.key AND b.ds='2009-07-07' AND a.ds='2009-07-07')</pre></div><p> </p></div><p>      在join操作的每一个mapred程序中，Hive都会把出现在join语句中相对靠后的表的数据stream化，相对靠前的变的数据缓存在内存中。当然，也可以手动指定stream化的表：</p><div><div class="cnblogs_code"><pre>　　　　SELECT /*+ STREAMTABLE(a) */ a.val, b.val, c.val FROM a JOIN b ON (a.key = b.key1) JOIN c ON (c.key = b.key1)</pre></div><p> </p></div><p> </p><p><strong>　　12.2  group by 优化</strong></p><p>        Map端聚合，首先在map端进行初步聚合，最后在reduce端得出最终结果，相关参数：</p><div><div class="cnblogs_code"><pre>　Hive.map.aggr = true  //是否在 Map 端进行聚合，默认为 True
　Hive.groupby.mapaggr.checkinterval = 100000  //在 Map 端进行聚合操作的条目数目</pre></div><p> </p></div><p>   　　数据倾斜聚合优化，设置参数Hive.groupby.skewindata = true，当选项设定为 true，生成的查询计划会有两个 MR Job。第一个 MR Job 中，Map 的输出结果集合会随机分布到 Reduce 中，每个 Reduce 做部分聚合操作，并输出结果，这样处理的结果是相同的 Group By Key 有可能被分发到不同的 Reduce 中，从而达到负载均衡的目的；第二个 MR Job 再根据预处理的数据结果按照 Group By Key 分布到 Reduce 中（这个过程可以保证相同的 Group By Key 被分布到同一个 Reduce 中），最后完成最终的聚合操作。</p><p><strong> </strong></p><p><strong>　　12.3 合并小文件</strong></p><p>        文件数目过多，会给 HDFS 带来压力，并且会影响处理效率，可以通过合并 Map 和 Reduce 的结果文件来消除这样的影响：</p><div><div class="cnblogs_code"><pre>　Hive.merge.mapfiles = true  //是否和并 Map 输出文件，默认为 True
　Hive.merge.mapredfiles = false  //是否合并 Reduce 输出文件，默认为 False
　Hive.merge.size.per.task = 256*1000*1000  //合并文件的大小</pre></div><p> </p></div><p> </p><p><strong>　　12.4 Hive实现(not) in</strong></p><p>        通过left outer join进行查询,（假设B表中包含另外的一个字段 key1</p><div><div class="cnblogs_code"><pre>　select a.key from a left outer join b on a.key=b.key where b.key1 is null</pre></div><p> </p></div><p>     　　通过left semi join 实现 in</p><div><div class="cnblogs_code"><pre>　SELECT a.key, a.val FROM a LEFT SEMI JOIN b on (a.key = b.key)</pre></div></div><p>  　　　　Left semi join 的限制：join条件中右边的表只能出现在join条件中。</p><p> </p><p><strong>　　12.5 排序优化</strong></p><p> 　　Order by 实现全局排序，一个reduce实现，效率低。</p><p>       Sort by 实现部分有序，单个reduce输出的结果是有序的，效率高，通常和DISTRIBUTE BY关键字一起使用（DISTRIBUTE BY关键字 可以指定map 到 reduce端的分发key）。</p><p>       CLUSTER BY col1 等价于DISTRIBUTE BY col1 SORT BY col1</p><p> </p><p><strong>　　12.6 使用分区</strong></p><p>        Hive中的每个分区都对应hdfs上的一个目录，分区列也不是表中的一个实际的字段，而是一个或者多个伪列，在表的数据文件中实际上并不保存分区列的信息与数据。Partition关键字中排在前面的为主分区（只有一个），后面的为副分区 静态分区：静态分区在加载数据和使用时都需要在sql语句中指定。</p><p>        案例：(stat_date='20120625',province='hunan')</p><p>        动态分区：使用动态分区需要设置Hive.exec.dynamic.partition参数值为true，默认值为false，在默认情况下，Hive会假设主分区时静态分区，副分区使用动态分区；如果想都使用动态分区，需要设置set Hive.exec.dynamic.partition.mode=nostrick，默认为strick。</p><p>         案例：(stat_date='20120625',province)</p><p> </p><p><strong>　　12.7 Distinct 使用</strong></p><p>        Hive支持在group by时对同一列进行多次distinct操作，却不支持在同一个语句中对多个列进行distinct操作。</p><p> </p><p><strong>　　12.8 Hql使用自定义的mapred脚本</strong></p><p>        注意事项：在使用自定义的mapred脚本时，关键字MAP REDUCE 是语句SELECT TRANSFORM ( ... )的语法转换，并不意味着使用MAP关键字时会强制产生一个新的map过程，使用REDUCE关键字时会产生一个red过程。</p><p>        自定义的mapred脚本可以是hql语句完成更为复杂的功能，但是性能比hql语句差了一些，应该尽量避免使用，如有可能，使用UDTF函数来替换自定义的mapred脚本</p><p> </p><p><strong>　　12.9 UDTF</strong></p><p>        UDTF将单一输入行转化为多个输出行，并且在使用UDTF时，select语句中不能包含其他的列，UDTF不支持嵌套，也不支持group by 、sort by等语句。如果想避免上述限制，需要使用lateral view语法，案例：</p><div><div class="cnblogs_code"><pre>　select a.timestamp, get_json_object(a.appevents, '$.eventid'), get_json_object(a.appenvets, '$.eventname') from log a;
　select a.timestamp, b.* from log a lateral view json_tuple(a.appevent, 'eventid', 'eventname') b as f1, f2;</pre></div><p> </p></div><p>　　其中，get_json_object为UDF函数，json_tuple为UDTF函数。UDTF函数在某些应用场景下可以大大提高hql语句的性能，如需要多次解析json或者xml数据的应用场景。</p><p> </p><p><strong>　　12.10 聚合函数count和sum</strong></p><p>        Count和sum函数可能是在hql语句中使用的最为频繁的两个聚合函数了，但是在Hive中count函数在计算distinct value时支持加入条件过滤。</p><p> </p><p> </p><p> </p><p><strong>13、Hive 的权限控制</strong></p><p>        Hive从0.10可以通过元数据控制权限。但是Hive的权限控制并不是完全安全的。基本的授权方案的目的是防止用户不小心做了不合适的事情。</p><p>        为了使用Hive的授权机制，有两个参数必须在Hive-site.xml中设置：</p><div><div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a title="复制代码"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a title="复制代码"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div><pre>&lt; property&gt; 
         &lt; name&gt;Hive.security.authorization.enabled&lt; /name&gt; 
         &lt; value&gt;true&lt; /value&gt; 
          &lt; description&gt;enable or disable the Hive client authorization&lt; /description&gt; 
 &lt; /property&gt; 

 
&lt; property&gt; 
          &lt; name&gt;Hive.security.authorization.createtable.owner.grants&lt; /name&gt; 
          &lt; value&gt;ALL&lt; /value&gt; 
          &lt; description&gt;the privileges automatically granted to the owner whenever a table gets created. An example like "select,drop" will grant select and drop privilege to the owner of the table&lt; /description&gt;
&lt; /property&gt;</pre><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a title="复制代码"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a title="复制代码"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div></div></div><p>  　　 Hive.security.authorization.enabled //参数是开启权限验证，默认为 false。</p><p>        Hive.security.authorization.createtable.owner.grants //参数是指表的创建者对表拥有所有权限。</p><p> </p><p> </p><p> </p><p><strong>14、角色的创建和删除</strong></p><p> 　　Hive 中的角色定义与关系型数据库中角色的定义类似，它是一种机制，给予那些没有适当权限的用户分配一定的权限。</p><p><strong>　　14.1     创建角色</strong></p><div><div class="cnblogs_code"><pre>　　　　语法：Hive&gt; create role role_name;
　　　　示例：Hive&gt; create role role_tes1;</pre></div><p> </p></div><p><strong>　　14.2    删除角色。</strong></p><div><div class="cnblogs_code"><pre>　　语法：drop role role_name
　　示例：drop role role_test1;</pre></div><p> </p><pre>

</pre></div><p><strong>15、角色的授权和撤销</strong></p><p><strong>　　15.1    把 role_test1 角色授权给 xiaojiang 用户，命令如下。</strong></p><div><div class="cnblogs_code"><pre>　　　　Hive&gt; grant role role_test1 to user xiaojiang;</pre></div><p> </p></div><p><strong>　　15.2    查看 xiaojiang 用户被授权的角色，命令如下。</strong></p><div><div class="cnblogs_code"><pre>      Hive &gt; show role grant user xiaojiang;</pre></div><p> </p></div><p><strong>　　15.3   取消 xiaojiang 用户的 role_test1 角色，命令如下。</strong></p><div><div class="cnblogs_code"><pre>　　　Hive&gt; revoke role role_test1 from user xiaojiang;</pre></div><p> </p></div><p> </p><p> </p><p><strong>16、Hive 支持的权限控制</strong></p><p><strong>　 16.1   把 select 权限授权给 xiaojiang 用户，命令如下。</strong></p><div><div class="cnblogs_code"><pre>　　　　Hive&gt; grant select on database default to user xiaojiang;</pre></div><p> </p></div><p><strong>　16.2   查看 xiaojiang 被授予那些操作权限，命令如下。</strong></p><div><div class="cnblogs_code"><pre>　　　　Hive&gt; show grant user xiaojiang on database default;</pre></div><p> </p></div><p><strong>　16.3   收回 xiaojiang 的 select 权限，操作如下。</strong></p><div><div class="cnblogs_code"><pre>　　　　Hive&gt; revoke select on database default from user xiaojiang;</pre></div><p> </p></div><p><strong>　16.4    查看 xiaojiang 用户拥有哪些权限，命令如下。</strong></p><div><div class="cnblogs_code"><pre>　　　　Hive&gt; show grant user xiaojiang on database default;</pre></div><p> </p></div><p><strong> </strong></p><p> </p><p> </p><p><strong>17、超级管理权限</strong></p><p>        Hive本身有权限管理功能，需要通过配置开启。</p><div><div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a title="复制代码"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a title="复制代码"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div><pre>　&lt; property&gt; 
 　　   &lt; name&gt;Hive.metastore.authorization.storage.checks&lt; /name&gt;
  　　  &lt; value&gt;true&lt; /value&gt;
　　&lt; /property&gt;


　　&lt; property&gt;
  　　  &lt; name&gt;Hive.metastore.execute.setugi&lt; /name&gt;
   　　 &lt; value&gt;false&lt; /value&gt;
　　&lt; /property&gt;


　　&lt; property&gt;
   　　 &lt; name&gt;Hive.security.authorization.enabled&lt; /name&gt;
    　　&lt; value&gt;true&lt; /value&gt;
　　&lt; /property&gt;

 
　　&lt; property&gt;
   　　 &lt; name&gt;Hive.security.authorization.createtable.owner.grants&lt; /name&gt;
   　　 &lt; value&gt;ALL&lt; /value&gt;
　　&lt; /property&gt;</pre><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a title="复制代码"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a title="复制代码"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div></div></div><p>      　其中Hive.security.authorization.createtable.owner.grants设置成ALL表示用户对自己创建的表是有所有权限的（这样是比较合理地）。</p><p>         开启权限控制有Hive的权限功能还有一个需要完善的地方，那就是“超级管理员”。 Hive中没有超级管理员，任何用户都可以进行Grant/Revoke操作，为了完善“超级管理员”，必须添加Hive.semantic.analyzer.hook配置，并实现自己的权限控制类。</p><p> </p><p>        编写权限控制类，代码如下所示。</p><div><div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a title="复制代码"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a title="复制代码"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div><pre>　package com.xxx.Hive;
　　import org.apache.hadoop.Hive.ql.parse.ASTNode;
　　import org.apache.hadoop.Hive.ql.parse.AbstractSemanticAnalyzerHook;
　　import org.apache.hadoop.Hive.ql.parse.HiveParser;
　　import org.apache.hadoop.Hive.ql.parse.HiveSemanticAnalyzerHookContext;
　　import org.apache.hadoop.Hive.ql.parse.SemanticException;
　　import org.apache.hadoop.Hive.ql.session.SessionState;

　　/**   
        　　 * 设置Hive超级管理员   *   
        　　 * @author   
        　　 * @version $Id: AuthHook.java,v 0.1 2013-6-13 下午3:32:12 yinxiu Exp $  
    */  
　　public class AuthHook extends AbstractSemanticAnalyzerHook { 
        　　 private static String admin = "admin";
        　　 @Override 27 public ASTNode preAnalyze(HiveSemanticAnalyzerHookContext context, 28 ASTNode ast) throws SemanticException {
        　　 switch (ast.getToken().getType()) { 
                 　　case HiveParser.TOK_CREATEDATABASE: 
                 　　case HiveParser.TOK_DROPDATABASE: 
                 　　case HiveParser.TOK_CREATEROLE: 
                 　　case HiveParser.TOK_DROPROLE:
                 　　case HiveParser.TOK_GRANT: 
                 　　case HiveParser.TOK_REVOKE: 
                 　　case HiveParser.TOK_GRANT_ROLE: 
                　　 case HiveParser.TOK_REVOKE_ROLE: 
                 　　String userName = null;
                 　　if (SessionState.get() != null  &amp;&amp; SessionState.get().getAuthenticator() != null) {
                　　          userName = SessionState.get().getAuthenticator().getUserName();
                　　 } 
                　　 if (!admin.equalsIgnoreCase(userName)) { 
                　　          throw new SemanticException(userName + " can't use ADMIN options, except " + admin + ".");
                　　  } 
                　　 break;
                　　 default: 
                　　 break;
                　　 }
                　　 return ast;
        　　 } 
　　}</pre><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a title="复制代码"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a title="复制代码"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div></div><p> </p><pre>
</pre></div><p>     　　添加了控制类之后还必须添加下面的配置：</p><div><div class="cnblogs_code"><pre>　　&lt; property&gt; 
      　　   &lt; name&gt;Hive.semantic.analyzer.hook&lt; /name&gt; 
        　　 &lt; value&gt;com.xxx.AuthHook&lt; /value&gt;  
　　&lt; /property&gt;</pre></div><p> </p></div><p>    　　若有使用Hiveserver，Hiveserver必须重启。</p><p>        至此，只有admin用户可以进行Grant/Revoke操作。</p><p> </p><p>       　　 权限操作示例：</p><div><div class="cnblogs_code"><pre>　　Hive &gt; grant select on database default to user xiaojiang;
　　Hive &gt; revoke all on database default from user xiaojiang;
　　Hive &gt; show grant user xiaojiang on database default;</pre></div><p> </p><br><pre>


</pre></div><p><strong>18、Hive与JDBC示例</strong></p><p>        在使用 JDBC 开发 Hive 程序时, 必须首先开启 Hive 的远程服务接口。使用下面命令进行开启。</p><div><div class="cnblogs_code"><pre>　　　Hive -service Hiveserver &amp;  　　//Hive低版本提供的服务是：Hiveserver
　　　Hive --service Hiveserver2 &amp;       //Hive0.11.0以上版本提供了的服务是：Hiveserver2</pre></div></div><p>　　我这里使用的Hive1.0版本，故我们使用Hiveserver2服务，下面我使用 Java 代码通过JDBC连接Hiveserver。</p><p> <img src="https://images2015.cnblogs.com/blog/855959/201703/855959-20170314192226885-603700493.png" alt=""></p><div class="cnblogs_code"><pre>[hadoop@djt002 hive-1.0.0]$ pwd
/usr/local/hive/hive-1.0.0
[hadoop@djt002 hive-1.0.0]$ bin/hive --service hiveserver2 &amp;</pre></div><p> </p><p> </p><p><strong>　　18.1  测试数据</strong></p><p>        本地目录/usr/local/data下的djt.txt文件内容(每行数据之间用tab键隔开)如下所示:</p><div><div class="cnblogs_code"><pre>1    dajiangtai;
2    hadoop
3    hive
4    hbase
5    spark</pre></div><img src="https://images2015.cnblogs.com/blog/855959/201703/855959-20170314192410463-684041484.png" alt=""><p> </p></div><p><strong>  　　18.2  程序代码</strong></p><div><div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a title="复制代码"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a title="复制代码"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div><pre> 1 package com.dajangtai.Hive;
 2 
 3 
 4 
 5 
 6 import java.sql.Connection;
 7 import java.sql.DriverManager;
 8 import java.sql.ResultSet;
 9 import java.sql.SQLException;
10 import java.sql.Statement;
11 
12 
13 public class Demo {
14     private static String driverName = "org.apache.hive.jdbc.HiveDriver";//hive驱动名称
15     private static String url = "jdbc:hive2://djt002:10000/default";//连接hive2服务的连接地址，Hive0.11.0以上版本提供了一个全新的服务：HiveServer2
16     private static String user = "hadoop";//对HDFS有操作权限的用户
17     private static String password = "";//在非安全模式下，指定一个用户运行查询，忽略密码
18     private static String sql = "";
19     private static ResultSet res;
20     public static void main(String[] args) {
21         try {
22             Class.forName(driverName);//加载HiveServer2驱动程序
23             Connection conn = DriverManager.getConnection(url, user, password);//根据URL连接指定的数据库
24             Statement stmt = conn.createStatement();
25             
26             //创建的表名
27             String tableName = "testHiveDriverTable";
28             
29             /** 第一步:表存在就先删除 **/
30             sql = "drop table " + tableName;
31             stmt.execute(sql);
32             
33             /** 第二步:表不存在就创建 **/
34             sql = "create table " + tableName + " (key int, value string)  row format delimited fields terminated by '\t' STORED AS TEXTFILE";
35             stmt.execute(sql);
36             
37             // 执行“show tables”操作
38             sql = "show tables '" + tableName + "'";
39             res = stmt.executeQuery(sql);
40             if (res.next()) {
41                 System.out.println(res.getString(1));
42             }
43             
44             // 执行“describe table”操作
45             sql = "describe " + tableName;
46             res = stmt.executeQuery(sql);
47             while (res.next()) {  
48                 System.out.println(res.getString(1) + "\t" + res.getString(2));
49             }
50             
51             // 执行“load data into table”操作
52             String filepath = "/usr/local/data/djt.txt";//hive服务所在节点的本地文件路径
53             sql = "load data local inpath '" + filepath + "' into table " + tableName;
54             stmt.execute(sql);
55             
56             // 执行“select * query”操作
57             sql = "select * from " + tableName;
58             res = stmt.executeQuery(sql);
59             while (res.next()) {
60                 System.out.println(res.getInt(1) + "\t" + res.getString(2));
61             }
62             
63             // 执行“regular hive query”操作，此查询会转换为MapReduce程序来处理
64             sql = "select count(*) from " + tableName;
65             res = stmt.executeQuery(sql);
66             while (res.next()) {
67                 System.out.println(res.getString(1));
68             }        
69             conn.close();
70             conn = null;
71         } catch (ClassNotFoundException e) {
72             e.printStackTrace();
73             System.exit(1);
74         } catch (SQLException e) {
75             e.printStackTrace();
76             System.exit(1);
77         }
78     }
79 }</pre><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a title="复制代码"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a title="复制代码"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div></div><p> </p></div><p><strong>   　　18.3  运行结果(右击--&gt;Run as--&gt;Run on Hadoop)</strong></p><p>       　　 执行“show tables”运行结果:</p><div><pre>　　　　　　　　testHivedrivertable</pre><img src="https://images2015.cnblogs.com/blog/855959/201703/855959-20170314192637823-910212957.png" alt=""><p> </p></div><p>  　　　　 执行“describe table”运行结果:</p><div><pre>　　　　　　key    int</pre><pre>　　　　　　value    string

</pre></div><p>   　　   执行“select * query”运行结果:</p><div><pre>　　　　　　1        dajiangtai</pre><pre>　　　　　　2        hadoop</pre><pre>　　　　　　3        Hive</pre><pre>　　　　　　4        hbase</pre><pre>　　　　　　5        spark

</pre></div><p> 　　　　  执行“regular Hive query”运行结果:</p><div><pre>　　　　　　5





</pre><img src="https://images2015.cnblogs.com/blog/855959/201703/855959-20170314192039854-186652413.png" alt=""><p> </p><p><img src="https://images2015.cnblogs.com/blog/855959/201703/855959-20170314192517885-1262320372.png" alt=""></p><div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a title="复制代码"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a title="复制代码"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div><pre>[hadoop@djt002 hive-1.0.0]$ <strong>bin/hive --service hiveserver2 &amp;</strong>
[1] 13063
[hadoop@djt002 hive-1.0.0]$ SLF4J: Class path contains multiple SLF4J bindings.
SLF4J: Found binding in [jar:file:/usr/local/hadoop/hadoop-2.6.0/share/hadoop/common/lib/slf4j-log4j12-1.7.5.jar!/org/slf4j/impl/StaticLoggerBinder.class]
SLF4J: Found binding in [jar:file:/usr/local/hive/hive-1.0.0/lib/hive-jdbc-1.0.0-standalone.jar!/org/slf4j/impl/StaticLoggerBinder.class]
SLF4J: See http://www.slf4j.org/codes.html#multiple_bindings for an explanation.
SLF4J: Actual binding is of type [org.slf4j.impl.Log4jLoggerFactory]
OK
OK
OK
OK

Loading data to table default.testhivedrivertable
Table default.testhivedrivertable stats: [numFiles=1, totalSize=46]
OK
OK
Query ID = hadoop_20170314223030_618f4f4e-d32c-4a04-bd4f-83b61c38a0a7
Total jobs = 1
Launching Job 1 out of 1
Number of reduce tasks determined at compile time: 1
In order to change the average load for a reducer (in bytes):
set hive.exec.reducers.bytes.per.reducer=&lt;number&gt;
In order to limit the maximum number of reducers:
set hive.exec.reducers.max=&lt;number&gt;
In order to set a constant number of reducers:
set mapreduce.job.reduces=&lt;number&gt;
Starting Job = job_1489492626721_0001, Tracking URL = http://djt002:8088/proxy/application_1489492626721_0001/
Kill Command = /usr/local/hadoop/hadoop-2.6.0/bin/hadoop job -kill job_1489492626721_0001
Hadoop job information for Stage-1: number of mappers: 1; number of reducers: 1
2017-03-14 22:31:36,226 Stage-1 map = 0%, reduce = 0%
2017-03-14 22:32:33,764 Stage-1 map = 100%, reduce = 0%, Cumulative CPU 9.08 sec
2017-03-14 22:33:10,992 Stage-1 map = 100%, reduce = 67%, Cumulative CPU 12.34 sec
2017-03-14 22:33:14,485 Stage-1 map = 100%, reduce = 100%, Cumulative CPU 14.51 sec
MapReduce Total cumulative CPU time: 14 seconds 510 msec
Ended Job = job_1489492626721_0001
MapReduce Jobs Launched:
Stage-Stage-1: Map: 1 Reduce: 1 Cumulative CPU: 14.51 sec HDFS Read: 266 HDFS Write: 2 SUCCESS
Total MapReduce CPU Time Spent: 14 seconds 510 msec
OK</pre><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a title="复制代码"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a title="复制代码"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></span></div></div><p> </p><br><pre>



</pre></div><p><strong>19、Hive 案例分析</strong></p><p>　　这里我们以机顶盒产生的用户收视数据为例，来具体分析如何使用Hive。</p><p>　　1、机顶盒产生的用户原始数据都有一定的格式，包含机顶盒号、收看的频道、收看的节目、收看的时间等信息。</p><p>　　2、用户的原始数据通常不直接交给Hive处理，而是需要经过一个清洗和转化的过程。这个过程一般是通过Hadoop 作业来实现，转化成与Hive表对应的格式。</p><p> </p><p>这个案例的具体步骤如下：</p><p><strong>　　步骤1：用户数据预处理</strong></p><p>　　通过MapReduce作业将日志转化为固定的格式。</p><p>　　用户的原始数据如下所示。</p><div><pre>　　　　&lt; GHApp&gt;&lt; WIC cardNum="1370695139" stbNum="03111108020232488" date="2012-09-21" pageWidgetVersion="1.0"&gt;&lt; A e="13:55:11" s="13:50:10" n="104" t="1" pi="789" p="%E5%86%8D%E5%9B%9E%E9%A6%96(21)" sn="BTV影视" /&gt;&lt; /WIC&gt;&lt; /GHApp&gt;</pre></div><p>　　　　转化之后的数据如下所示，每个字段我们使用"@"分割符号。</p><div><pre>　　　　1370695139@03111108020232488@2012-09-21@BTV影视@再回首@13:50:10@13:55:11@301</pre></div><p>　　　　上面的字段分别代表：机顶盒号、用户编号、收看日期、频道、栏目、起始时间、结束时间、收视时长。</p><p> </p><p>　<strong>　步骤2：创建Hive表</strong></p><p>　　　　我们根据对应字段，使用Hive创建表。</p><div><div class="cnblogs_code"><pre>　　　　create table tvdata(cardnum string,stbnum string,date string,sn string,p string ,s string,e string,duration int) row format delimited fields terminated by '@' stored as textfile; </pre></div><p> </p></div><p><strong>　　</strong></p><p><strong>　　步骤3：将hdfs中的数据导入表中</strong></p><p>　　　　我们使用以下命令，将hdfs中的数据导入表中。</p><div><div class="cnblogs_code"><pre>　　　　load data inpath '/media/tvdata/part-r-00000' into table tvdata;</pre></div><p> </p><pre>
</pre></div><p><strong>　　步骤4：编写HQL，分析数据</strong></p><p>　　　　使用HQL语句，统计每个的频道的人均收视时长。</p><div><div class="cnblogs_code"><pre>　　　　select sn,sum(duration)/count(*) from tvdata group by sn;</pre></div></div><p>　　这里我们使用HQL只是从一个角度分析数据，大家可以尝试从多个角度来分析数据。</p>            </div>
                </div>