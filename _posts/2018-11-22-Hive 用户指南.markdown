---
layout:     post
title:      Hive 用户指南
---
<div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post">
								<div class="article-copyright">
					版权声明：本文为博主原创文章，未经博主允许不得转载。					https://blog.csdn.net/Rundy_Deng/article/details/76916656				</div>
								            <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f76675cdea.css">
						<div class="htmledit_views" id="content_views">
                
<p align="center"><strong></strong></p>
<p align="center"><strong> </strong></p>
<p align="center"><strong> </strong></p>
<p align="center"><strong> </strong></p>
<p align="center"><strong> </strong></p>
<p align="center"><strong> </strong></p>
<p align="center"><strong> </strong></p>
<p align="center"><strong>Hive <span style="font-family:宋体">用户指南 </span><span style="font-family:Times New Roman">v1.0</span></strong></p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p align="justify"><strong><span style="color:rgb(54,95,144)"> </span></strong></p>
<p> </p>
<p align="justify"><strong><span style="color:rgb(54,95,144)">目录</span></strong></p>
<p><a target="_blank" href="#_Toc280790998" rel="nofollow"><u><span style="color:rgb(0,0,255)">1.</span>
<span style="color:rgb(0,0,255)">HIVE</span><span style="color:rgb(0,0,255)"><span style="font-family:宋体">结构</span></span></u> 6</a></p>
<p><a target="_blank" href="#_Toc280790999" rel="nofollow"><u><span style="color:rgb(0,0,255)">1.1</span>
<span style="color:rgb(0,0,255)">HIVE</span><span style="color:rgb(0,0,255)"><span style="font-family:宋体">架构</span></span></u> 6</a></p>
<p><a target="_blank" href="#_Toc280791000" rel="nofollow"><u><span style="color:rgb(0,0,255)">1.2</span>
<span style="color:rgb(0,0,255)">Hive </span><span style="color:rgb(0,0,255)"><span style="font-family:宋体">和</span></span><span style="color:rgb(0,0,255)"> Hadoop
</span><span style="color:rgb(0,0,255)"><span style="font-family:宋体">关系</span></span></u> 7</a></p>
<p><a target="_blank" href="#_Toc280791001" rel="nofollow"><u><span style="color:rgb(0,0,255)">1.3</span>
<span style="color:rgb(0,0,255)">Hive </span><span style="color:rgb(0,0,255)"><span style="font-family:宋体">和普通关系数据库的异同</span></span></u> 8</a></p>
<p><a target="_blank" href="#_Toc280791002" rel="nofollow"><u><span style="color:rgb(0,0,255)">1.4</span>
<span style="color:rgb(0,0,255)">HIVE</span><span style="color:rgb(0,0,255)"><span style="font-family:宋体">元数据库</span></span></u> 9</a></p>
<p><a target="_blank" href="#_Toc280791003" rel="nofollow"><u><span style="color:rgb(0,0,255)">1.4.1</span>
<span style="color:rgb(0,0,255)">DERBY</span></u> 9</a></p>
<p><a target="_blank" href="#_Toc280791004" rel="nofollow"><u><span style="color:rgb(0,0,255)">1.4.2</span>
<span style="color:rgb(0,0,255)">Mysql</span></u> 10</a></p>
<p><a target="_blank" href="#_Toc280791005" rel="nofollow"><u><span style="color:rgb(0,0,255)">1.5</span>
<span style="color:rgb(0,0,255)">HIVE</span><span style="color:rgb(0,0,255)"><span style="font-family:宋体">的数据存储</span></span></u> 11</a></p>
<p><a target="_blank" href="#_Toc280791006" rel="nofollow"><u><span style="color:rgb(0,0,255)">1.6</span>
<span style="color:rgb(0,0,255)"><span style="font-family:宋体">其它</span></span><span style="color:rgb(0,0,255)">HIVE</span><span style="color:rgb(0,0,255)"><span style="font-family:宋体">操作</span></span></u> 11</a></p>
<p><a target="_blank" href="#_Toc280791007" rel="nofollow"><u><span style="color:rgb(0,0,255)">2.</span>
<span style="color:rgb(0,0,255)">HIVE </span><span style="color:rgb(0,0,255)"><span style="font-family:宋体">基本操作</span></span></u> 12</a></p>
<p><a target="_blank" href="#_Toc280791008" rel="nofollow"><u><span style="color:rgb(0,0,255)">2.1</span>
<span style="color:rgb(0,0,255)">create table</span></u> 12</a></p>
<p><a target="_blank" href="#_Toc280791009" rel="nofollow"><u><span style="color:rgb(0,0,255)">2.1.1</span>
<span style="color:rgb(0,0,255)"><span style="font-family:宋体">总述</span></span></u> 12</a></p>
<p><a target="_blank" href="#_Toc280791010" rel="nofollow"><u><span style="color:rgb(0,0,255)">2.1.2</span>
<span style="color:rgb(0,0,255)"><span style="font-family:宋体">语法</span></span></u> 12</a></p>
<p><a target="_blank" href="#_Toc280791011" rel="nofollow"><u><span style="color:rgb(0,0,255)">2.1.3</span>
<span style="color:rgb(0,0,255)"><span style="font-family:宋体">基本例子</span></span></u> 14</a></p>
<p><a target="_blank" href="#_Toc280791012" rel="nofollow"><u><span style="color:rgb(0,0,255)">2.1.4</span>
<span style="color:rgb(0,0,255)"><span style="font-family:宋体">创建分区</span></span></u> 15</a></p>
<p><a target="_blank" href="#_Toc280791013" rel="nofollow"><u><span style="color:rgb(0,0,255)">2.1.5</span>
<span style="color:rgb(0,0,255)"><span style="font-family:宋体">其它例子</span></span></u> 16</a></p>
<p><a target="_blank" href="#_Toc280791014" rel="nofollow"><u><span style="color:rgb(0,0,255)">2.2</span>
<span style="color:rgb(0,0,255)">Alter Table</span></u> 17</a></p>
<p><a target="_blank" href="#_Toc280791015" rel="nofollow"><u><span style="color:rgb(0,0,255)">2.2.1</span>
<span style="color:rgb(0,0,255)">Add Partitions</span></u> 17</a></p>
<p><a target="_blank" href="#_Toc280791016" rel="nofollow"><u><span style="color:rgb(0,0,255)">2.2.2</span>
<span style="color:rgb(0,0,255)">Drop Partitions</span></u> 17</a></p>
<p><a target="_blank" href="#_Toc280791017" rel="nofollow"><u><span style="color:rgb(0,0,255)">2.2.3</span>
<span style="color:rgb(0,0,255)">Rename Table</span></u> 17</a></p>
<p><a target="_blank" href="#_Toc280791018" rel="nofollow"><u><span style="color:rgb(0,0,255)">2.2.4</span>
<span style="color:rgb(0,0,255)">Change Column</span></u> 18</a></p>
<p><a target="_blank" href="#_Toc280791019" rel="nofollow"><u><span style="color:rgb(0,0,255)">2.2.5</span>
<span style="color:rgb(0,0,255)">Add/Replace Columns</span></u> 18</a></p>
<p><a target="_blank" href="#_Toc280791020" rel="nofollow"><u><span style="color:rgb(0,0,255)">2.3</span>
<span style="color:rgb(0,0,255)">Create View</span></u> 18</a></p>
<p><a target="_blank" href="#_Toc280791021" rel="nofollow"><u><span style="color:rgb(0,0,255)">2.4</span>
<span style="color:rgb(0,0,255)">Show</span></u> 19</a></p>
<p><a target="_blank" href="#_Toc280791022" rel="nofollow"><u><span style="color:rgb(0,0,255)">2.5</span>
<span style="color:rgb(0,0,255)">Load</span></u> 19</a></p>
<p><a target="_blank" href="#_Toc280791023" rel="nofollow"><u><span style="color:rgb(0,0,255)">2.6</span>
<span style="color:rgb(0,0,255)">Insert</span></u> 21</a></p>
<p><a target="_blank" href="#_Toc280791024" rel="nofollow"><u><span style="color:rgb(0,0,255)">2.6.1</span>
<span style="color:rgb(0,0,255)">Inserting data into Hive Tables from queries</span></u> 21</a></p>
<p><a target="_blank" href="#_Toc280791025" rel="nofollow"><u><span style="color:rgb(0,0,255)">2.6.2</span>
<span style="color:rgb(0,0,255)">Writing data into filesystem from queries</span></u> 21</a></p>
<p><a target="_blank" href="#_Toc280791026" rel="nofollow"><u><span style="color:rgb(0,0,255)">2.7</span>
<span style="color:rgb(0,0,255)">Cli</span></u> 22</a></p>
<p><a target="_blank" href="#_Toc280791027" rel="nofollow"><u><span style="color:rgb(0,0,255)">2.7.1</span>
<span style="color:rgb(0,0,255)">Hive Command line Options</span></u> 22</a></p>
<p><a target="_blank" href="#_Toc280791028" rel="nofollow"><u><span style="color:rgb(0,0,255)">2.7.2</span>
<span style="color:rgb(0,0,255)">Hive interactive Shell Command</span></u> 24</a></p>
<p><a target="_blank" href="#_Toc280791029" rel="nofollow"><u><span style="color:rgb(0,0,255)">2.7.3</span>
<span style="color:rgb(0,0,255)">Hive Resources</span></u> 24</a></p>
<p><a target="_blank" href="#_Toc280791030" rel="nofollow"><u><span style="color:rgb(0,0,255)">2.7.4</span>
<span style="color:rgb(0,0,255)"><span style="font-family:宋体">调用</span></span><span style="color:rgb(0,0,255)">python</span><span style="color:rgb(0,0,255)"><span style="font-family:宋体">、</span></span><span style="color:rgb(0,0,255)">shell</span><span style="color:rgb(0,0,255)"><span style="font-family:宋体">等语言</span></span></u>
 25</a></p>
<p><a target="_blank" href="#_Toc280791031" rel="nofollow"><u><span style="color:rgb(0,0,255)">2.8</span>
<span style="color:rgb(0,0,255)">DROP</span></u> 26</a></p>
<p><a target="_blank" href="#_Toc280791032" rel="nofollow"><u><span style="color:rgb(0,0,255)">2.9</span>
<span style="color:rgb(0,0,255)"><span style="font-family:宋体">其它</span></span></u> 27</a></p>
<p><a target="_blank" href="#_Toc280791033" rel="nofollow"><u><span style="color:rgb(0,0,255)">2.9.1</span>
<span style="color:rgb(0,0,255)">Limit</span></u> 27</a></p>
<p><a target="_blank" href="#_Toc280791034" rel="nofollow"><u><span style="color:rgb(0,0,255)">2.9.2</span>
<span style="color:rgb(0,0,255)">Top k</span></u> 27</a></p>
<p><a target="_blank" href="#_Toc280791035" rel="nofollow"><u><span style="color:rgb(0,0,255)">2.9.3</span>
<span style="color:rgb(0,0,255)">REGEX Column Specification</span></u> 27</a></p>
<p><a target="_blank" href="#_Toc280791036" rel="nofollow"><u><span style="color:rgb(0,0,255)">3.</span>
<span style="color:rgb(0,0,255)">Hive Select</span></u> 27</a></p>
<p><a target="_blank" href="#_Toc280791037" rel="nofollow"><u><span style="color:rgb(0,0,255)">3.1</span>
<span style="color:rgb(0,0,255)">Group By</span></u> 28</a></p>
<p><a target="_blank" href="#_Toc280791038" rel="nofollow"><u><span style="color:rgb(0,0,255)">3.2</span>
<span style="color:rgb(0,0,255)">Order /Sort By</span></u> 28</a></p>
<p><a target="_blank" href="#_Toc280791039" rel="nofollow"><u><span style="color:rgb(0,0,255)">4.</span>
<span style="color:rgb(0,0,255)">Hive Join</span></u> 29</a></p>
<p><a target="_blank" href="#_Toc280791040" rel="nofollow"><u><span style="color:rgb(0,0,255)">5.</span>
<span style="color:rgb(0,0,255)">HIVE</span><span style="color:rgb(0,0,255)"><span style="font-family:宋体">参数设置</span></span></u> 31</a></p>
<p><a target="_blank" href="#_Toc280791041" rel="nofollow"><u><span style="color:rgb(0,0,255)">6.</span>
<span style="color:rgb(0,0,255)">HIVE UDF</span></u> 33</a></p>
<p><a target="_blank" href="#_Toc280791042" rel="nofollow"><u><span style="color:rgb(0,0,255)">6.1</span>
<span style="color:rgb(0,0,255)"><span style="font-family:宋体">基本函数</span></span></u> 33</a></p>
<p><a target="_blank" href="#_Toc280791043" rel="nofollow"><u><span style="color:rgb(0,0,255)">6.1.1</span>
<span style="color:rgb(0,0,255)"><span style="font-family:宋体">关系操作符</span></span></u> 33</a></p>
<p><a target="_blank" href="#_Toc280791044" rel="nofollow"><u><span style="color:rgb(0,0,255)">6.1.2</span>
<span style="color:rgb(0,0,255)"><span style="font-family:宋体">代数操作符</span></span></u> 34</a></p>
<p><a target="_blank" href="#_Toc280791045" rel="nofollow"><u><span style="color:rgb(0,0,255)">6.1.3</span>
<span style="color:rgb(0,0,255)"><span style="font-family:宋体">逻辑操作符</span></span></u> 35</a></p>
<p><a target="_blank" href="#_Toc280791046" rel="nofollow"><u><span style="color:rgb(0,0,255)">6.1.4</span>
<span style="color:rgb(0,0,255)"><span style="font-family:宋体">复杂类型操作符</span></span></u> 35</a></p>
<p><a target="_blank" href="#_Toc280791047" rel="nofollow"><u><span style="color:rgb(0,0,255)">6.1.5</span>
<span style="color:rgb(0,0,255)"><span style="font-family:宋体">内建函数</span></span></u> 36</a></p>
<p><a target="_blank" href="#_Toc280791048" rel="nofollow"><u><span style="color:rgb(0,0,255)">6.1.6</span>
<span style="color:rgb(0,0,255)"><span style="font-family:宋体">数学函数</span></span></u> 36</a></p>
<p><a target="_blank" href="#_Toc280791049" rel="nofollow"><u><span style="color:rgb(0,0,255)">6.1.7</span>
<span style="color:rgb(0,0,255)"><span style="font-family:宋体">集合函数</span></span></u> 36</a></p>
<p><a target="_blank" href="#_Toc280791050" rel="nofollow"><u><span style="color:rgb(0,0,255)">6.1.8</span>
<span style="color:rgb(0,0,255)"><span style="font-family:宋体">类型转换</span></span></u> 36</a></p>
<p><a target="_blank" href="#_Toc280791051" rel="nofollow"><u><span style="color:rgb(0,0,255)">6.1.9</span>
<span style="color:rgb(0,0,255)"><span style="font-family:宋体">日期函数</span></span></u> 36</a></p>
<p><a target="_blank" href="#_Toc280791052" rel="nofollow"><u><span style="color:rgb(0,0,255)">6.1.10</span>
<span style="color:rgb(0,0,255)"><span style="font-family:宋体">条件函数</span></span></u> 37</a></p>
<p><a target="_blank" href="#_Toc280791053" rel="nofollow"><u><span style="color:rgb(0,0,255)">6.1.11</span>
<span style="color:rgb(0,0,255)"><span style="font-family:宋体">字符串函数</span></span></u> 37</a></p>
<p><a target="_blank" href="#_Toc280791054" rel="nofollow"><u><span style="color:rgb(0,0,255)">6.2</span>
<span style="color:rgb(0,0,255)">UDTF</span></u> 39</a></p>
<p><a target="_blank" href="#_Toc280791055" rel="nofollow"><u><span style="color:rgb(0,0,255)">6.2.1</span>
<span style="color:rgb(0,0,255)">Explode</span></u> 39</a></p>
<p><a target="_blank" href="#_Toc280791056" rel="nofollow"><u><span style="color:rgb(0,0,255)">7.</span>
<span style="color:rgb(0,0,255)">HIVE </span><span style="color:rgb(0,0,255)"><span style="font-family:宋体">的</span></span><span style="color:rgb(0,0,255)">MAP/REDUCE</span></u> 41</a></p>
<p><a target="_blank" href="#_Toc280791057" rel="nofollow"><u><span style="color:rgb(0,0,255)">7.1</span>
<span style="color:rgb(0,0,255)">JOIN</span></u> 41</a></p>
<p><a target="_blank" href="#_Toc280791058" rel="nofollow"><u><span style="color:rgb(0,0,255)">7.2</span>
<span style="color:rgb(0,0,255)">GROUP BY</span></u> 42</a></p>
<p><a target="_blank" href="#_Toc280791059" rel="nofollow"><u><span style="color:rgb(0,0,255)">7.3</span>
<span style="color:rgb(0,0,255)">DISTINCT</span></u> 42</a></p>
<p><a target="_blank" href="#_Toc280791060" rel="nofollow"><u><span style="color:rgb(0,0,255)">8.</span>
<span style="color:rgb(0,0,255)"><span style="font-family:宋体">使用</span></span><span style="color:rgb(0,0,255)">HIVE</span><span style="color:rgb(0,0,255)"><span style="font-family:宋体">注意点</span></span></u> 43</a></p>
<p><a target="_blank" href="#_Toc280791061" rel="nofollow"><u><span style="color:rgb(0,0,255)">8.1</span>
<span style="color:rgb(0,0,255)"><span style="font-family:宋体">字符集</span></span></u> 43</a></p>
<p><a target="_blank" href="#_Toc280791062" rel="nofollow"><u><span style="color:rgb(0,0,255)">8.2</span>
<span style="color:rgb(0,0,255)"><span style="font-family:宋体">压缩</span></span></u> 43</a></p>
<p><a target="_blank" href="#_Toc280791063" rel="nofollow"><u><span style="color:rgb(0,0,255)">8.3</span>
<span style="color:rgb(0,0,255)">count(distinct)</span></u> 43</a></p>
<p><a target="_blank" href="#_Toc280791064" rel="nofollow"><u><span style="color:rgb(0,0,255)">8.4</span>
<span style="color:rgb(0,0,255)">JOIN</span></u> 43</a></p>
<p><a target="_blank" href="#_Toc280791065" rel="nofollow"><u><span style="color:rgb(0,0,255)">8.5</span>
<span style="color:rgb(0,0,255)">DML</span><span style="color:rgb(0,0,255)"><span style="font-family:宋体">操作</span></span></u> 44</a></p>
<p><a target="_blank" href="#_Toc280791066" rel="nofollow"><u><span style="color:rgb(0,0,255)">8.6</span>
<span style="color:rgb(0,0,255)">HAVING</span></u> 44</a></p>
<p><a target="_blank" href="#_Toc280791067" rel="nofollow"><u><span style="color:rgb(0,0,255)">8.7</span>
<span style="color:rgb(0,0,255)"><span style="font-family:宋体">子查询</span></span></u> 44</a></p>
<p><a target="_blank" href="#_Toc280791068" rel="nofollow"><u><span style="color:rgb(0,0,255)">8.8</span>
<span style="color:rgb(0,0,255)">Join</span><span style="color:rgb(0,0,255)"><span style="font-family:宋体">中处理</span></span><span style="color:rgb(0,0,255)">null</span><span style="color:rgb(0,0,255)"><span style="font-family:宋体">值的语义区别</span></span></u> 44</a></p>
<p><a target="_blank" href="#_Toc280791069" rel="nofollow"><u><span style="color:rgb(0,0,255)">9.</span>
<span style="color:rgb(0,0,255)"><span style="font-family:宋体">优化与技巧</span></span></u> 47</a></p>
<p><a target="_blank" href="#_Toc280791070" rel="nofollow"><u><span style="color:rgb(0,0,255)">9.1</span>
<span style="color:rgb(0,0,255)"><span style="font-family:宋体">全排序</span></span></u> 47</a></p>
<p><a target="_blank" href="#_Toc280791071" rel="nofollow"><u><span style="color:rgb(0,0,255)">9.1.1</span>
<span style="color:rgb(0,0,255)"><span style="font-family:宋体">例</span></span><span style="color:rgb(0,0,255)">1</span></u> 48</a></p>
<p><a target="_blank" href="#_Toc280791072" rel="nofollow"><u><span style="color:rgb(0,0,255)">9.1.2</span>
<span style="color:rgb(0,0,255)"><span style="font-family:宋体">例</span></span><span style="color:rgb(0,0,255)">2</span></u> 51</a></p>
<p><a target="_blank" href="#_Toc280791073" rel="nofollow"><u><span style="color:rgb(0,0,255)">9.2</span>
<span style="color:rgb(0,0,255)"><span style="font-family:宋体">怎样做笛卡尔积</span></span></u> 54</a></p>
<p><a target="_blank" href="#_Toc280791074" rel="nofollow"><u><span style="color:rgb(0,0,255)">9.3</span>
<span style="color:rgb(0,0,255)"><span style="font-family:宋体">怎样写</span></span><span style="color:rgb(0,0,255)">exist/in</span><span style="color:rgb(0,0,255)"><span style="font-family:宋体">子句</span></span></u> 54</a></p>
<p><a target="_blank" href="#_Toc280791075" rel="nofollow"><u><span style="color:rgb(0,0,255)">9.4</span>
<span style="color:rgb(0,0,255)"><span style="font-family:宋体">怎样决定</span></span><span style="color:rgb(0,0,255)">reducer</span><span style="color:rgb(0,0,255)"><span style="font-family:宋体">个数</span></span></u> 55</a></p>
<p><a target="_blank" href="#_Toc280791076" rel="nofollow"><u><span style="color:rgb(0,0,255)">9.5</span>
<span style="color:rgb(0,0,255)"><span style="font-family:宋体">合并</span></span><span style="color:rgb(0,0,255)">MapReduce</span><span style="color:rgb(0,0,255)"><span style="font-family:宋体">操作</span></span></u> 55</a></p>
<p><a target="_blank" href="#_Toc280791077" rel="nofollow"><u><span style="color:rgb(0,0,255)">9.6</span></u>
<em><u><span style="color:rgb(0,0,255)">Bucket </span><span style="color:rgb(0,0,255)"><span style="font-family:宋体">与</span></span><span style="color:rgb(0,0,255)"> sampling</span></u></em> 56</a></p>
<p><a target="_blank" href="#_Toc280791078" rel="nofollow"><u><span style="color:rgb(0,0,255)">9.7</span>
<span style="color:rgb(0,0,255)">Partition</span></u> 57</a></p>
<p><a target="_blank" href="#_Toc280791079" rel="nofollow"><u><span style="color:rgb(0,0,255)">9.8</span>
<span style="color:rgb(0,0,255)">JOIN</span></u> 58</a></p>
<p><a target="_blank" href="#_Toc280791080" rel="nofollow"><u><span style="color:rgb(0,0,255)">9.8.1</span>
<span style="color:rgb(0,0,255)">JOIN</span><span style="color:rgb(0,0,255)"><span style="font-family:宋体">原则</span></span></u> 58</a></p>
<p><a target="_blank" href="#_Toc280791081" rel="nofollow"><u><span style="color:rgb(0,0,255)">9.8.2</span>
<span style="color:rgb(0,0,255)">Map Join</span></u> 58</a></p>
<p><a target="_blank" href="#_Toc280791082" rel="nofollow"><u><span style="color:rgb(0,0,255)">9.8.3</span>
<span style="color:rgb(0,0,255)"><span style="font-family:宋体">大表</span></span><span style="color:rgb(0,0,255)">Join</span><span style="color:rgb(0,0,255)"><span style="font-family:宋体">的数据偏斜</span></span></u> 60</a></p>
<p><a target="_blank" href="#_Toc280791083" rel="nofollow"><u><span style="color:rgb(0,0,255)">9.9</span>
<span style="color:rgb(0,0,255)"><span style="font-family:宋体">合并小文件</span></span></u> 62</a></p>
<p><a target="_blank" href="#_Toc280791084" rel="nofollow"><u><span style="color:rgb(0,0,255)">9.10</span>
<span style="color:rgb(0,0,255)">Group By</span></u> 62</a></p>
<p><a target="_blank" href="#_Toc280791085" rel="nofollow"><u><span style="color:rgb(0,0,255)">10.</span>
<span style="color:rgb(0,0,255)">HIVE FAQ</span><span style="color:rgb(0,0,255)"><span style="font-family:宋体">：</span></span></u> 62</a></p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<h1><a target="_blank" name="_Toc280790998"></a>1. <strong>HIVE<span style="font-family:宋体">结构</span></strong></h1>
<p>Hive 是建立在 Hadoop 上的数据仓库基础构架。它提供了一系列的工具，可以用来进行数据提取转化加载（ETL），这是一种可以存储、查询和分析存储在 Hadoop 中的大规模数据的机制。Hive 定义了简单的类 SQL 查询语言，称为 QL，它允许熟悉 SQL 的用户查询数据。同时，这个语言也允许熟悉 MapReduce 开发者的开发自定义的 mapper 和 reducer 来处理内建的 mapper 和 reducer 无法完成的复杂的分析工作。</p>
<h2><a target="_blank" name="_Toc280790999"></a>1.1 <strong>HIVE<span style="font-family:宋体">架构</span></strong></h2>
<p> </p>
<p>Hive 的结构可以分为以下几部分： </p>
<p>· <span style="font-family:宋体">用户接口：包括</span> CLI, Client, WUI </p>
<p>· <span style="font-family:宋体">元数据存储。通常是存储在关系数据库如</span> mysql, derby 中 </p>
<p>· <span style="font-family:宋体">解释器、编译器、优化器、执行器</span> </p>
<p>· Hadoop：用 HDFS 进行存储，利用 MapReduce 进行计算 </p>
<p>1、 <span style="font-family:宋体">用户接口主要有三个：</span>CLI，Client 和 WUI。其中最常用的是 CLI，Cli 启动的时候，会同时启动一个 Hive 副本。Client 是 Hive 的客户端，用户连接至 Hive Server。在启动 Client 模式的时候，需要指出 Hive Server 所在节点，并且在该节点启动 Hive Server。 WUI 是通过浏览器访问 Hive。
</p>
<p>2、 Hive 将元数据存储在数据库中，如 mysql、derby。Hive 中的元数据包括表的名字，表的列和分区及其属性，表的属性（是否为外部表等），表的数据所在目录等。
</p>
<p>3、 <span style="font-family:宋体">解释器、编译器、优化器完成</span> HQL 查询语句从词法分析、语法分析、编译、优化以及查询计划的生成。生成的查询计划存储在 HDFS 中，并在随后有 MapReduce 调用执行。
</p>
<p>4、 Hive 的数据存储在 HDFS 中，大部分的查询由 MapReduce 完成（包含 * 的查询，比如 select * from tbl 不会生成 MapRedcue 任务）。 </p>
<h2><a target="_blank" name="_Toc280791000"></a>1.2 <strong>Hive <span style="font-family:宋体">
和 </span><span style="font-family:Times New Roman">Hadoop </span><span style="font-family:宋体">关系</span> </strong></h2>
<p> </p>
<p>Hive 构建在 Hadoop 之上， </p>
<p>· HQL 中对查询语句的解释、优化、生成查询计划是由 Hive 完成的 </p>
<p>· <span style="font-family:宋体">所有的数据都是存储在</span> Hadoop 中 </p>
<p>· <span style="font-family:宋体">查询计划被转化为</span> MapReduce 任务，在 Hadoop 中执行（有些查询没有 MR 任务，如：select * from table）
</p>
<p>· Hadoop和Hive都是用UTF-8编码的</p>
<p> </p>
<h2><a target="_blank" name="_Toc280791001"></a>1.3 <strong>Hive <span style="font-family:宋体">
和普通关系数据库的异同</span> </strong></h2>
<table>
<tbody>
<tr>
<td valign="center" style="background:rgb(60,179,113)">
<p> </p>
</td>
<td valign="center" style="background:rgb(60,179,113)">
<p>Hive </p>
</td>
<td valign="center" style="background:rgb(60,179,113)">
<p>RDBMS </p>
</td>
</tr>
<tr>
<td valign="center" style="background:rgb(60,179,113)">
<p>查询语言 </p>
</td>
<td valign="center" style="background:rgb(240,255,240)">
<p>HQL </p>
</td>
<td valign="center" style="background:rgb(240,255,240)">
<p>SQL </p>
</td>
</tr>
<tr>
<td valign="center" style="background:rgb(60,179,113)">
<p>数据存储 </p>
</td>
<td valign="center" style="background:rgb(245,245,245)">
<p>HDFS </p>
</td>
<td valign="center" style="background:rgb(245,245,245)">
<p>Raw Device or Local FS </p>
</td>
</tr>
<tr>
<td valign="center" style="background:rgb(60,179,113)">
<p>索引 </p>
</td>
<td valign="center" style="background:rgb(240,255,240)">
<p>无 </p>
</td>
<td valign="center" style="background:rgb(240,255,240)">
<p>有 </p>
</td>
</tr>
<tr>
<td valign="center" style="background:rgb(60,179,113)">
<p>执行 </p>
</td>
<td valign="center" style="background:rgb(245,245,245)">
<p>MapReduce </p>
</td>
<td valign="center" style="background:rgb(245,245,245)">
<p>Excutor </p>
</td>
</tr>
<tr>
<td valign="center" style="background:rgb(60,179,113)">
<p>执行延迟 </p>
</td>
<td valign="center" style="background:rgb(240,255,240)">
<p>高 </p>
</td>
<td valign="center" style="background:rgb(240,255,240)">
<p>低 </p>
</td>
</tr>
<tr>
<td valign="center" style="background:rgb(60,179,113)">
<p>处理数据规模 </p>
</td>
<td valign="center" style="background:rgb(245,245,245)">
<p>大 </p>
</td>
<td valign="center" style="background:rgb(245,245,245)">
<p>小 </p>
</td>
</tr>
</tbody>
</table>
<p>1. <span style="font-family:宋体">查询语言。由于</span> SQL 被广泛的应用在数据仓库中，因此，专门针对 Hive 的特性设计了类 SQL 的查询语言 HQL。熟悉 SQL 开发的开发者可以很方便的使用 Hive 进行开发。
</p>
<p>2. <span style="font-family:宋体">数据存储位置。</span>Hive 是建立在 Hadoop 之上的，所有 Hive 的数据都是存储在 HDFS 中的。而数据库则可以将数据保存在块设备或者本地文件系统中。
</p>
<p>3. <span style="font-family:宋体">数据格式。</span>Hive 中没有定义专门的数据格式，数据格式可以由用户指定，用户定义数据格式需要指定三个属性：列分隔符（通常为空格、”\t”、”\x001″）、行分隔符（”\n”）以及读取文件数据的方法（Hive 中默认有三个文件格式 TextFile，SequenceFile 以及 RCFile）。由于在加载数据的过程中，不需要从用户数据格式到 Hive 定义的数据格式的转换，因此，Hive 在加载的过程中不会对数据本身进行任何修改，而只是将数据内容复制或者移动到相应的
 HDFS 目录中。而在数据库中，不同的数据库有不同的存储引擎，定义了自己的数据格式。所有数据都会按照一定的组织存储，因此，数据库加载数据的过程会比较耗时。 </p>
<p>4. <span style="font-family:宋体">数据更新。由于</span> Hive 是针对数据仓库应用设计的，而数据仓库的内容是<span style="color:rgb(255,0,0)">读多写少的</span>。因此，<strong><span style="color:rgb(255,0,0)">Hive 中不支持对数据的改写和添加</span></strong><span style="font-family:宋体">，所有的数据都是在加载的时候中确定好的。而数据库中的数据通常是需要经常进行修改的，因此可以使用</span>
 INSERT INTO ...  VALUES 添加数据，使用 UPDATE ... SET 修改数据。 </p>
<p>5. <span style="font-family:宋体">索引。之前已经说过，</span>Hive 在加载数据的过程中不会对数据进行任何处理，甚至不会对数据进行扫描，因此也没有对数据中的某些 Key 建立索引。Hive 要访问数据中满足条件的特定值时，需要暴力扫描整个数据，因此访问延迟较高。由于 MapReduce 的引入， Hive 可以并行访问数据，因此即使没有索引，对于大数据量的访问，Hive 仍然可以体现出优势。数据库中，通常会针对一个或者几个列建立索引，因此对于少量的特定条件的数据的访问，数据库可以有很高的效率，较低的延迟。由于数据的访问延迟较高，决定了
 Hive 不适合在线数据查询。 </p>
<p>6. <span style="font-family:宋体">执行。</span>Hive 中大多数查询的执行是通过 Hadoop 提供的 MapReduce 来实现的（类似 select * from tbl 的查询不需要 MapReduce）。而数据库通常有自己的执行引擎。
</p>
<p>7. <span style="font-family:宋体">执行延迟。之前提到，</span>Hive 在查询数据的时候，由于没有索引，需要扫描整个表，因此延迟较高。另外一个导致 Hive 执行延迟高的因素是 MapReduce 框架。<strong><span style="color:rgb(255,0,0)"><span style="font-family:宋体">由于</span> MapReduce 本身具有较高的延迟</span></strong><span style="font-family:宋体">，因此在利用</span>
 MapReduce 执行 Hive 查询时，也会有较高的延迟。相对的，数据库的执行延迟较低。当然，这个低是有条件的，即数据规模较小，<strong><span style="color:rgb(255,0,0)"><span style="font-family:宋体">当数据规模大到超过数据库的处理能力的时候，</span>Hive 的并行计算显然能体现出优势。
</span></strong></p>
<p>8. <span style="font-family:宋体">可扩展性。由于</span> Hive 是建立在 Hadoop 之上的，因此 Hive 的可扩展性是和 Hadoop 的可扩展性是一致的（世界上最大的 Hadoop 集群在 Yahoo!，2009年的规模在 4000 台节点左右）。而数据库由于 ACID 语义的严格限制，扩展行非常有限。目前最先进的并行数据库 Oracle 在理论上的扩展能力也只有 100 台左右。
</p>
<p>9. <span style="font-family:宋体">数据规模。由于</span> Hive 建立在集群上并可以利用 MapReduce 进行并行计算，因此可以支持很大规模的数据；对应的，数据库可以支持的数据规模较小。 </p>
<h2><a target="_blank" name="_Toc280791002"></a>1.4 <strong>HIVE<span style="font-family:宋体">元数据库</span></strong></h2>
<p>Hive 将元数据存储在 RDBMS 中,一般常用的有MYSQL和DERBY。</p>
<h3><a target="_blank" name="_Toc280791003"></a>1.4.1 <strong>DERBY</strong></h3>
<p><span style="font-family:宋体">启动</span>HIVE的元数据库</p>
<p><span style="font-family:宋体">进入到</span>hive的安装目录</p>
<p>Eg:</p>
<p>1、启动derby数据库</p>
<p>/home/admin/caona/hive/build/dist/</p>
<p><span style="font-family:宋体">运行</span>startNetworkServer -h 0.0.0.0</p>
<p> </p>
<p>2、连接Derby数据库进行测试</p>
<p><span style="font-family:宋体">查看</span>/home/admin/caona/hive/build/dist/conf/hive-default.xml。</p>
<p><span style="font-family:宋体">找到</span>&lt;property&gt;</p>
<p>    &lt;name&gt;javax.jdo.option.ConnectionURL&lt;/name&gt;</p>
<p>    &lt;value&gt;jdbc:derby://hadoop1:1527/metastore_db;create=true&lt;/value&gt;</p>
<p>    &lt;description&gt;JDBC connect string for a JDBC metastore&lt;/description&gt;</p>
<p>  &lt;/property&gt;</p>
<p><span style="font-family:宋体">进入</span>derby安装目录</p>
<p>/home/admin/caona/hive/build/dist/db-derby-10.4.1.3-bin/bin</p>
<p><span style="font-family:宋体">输入</span>./ij</p>
<p>Connect 'jdbc:derby://hadoop1:1527/metastore_db;create=true';</p>
<p> </p>
<p>3、元数据库数据字典</p>
<table>
<tbody>
<tr>
<td valign="top">
<p>表名</p>
</td>
<td valign="top">
<p>说明</p>
</td>
<td valign="top">
<p>关联键</p>
</td>
</tr>
<tr>
<td valign="center">
<p>BUCKETING_COLS         </p>
</td>
<td valign="center">
<p>　</p>
</td>
<td valign="center">
<p>　</p>
</td>
</tr>
<tr>
<td valign="center">
<p>    COLUMNS            </p>
</td>
<td valign="center">
<p>Hive表字段信息(字段注释，字段名，字段类型，字段序号)</p>
</td>
<td valign="center">
<p>SD_ID</p>
</td>
</tr>
<tr>
<td valign="center">
<p>DBS</p>
</td>
<td valign="center">
<p>　元数据库信息，存放HDFS路径信息</p>
</td>
<td valign="center">
<p>DB_ID</p>
</td>
</tr>
<tr>
<td valign="center">
<p>PARTITION_KEYS         </p>
</td>
<td valign="center">
<p>Hive分区表分区键</p>
</td>
<td valign="center">
<p>PART_ID</p>
</td>
</tr>
<tr>
<td valign="center">
<p>SDS                    </p>
</td>
<td valign="center">
<p>所有hive表、表分区所对应的hdfs数据目录和数据格式。</p>
</td>
<td valign="center">
<p>SD_ID,SERDE_ID</p>
</td>
</tr>
<tr>
<td valign="center">
<p>SD_PARAMS              </p>
</td>
<td valign="center">
<p>序列化反序列化信息，如行分隔符、列分隔符、NULL的表示字符等</p>
</td>
<td valign="center">
<p>SERDE_ID</p>
</td>
</tr>
<tr>
<td valign="center">
<p>SEQUENCE_TABLE         </p>
</td>
<td valign="center">
<p>SEQUENCE_TABLE表保存了hive对象的下一个可用ID，如’org.apache.hadoop.hive.metastore.model.MTable’, 21，则下一个新创建的hive表其TBL_ID就是21，同时SEQUENCE_TABLE表中271786被更新为26(这里每次都是+5?)。同样，COLUMN，PARTITION等都有相应的记录</p>
</td>
<td valign="center">
<p>　</p>
</td>
</tr>
<tr>
<td valign="center">
<p>SERDES                 </p>
</td>
<td valign="center">
<p>　</p>
</td>
<td valign="center">
<p>　</p>
</td>
</tr>
<tr>
<td valign="center">
<p>SERDE_PARAMS           </p>
</td>
<td valign="center">
<p>　</p>
</td>
<td valign="center">
<p>　</p>
</td>
</tr>
<tr>
<td valign="center">
<p>SORT_COLS              </p>
</td>
<td valign="center">
<p>　</p>
</td>
<td valign="center">
<p>　</p>
</td>
</tr>
<tr>
<td valign="center">
<p>TABLE_PARAMS           </p>
</td>
<td valign="center">
<p>表级属性，如是否外部表，表注释等</p>
</td>
<td valign="center">
<p>TBL_ID</p>
</td>
</tr>
<tr>
<td valign="center">
<p>TBLS                   </p>
</td>
<td valign="center">
<p>所有hive表的基本信息</p>
</td>
<td valign="center">
<p>TBL_ID,SD_ID</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p><span style="font-family:宋体">从上面几张表的内容来看，</span>hive整个创建表的过程已经比较清楚了</p>
<p>1. <span style="font-family:宋体">解析用户提交</span>hive语句，对其进行解析，分解为表、字段、分区等hive对象 </p>
<p>2. <span style="font-family:宋体">根据解析到的信息构建对应的表、字段、分区等对象，从</span>SEQUENCE_TABLE中获取构建对象的最新ID，与构建对象信息(名称，类型等)一同通过DAO方法写入到元数据表中去，成功后将SEQUENCE_TABLE中对应的最新ID+5。
</p>
<p><span style="font-family:宋体">实际上我们常见的</span>RDBMS都是通过这种方法进行组织的，典型的如postgresql，其系统表中和hive元数据一样裸露了这些id信息(oid,cid等),而Oracle等商业化的系统则隐藏了这些具体的ID。通过这些元数据我们可以很容易的读到数据诸如创建一个表的数据字典信息，比如导出建表语名等。</p>
<p><span style="background:rgb(255,255,0)"><span style="font-family:宋体">导出建表语句的</span>shell脚本见</span><em><span style="background:rgb(255,255,0)"><span style="font-family:宋体">附一</span></span> <span style="font-family:宋体">待完成</span></em></p>
<h3><a target="_blank" name="_Toc280791004"></a>1.4.2 <strong>Mysql</strong></h3>
<p><span style="font-family:宋体">将存放元数据的</span>Derby数据库迁移到Mysql数据库</p>
<p>步骤：</p>
<p> </p>
<h2><a target="_blank" name="_Toc280791005"></a>1.5 <strong>HIVE<span style="font-family:宋体">的数据存储</span></strong></h2>
<p>    <span style="font-family:宋体">首先，</span>Hive <span style="font-family:宋体">没有专门的数据存储格式，也没有为数据建立索引，用户可以非常自由的组织</span> Hive
<span style="font-family:宋体">中的表，只需要在创建表的时候告诉</span> Hive <span style="font-family:宋体">
数据中的列分隔符和行分隔符，</span>Hive <span style="font-family:宋体">就可以解析数据。</span></p>
<p><span style="font-family:宋体">其次，</span>Hive <span style="font-family:宋体">中所有的数据都存储在</span> HDFS
<span style="font-family:宋体">中，</span><strong><span style="color:rgb(255,0,0)">Hive
</span><span style="color:rgb(255,0,0)"><span style="font-family:宋体">中包含以下数据模型：</span></span><span style="color:rgb(255,0,0)">Table</span><span style="color:rgb(255,0,0)"><span style="font-family:宋体">，</span></span><span style="color:rgb(255,0,0)">External
 Table</span><span style="color:rgb(255,0,0)"><span style="font-family:宋体">，</span></span><span style="color:rgb(255,0,0)">Partition</span><span style="color:rgb(255,0,0)"><span style="font-family:宋体">，</span></span><span style="color:rgb(255,0,0)">Bucket</span><span style="color:rgb(255,0,0)"><span style="font-family:宋体">。</span></span></strong></p>
<p>1. Hive <span style="font-family:宋体">中的</span> Table <span style="font-family:宋体">
和数据库中的</span> Table <span style="font-family:宋体">在概念上是类似的，每一个</span> Table <span style="font-family:宋体">
在</span> Hive <span style="font-family:宋体">中都有一个相应的目录存储数据。例如，</span><strong><span style="color:rgb(255,0,0)"><span style="font-family:宋体">一个表</span></span><span style="color:rgb(255,0,0)"> </span><span style="color:rgb(255,0,0)">htduan</span><span style="color:rgb(255,0,0)"><span style="font-family:宋体">，它在</span></span><span style="color:rgb(255,0,0)"> HDFS
</span><span style="color:rgb(255,0,0)"><span style="font-family:宋体">中的路径为：</span></span><span style="color:rgb(255,0,0)">/</span><span style="color:rgb(255,0,0)"> </span><span style="color:rgb(255,0,0)">warehouse /</span><span style="color:rgb(255,0,0)">htduan</span></strong><span style="font-family:宋体">，其中，</span>wh
<span style="font-family:宋体">是在</span> hive-site.xml <span style="font-family:宋体">
中由</span> ${hive.metastore.warehouse.dir} <span style="font-family:宋体">指定的数据仓库的目录，所有的</span> Table
<span style="font-family:宋体">数据（不包括</span> External Table<span style="font-family:宋体">）都保存在这个目录中。</span> </p>
<p>2. Partition <span style="font-family:宋体">对应于数据库中的</span> Partition <span style="font-family:宋体">
列的密集索引，但是</span> Hive <span style="font-family:宋体">中</span> Partition <span style="font-family:宋体">
的组织方式和数据库中的很不相同。在</span> Hive <span style="font-family:宋体">中，表中的一个</span> Partition
<span style="font-family:宋体">对应于表下的一个目录，所有的</span> Partition <span style="font-family:宋体">
的数据都存储在对应的目录中。例如：</span>htduan <span style="font-family:宋体">表中包含</span> dt <span style="font-family:宋体">和</span> city
<span style="font-family:宋体">两个</span> Partition<span style="font-family:宋体">，则对应于</span> dt = 20100801, ctry = US
<span style="font-family:宋体">的</span> HDFS <span style="font-family:宋体">子目录为：</span>/ warehouse /htduan/dt=20100801/ctry=US<span style="font-family:宋体">；对应于</span> dt = 20100801, ctry = CA
<span style="font-family:宋体">的</span> HDFS <span style="font-family:宋体">子目录为；</span>/ warehouse /htduan/dt=20100801/ctry=CA
</p>
<p>3. Buckets <span style="font-family:宋体">对指定列计算</span> hash<span style="font-family:宋体">，根据</span> hash
<span style="font-family:宋体">值切分数据，目的是为了并行，每一个</span> Bucket <span style="font-family:宋体">
对应一个文件。将</span> user <span style="font-family:宋体">列分散至</span> 32 <span style="font-family:宋体">
个</span> bucket<span style="font-family:宋体">，首先对</span> user <span style="font-family:宋体">
列的值计算</span> hash<span style="font-family:宋体">，对应</span> hash <span style="font-family:宋体">
值为</span> 0 <span style="font-family:宋体">的</span> HDFS <span style="font-family:宋体">
目录为：</span>/ warehouse /htduan/dt =20100801/ctry=US/part-00000<span style="font-family:宋体">；</span>hash
<span style="font-family:宋体">值为</span> 20 <span style="font-family:宋体">的</span> HDFS
<span style="font-family:宋体">目录为：</span>/ warehouse /htduan/dt =20100801/ctry=US/part-00020
</p>
<p>4. External Table <span style="font-family:宋体">指向已经在</span> HDFS <span style="font-family:宋体">
中存在的数据，可以创建</span> Partition<span style="font-family:宋体">。它和</span> Table <span style="font-family:宋体">
在元数据的组织上是相同的，而实际数据的存储则有较大的差异。</span> </p>
<p>· Table <span style="font-family:宋体">的创建过程和数据加载过程（这两个过程可以在同一个语句中完成），在加载数据的过程中，实际数据会被移动到数据仓库目录中；之后对数据对访问将会直接在数据仓库目录中完成。删除表时，表中的数据和元数据将会被同时删除。</span> </p>
<p>· External Table <span style="font-family:宋体">只有一个过程，加载数据和创建表同时完成（</span>CREATE EXTERNAL TABLE ……LOCATION<span style="font-family:宋体">），实际数据是存储在</span> LOCATION
<span style="font-family:宋体">后面指定的</span> HDFS <span style="font-family:宋体">路径中，并不会移动到数据仓库目录中。当删除一个</span> External Table
<span style="font-family:宋体">时，仅删除</span> </p>
<p> </p>
<h2><a target="_blank" name="_Toc280791006"></a>1.6 <strong><span style="font-family:宋体">其它</span>HIVE<span style="font-family:宋体">操作</span></strong></h2>
<p> </p>
<p>1、 <span style="font-family:宋体">启动</span>HIVE的WEB的界面</p>
<p><span style="color:rgb(51,51,51)">sh $HIVE_HOME/bin/hive --service hwi</span></p>
<p><span style="color:rgb(51,51,51)"> </span></p>
<p>2、查看HDFS上的文件数据</p>
<p>hadoop fs -text /user/admin/daiqf/createspu_fp/input/cateinfo |head</p>
<h1><a target="_blank" name="_Toc280791007"></a>2. <strong>HIVE <span style="font-family:宋体">
基本操作</span></strong></h1>
<h2><a target="_blank" name="_Toc280791008"></a>2.1 <strong>create table</strong></h2>
<h3><a target="_blank" name="_Toc280791009"></a>2.1.1 <strong>总述</strong></h3>
<p>l CREATE TABLE 创建一个指定名字的表。如果相同名字的表已经存在，则抛出异常；用户可以用 IF NOT EXIST 选项来忽略这个异常。</p>
<p>l EXTERNAL 关键字可以让用户<span style="color:rgb(255,0,0)"><span style="font-family:宋体">创建一个外部表，在建表的同时指定一个指向实际数据的路径（</span>LOCATION）</span><span style="font-family:宋体">，</span>Hive
<span style="color:rgb(255,0,0)">创建内部表时，会将数据移动到数据仓库指向的路径；若创建外部表，仅记录数据所在的路径，不对数据的位置做任何改变。在删除表的时候，内部表的元数据和数据会被一起删除，而外部表只删除元数据，不删除数据。</span></p>
<p>l LIKE 允许用户复制现有的表结构，但是不复制数据。</p>
<p>l <span style="font-family:宋体">用户在建表的时候可以自定义</span> SerDe 或者使用自带的 SerDe。如果没有指定 ROW FORMAT 或者 ROW FORMAT DELIMITED，将会使用自带的 SerDe。在建表的时候，用户还需要为表指定列，用户在指定表的列的同时也会指定自定义的 SerDe，Hive 通过 SerDe 确定表的具体的列的数据。</p>
<p>l <span style="font-family:宋体">如果文件数据是纯文本，可以使用</span> STORED AS TEXTFILE。如果数据需要压缩，使用 STORED AS SEQUENCE 。</p>
<p>l <span style="font-family:宋体">有分区的表可以在创建的时候使用</span> PARTITIONED BY 语句。一个表可以拥有一个或者多个分区，每一个分区单独存在一个目录下。而且，表和分区都可以对某个列进行 CLUSTERED BY 操作，将若干个列放入一个桶（bucket）中。也可以利用SORT BY 对数据进行排序。这样可以为特定应用提高性能。</p>
<p>l <span style="font-family:宋体">表名和列名不区分大小写，</span>SerDe 和属性名区分大小写。表和列的注释是字符串。</p>
<h3><a target="_blank" name="_Toc280791010"></a>2.1.2 <strong>语法</strong></h3>
<p style="background:rgb(243,245,247)">CREATE [EXTERNAL] TABLE [IF NOT EXISTS] table_name</p>
<p style="background:rgb(243,245,247)">  [(col_name data_type [COMMENT col_comment], ...)]</p>
<p style="background:rgb(243,245,247)">  [COMMENT table_comment]</p>
<p style="background:rgb(243,245,247)">  [PARTITIONED BY (col_name data_type [COMMENT col_comment], ...)]</p>
<p style="background:rgb(243,245,247)">  [CLUSTERED BY (col_name, col_name, ...) [SORTED BY (col_name [ASC|DESC], ...)] INTO num_buckets BUCKETS]</p>
<p style="background:rgb(243,245,247)">  [</p>
<p style="background:rgb(243,245,247)">   [ROW FORMAT row_format] [STORED AS file_format]</p>
<p style="background:rgb(243,245,247)">   | STORED BY 'storage.handler.class.name' [ WITH SERDEPROPERTIES (...) ]  (Note:  only available starting with 0.6.0)</p>
<p style="background:rgb(243,245,247)">  ]</p>
<p style="background:rgb(243,245,247)">  [LOCATION hdfs_path]</p>
<p style="background:rgb(243,245,247)">  [TBLPROPERTIES (property_name=property_value, ...)]  (Note:  only available starting with 0.6.0)</p>
<p style="background:rgb(243,245,247)">  [AS select_statement]  (Note: this feature is only available starting with 0.5.0.)</p>
<p style="background:rgb(243,245,247)"> </p>
<p style="background:rgb(243,245,247)">CREATE [EXTERNAL] TABLE [IF NOT EXISTS] table_name</p>
<p style="background:rgb(243,245,247)">  LIKE existing_table_name</p>
<p style="background:rgb(243,245,247)">  [LOCATION hdfs_path]</p>
<p style="background:rgb(243,245,247)"> </p>
<p style="background:rgb(243,245,247)">data_type</p>
<p style="background:rgb(243,245,247)">  : primitive_type</p>
<p style="background:rgb(243,245,247)">  | array_type</p>
<p style="background:rgb(243,245,247)">  | map_type</p>
<p style="background:rgb(243,245,247)">  | struct_type</p>
<p style="background:rgb(243,245,247)"> </p>
<p style="background:rgb(243,245,247)">primitive_type</p>
<p style="background:rgb(243,245,247)">  : TINYINT</p>
<p style="background:rgb(243,245,247)">  | SMALLINT</p>
<p style="background:rgb(243,245,247)">  | INT</p>
<p style="background:rgb(243,245,247)">  | BIGINT</p>
<p style="background:rgb(243,245,247)">  | BOOLEAN</p>
<p style="background:rgb(243,245,247)">  | FLOAT</p>
<p style="background:rgb(243,245,247)">  | DOUBLE</p>
<p style="background:rgb(243,245,247)">  | STRING</p>
<p style="background:rgb(243,245,247)"> </p>
<p style="background:rgb(243,245,247)">array_type</p>
<p style="background:rgb(243,245,247)">  : ARRAY &lt; data_type &gt;</p>
<p style="background:rgb(243,245,247)"> </p>
<p style="background:rgb(243,245,247)">map_type</p>
<p style="background:rgb(243,245,247)">  : MAP &lt; primitive_type, data_type &gt;</p>
<p style="background:rgb(243,245,247)"> </p>
<p style="background:rgb(243,245,247)">struct_type</p>
<p style="background:rgb(243,245,247)">  : STRUCT &lt; col_name : data_type [COMMENT col_comment], ...&gt;</p>
<p style="background:rgb(243,245,247)"> </p>
<p style="background:rgb(243,245,247)">row_format</p>
<p style="background:rgb(243,245,247)">  : DELIMITED [FIELDS TERMINATED BY char] [COLLECTION ITEMS TERMINATED BY char]</p>
<p style="background:rgb(243,245,247)">        [MAP KEYS TERMINATED BY char] [LINES TERMINATED BY char]</p>
<p style="background:rgb(243,245,247)">  | SERDE serde_name [WITH SERDEPROPERTIES (property_name=property_value, property_name=property_value, ...)]</p>
<p style="background:rgb(243,245,247)"> </p>
<p style="background:rgb(243,245,247)">file_format:</p>
<p style="background:rgb(243,245,247)">  : SEQUENCEFILE</p>
<p style="background:rgb(243,245,247)">  | TEXTFILE</p>
<p style="background:rgb(243,245,247)">  | RCFILE     (Note:  only available starting with 0.6.0)</p>
<p style="background:rgb(243,245,247)">  | INPUTFORMAT input_format_classname OUTPUTFORMAT output_format_classname<a target="_blank" name="_Toc280791011"></a></p>
<p style="background:rgb(243,245,247)"> </p>
<p> </p>
<p><span style="font-family:宋体">目前在</span>hive中常用的数据类型有:</p>
<p>   BIGINT – 主要用于状态,类别,数量的字段, 如status/option/type/quantity</p>
<p>   DOUBLE – 主要用于金额的字段, 如fee/price/bid</p>
<p>   STRING – 除上述之外的字段基本都使用String, 尤其是id和日期时间这样的字段</p>
<p> </p>
<h3>2.1.3 <strong><span style="font-family:宋体">基本例子</span></strong></h3>
<p>1、如果一个表已经存在，可以使用if not exists</p>
<p>2、 create table htduan(id int,cont string) row format delimited fields terminated by '\005' stored as textfile;</p>
<p>terminated by：关于来源的文本数据的字段间隔符</p>
<p><span style="font-family:宋体">如果要将自定义间隔符的文件读入一个表，需要通过创建表的语句来指明输入文件间隔符，然后</span>load data到这个表。</p>
<p>4、Alibaba数据库常用间隔符的读取</p>
<p><span style="font-family:宋体">我们的常用间隔符一般是</span>Ascii码5，Ascii码7等。在hive中Ascii码5用’\005’表示， Ascii码7用’\007’表示，依此类推。</p>
<p>5、装载数据</p>
<p><span style="font-family:宋体">查看一下：</span>Hadoop fs -ls</p>
<p>LOAD DATA INPATH '/user/admin/htduan/a.txt' OVERWRITE INTO TABLE htduan;</p>
<p>6、如果使用external建表和普通建表区别</p>
<p>A、指定一个位置，而不使用默认的位置。如：</p>
<p>create  EXTERNAL  table htduan(id int,cont string) row format delimited fields terminated by '\005' stored as textfile location '/user/admin/htduan/';</p>
<p>--------------check结果</p>
<p>ij&gt; select LOCATION from tbls a,sds b where a.sd_id=b.sd_id and tbl_name='htduan';  </p>
<p>-----</p>
<p>LOCATION                                                                                                                        </p>
<p>--------------------------------------------------------------------------------------------------------------------------------</p>
<p>hdfs://hadoop1:7000/user/admin/htduan   </p>
<p> </p>
<p>ij&gt; select LOCATION from tbls a,sds b where a.sd_id=b.sd_id and tbl_name='c';</p>
<p>----</p>
<p>LOCATION                                                                                                                        </p>
<p>--------------------------------------------------------------------------------------------------------------------------------</p>
<p>hdfs://hadoop1:7000/user/hive/warehouse/c</p>
<p>B、对于使用create table external建表完成后，再drop掉表，表中的数据还在文件系统中。</p>
<p>如：</p>
<p>hive&gt; create  EXTERNAL  table htduan(id int,cont string) row format delimited fields terminated by '\005' stored as textfile;</p>
<p>----</p>
<p>OK</p>
<p> </p>
<p>hive&gt; LOAD DATA INPATH '/user/admin/htduan' OVERWRITE INTO TABLE htduan;</p>
<p>--------------------------------------------------</p>
<p>Loading data to table htduan</p>
<p>OK</p>
<p> </p>
<p>hive&gt; drop table htduan;</p>
<p>----</p>
<p>OK</p>
<p> </p>
<p>[admin@hadoop1 bin]$ ./hadoop fs -ls hdfs://hadoop1:7000/user/hive/warehouse/htduan
</p>
<p>Found 1 items</p>
<p><span style="font-family:宋体">使用普通的建表</span>DROP后则找不到</p>
<h3><a target="_blank" name="_Toc280791012"></a>2.1.4 <strong>创建分区</strong></h3>
<p>   HIVE的分区通过在创建表时启用partition by实现，用来partition的维度并不是实际数据的某一列，具体分区的标志是由插入内容时给定的。当要查询某一分区的内容时可以采用where语句，形似where tablename.partition_key &gt; a来实现。</p>
<p>创建含分区的表。</p>
<p>命令原型：</p>
<p style="background:rgb(243,245,247)">CREATE TABLE page_view(viewTime INT, userid BIGINT,</p>
<p style="background:rgb(243,245,247)">     page_url STRING, referrer_url STRING,</p>
<p style="background:rgb(243,245,247)">     ip STRING COMMENT 'IP Address of the User')</p>
<p style="background:rgb(243,245,247)"> COMMENT 'This is the page view table'</p>
<p style="background:rgb(243,245,247)"> PARTITIONED BY(dt STRING, country STRING)</p>
<p style="background:rgb(243,245,247)"> CLUSTERED BY(userid) SORTED BY(viewTime) INTO 32 BUCKETS</p>
<p style="background:rgb(243,245,247)"> ROW FORMAT DELIMITED</p>
<p style="background:rgb(243,245,247)">   FIELDS TERMINATED BY '\001'</p>
<p style="background:rgb(243,245,247)">   COLLECTION ITEMS TERMINATED BY '\002'</p>
<p style="background:rgb(243,245,247)">   MAP KEYS TERMINATED BY '\003'</p>
<p style="background:rgb(243,245,247)"> STORED AS SEQUENCEFILE;</p>
<p> </p>
<p>Eg:</p>
<p>建表：</p>
<p>CREATE TABLE c02_clickstat_fatdt1</p>
<p>(yyyymmdd  string,</p>
<p> id              INT,</p>
<p> ip               string,</p>
<p> country          string,</p>
<p> cookie_id        string,</p>
<p> page_id          string  ,  </p>
<p> clickstat_url_id int,</p>
<p> query_string     string,</p>
<p> refer            string</p>
<p>)PARTITIONED BY(dt STRING)</p>
<p>row format delimited fields terminated by '\005' stored as textfile;</p>
<p> </p>
<p>装载数据：</p>
<p>LOAD DATA INPATH '/user/admin/SqlldrDat/CnClickstat/20101101/19/clickstat_gp_fatdt0/0' OVERWRITE INTO TABLE c02_clickstat_fatdt1</p>
<p> PARTITION(dt='20101101');</p>
<p> </p>
<p>访问某一个分区</p>
<p>SELECT count(*)</p>
<p>    FROM c02_clickstat_fatdt1 a</p>
<p>    WHERE a.dt &gt;= '20101101' AND a.dt &lt; '20101102';</p>
<h3><a target="_blank" name="_Toc280791013"></a>2.1.5 <strong>其它例子</strong></h3>
<p>1、指定LOCATION位置</p>
<p style="background:rgb(243,245,247)">CREATE EXTERNAL TABLE page_view(viewTime INT, userid BIGINT,</p>
<p style="background:rgb(243,245,247)">     page_url STRING, referrer_url STRING,</p>
<p style="background:rgb(243,245,247)">     ip STRING COMMENT 'IP Address of the User',</p>
<p style="background:rgb(243,245,247)">     country STRING COMMENT 'country of origination')</p>
<p style="background:rgb(243,245,247)"> COMMENT 'This is the staging page view table'</p>
<p style="background:rgb(243,245,247)"> ROW FORMAT DELIMITED FIELDS TERMINATED BY '\054'</p>
<p style="background:rgb(243,245,247)"> STORED AS TEXTFILE</p>
<p style="background:rgb(243,245,247)"> LOCATION '&lt;hdfs_location&gt;';</p>
<p>2、 复制一个空表</p>
<p style="background:rgb(243,245,247)">CREATE TABLE empty_key_value_store</p>
<p style="background:rgb(243,245,247)">LIKE key_value_store;</p>
<p> </p>
<p> </p>
<p> </p>
<h2><a target="_blank" name="_Toc280791014"></a>2.2 <strong>Alter Table</strong></h2>
<h3><a target="_blank" name="_Toc280791015"></a>2.2.1 <strong>Add Partitions</strong></h3>
<p style="background:rgb(243,245,247)">ALTER TABLE table_name ADD [IF NOT EXISTS] partition_spec [ LOCATION 'location1' ] partition_spec [ LOCATION 'location2' ] ...</p>
<p style="background:rgb(243,245,247)"> </p>
<p style="background:rgb(243,245,247)">partition_spec:</p>
<p style="background:rgb(243,245,247)">  : PARTITION (partition_col = partition_col_value, partition_col = partiton_col_value, ...)</p>
<p>Eg:</p>
<p>ALTER TABLE c02_clickstat_fatdt1 ADD </p>
<p>PARTITION (dt='20101202') location '/user/hive/warehouse/c02_clickstat_fatdt1/part20101202'
</p>
<p>PARTITION (dt='20101203') location '/user/hive/warehouse/c02_clickstat_fatdt1/part20101203';</p>
<p> </p>
<h3><a target="_blank" name="_Toc280791016"></a>2.2.2 <strong>Drop Partitions</strong></h3>
<p>ALTER TABLE table_name DROP partition_spec, partition_spec,...</p>
<p> </p>
<p>ALTER TABLE c02_clickstat_fatdt1 DROP PARTITION (dt='20101202');</p>
<h3><a target="_blank" name="_Toc280791017"></a>2.2.3 <strong>Rename Table</strong></h3>
<p>ALTER TABLE table_name RENAME TO new_table_name</p>
<p><span style="font-family:宋体">这个命令可以让用户为表更名。数据所在的位置和分区名并不改变。换而言之，老的表名并未</span>“释放”，对老表的更改会改变新表的数据。</p>
<h3><a target="_blank" name="_Toc280791018"></a>2.2.4 <strong>Change Column </strong></h3>
<p>ALTER TABLE table_name CHANGE [COLUMN] col_old_name col_new_name column_type [COMMENT col_comment] [FIRST|AFTER column_name]</p>
<p>这个命令可以允许改变列名、数据类型、注释、列位置或者它们的任意组合</p>
<p>Eg:</p>
<p> </p>
<h3><a target="_blank" name="_Toc280791019"></a>2.2.5 <strong>Add/Replace Columns</strong></h3>
<p>ALTER TABLE table_name ADD|REPLACE COLUMNS (col_name data_type [COMMENT col_comment], ...)</p>
<p> </p>
<p>ADD是代表新增一字段，字段位置在所有列后面(partition列前);REPLACE则是表示替换表中所有字段。</p>
<p>Eg:</p>
<p>hive&gt; desc xi;</p>
<p>OK</p>
<p>id      int</p>
<p>cont    string</p>
<p>dw_ins_date     string</p>
<p>Time taken: 0.061 seconds</p>
<p>hive&gt; create table xibak like xi;                         </p>
<p>OK</p>
<p>Time taken: 0.157 seconds</p>
<p>hive&gt; alter table xibak replace columns (ins_date string);   </p>
<p>OK</p>
<p>Time taken: 0.109 seconds</p>
<p>hive&gt; desc xibak;</p>
<p>OK</p>
<p>ins_date        string</p>
<h2><a target="_blank" name="_Toc280791020"></a>2.3 <strong>Create View</strong></h2>
<p>CREATE VIEW [IF NOT EXISTS] view_name [ (column_name [COMMENT column_comment], ...) ]</p>
<p>[COMMENT view_comment]</p>
<p>[TBLPROPERTIES (property_name = property_value, ...)]</p>
<p>AS SELECT ...</p>
<p> </p>
<h2><a target="_blank" name="_Toc280791021"></a>2.4 <strong>Show</strong></h2>
<p>查看表名</p>
<p style="background:rgb(243,245,247)">SHOW TABLES;</p>
<p> </p>
<p>查看表名，部分匹配</p>
<p style="background:rgb(243,245,247)">SHOW TABLES 'page.*';</p>
<p style="background:rgb(243,245,247)">SHOW TABLES '.*view';</p>
<p> </p>
<p><span style="font-family:宋体">查看某表的所有</span>Partition，如果没有就报错：</p>
<p style="background:rgb(243,245,247)">SHOW PARTITIONS page_view;</p>
<p> </p>
<p>查看某表结构：</p>
<p style="background:rgb(243,245,247)">DESCRIBE <em>invites</em>;</p>
<p> </p>
<p>查看分区内容</p>
<p style="background:rgb(243,245,247)">SELECT a.foo FROM invites a WHERE a.ds='2008-08-15';</p>
<p> </p>
<p><span style="font-family:宋体">查看有限行内容，同</span>Greenplum，用limit关键词</p>
<p style="background:rgb(243,245,247)">SELECT a.foo FROM invites a limit 3;</p>
<p> </p>
<p>查看表分区定义</p>
<p style="background:rgb(243,245,247)">DESCRIBE EXTENDED page_view PARTITION (ds='2008-08-08');</p>
<h2><a target="_blank" name="_Toc280791022"></a>2.5 <strong>Load</strong></h2>
<p>   HIVE装载数据没有做任何转换加载到表中的数据只是进入相应的配置单元表的位置移动数据文件。纯加载操作复制/移动操作。 </p>
<p> </p>
<p>3.1 语法</p>
<p style="background:rgb(243,245,247)">LOAD DATA [LOCAL] INPATH 'filepath' [OVERWRITE] INTO TABLE tablename [PARTITION (partcol1=val1, partcol2=val2 ...)]</p>
<p>Load 操作只是单纯的复制/移动操作，将数据文件移动到 Hive 表对应的位置。</p>
<p>· filepath 可以是： </p>
<p>o <span style="font-family:宋体">相对路径，例如：</span>project/data1 </p>
<p>o <span style="font-family:宋体">绝对路径，例如：</span> /user/hive/project/data1 </p>
<p>o <span style="font-family:宋体">包含模式的完整</span> URI，例如：hdfs://namenode:9000/user/hive/project/data1
</p>
<p>· <span style="font-family:宋体">加载的目标可以是一个表或者分区。如果表包含分区，必须指定每一个分区的分区名。</span> </p>
<p>· filepath 可以引用一个文件（这种情况下，Hive 会将文件移动到表所对应的目录中）或者是一个目录（在这种情况下，Hive 会将目录中的所有文件移动至表所对应的目录中）。
</p>
<p>· <span style="font-family:宋体">如果指定了</span> LOCAL，那么： </p>
<p>o load 命令会去查找本地文件系统中的 filepath。如果发现是相对路径，则路径会被解释为相对于当前用户的当前路径。用户也可以为本地文件指定一个完整的 URI，比如：file:///user/hive/project/data1.
</p>
<p>o load 命令会将 filepath 中的文件复制到目标文件系统中。目标文件系统由表的位置属性决定。被复制的数据文件移动到表的数据对应的位置。 </p>
<p>· <span style="font-family:宋体">如果没有指定</span> LOCAL 关键字，如果 filepath 指向的是一个完整的 URI，hive 会直接使用这个 URI。 否则：
</p>
<p>o <span style="font-family:宋体">如果没有指定</span> schema 或者 authority，Hive 会使用在 hadoop 配置文件中定义的 schema 和 authority，fs.default.name 指定了 Namenode 的 URI。
</p>
<p>o <span style="font-family:宋体">如果路径不是绝对的，</span>Hive 相对于 /user/ 进行解释。 </p>
<p>o Hive 会将 filepath 中指定的文件内容移动到 table （或者 partition）所指定的路径中。 </p>
<p>· <span style="font-family:宋体">如果使用了</span> OVERWRITE 关键字，则目标表（或者分区）中的内容（如果有）会被删除，然后再将 filepath 指向的文件/目录中的内容添加到表/分区中。
</p>
<p>· <span style="font-family:宋体">如果目标表（分区）已经有一个文件，并且文件名和</span> filepath 中的文件名冲突，那么现有的文件会被新文件所替代。
</p>
<p> </p>
<p>从本地导入数据到表格并追加原表</p>
<p style="background:rgb(243,245,247)">LOAD DATA LOCAL INPATH `/tmp/pv_2008-06-08_us.txt` INTO TABLE c02 PARTITION(date='2008-06-08', country='US')</p>
<p> </p>
<p>从本地导入数据到表格并追加记录</p>
<p style="background:rgb(243,245,247)">LOAD DATA LOCAL INPATH './examples/files/kv1.txt' INTO TABLE pokes;
</p>
<p> </p>
<p><span style="font-family:宋体">从</span>hdfs导入数据到表格并覆盖原表</p>
<p style="background:rgb(243,245,247)">LOAD DATA INPATH '/user/admin/SqlldrDat/CnClickstat/20101101/18/clickstat_gp_fatdt0/0' INTO table c02_clickstat_fatdt1 OVERWRITE PARTITION (dt='20101201');</p>
<p>关于来源的文本数据的字段间隔符</p>
<p><span style="font-family:宋体">如果要将自定义间隔符的文件读入一个表，需要通过创建表的语句来指明输入文件间隔符，然后</span>load data到这个表就ok了。</p>
<p> </p>
<h2><a target="_blank" name="_Toc280791023"></a>2.6 <strong>Insert</strong></h2>
<h3><a target="_blank" name="_Toc280791024"></a>2.6.1 <strong>Inserting data into Hive Tables from queries</strong></h3>
<p> </p>
<p style="background:rgb(243,245,247)">Standard syntax:</p>
<p style="background:rgb(243,245,247)">INSERT OVERWRITE TABLE tablename1 [PARTITION (partcol1=val1, partcol2=val2 ...)] select_statement1 FROM from_statement
</p>
<p style="background:rgb(243,245,247)"> </p>
<p style="background:rgb(243,245,247)">Hive extension (multiple inserts):</p>
<p style="background:rgb(243,245,247)">FROM from_statement</p>
<p style="background:rgb(243,245,247)">INSERT OVERWRITE TABLE tablename1 [PARTITION (partcol1=val1, partcol2=val2 ...)] select_statement1</p>
<p style="background:rgb(243,245,247)">[INSERT OVERWRITE TABLE tablename2 [PARTITION ...] select_statement2] ...</p>
<p style="background:rgb(243,245,247)"> </p>
<p style="background:rgb(243,245,247)">Hive extension (dynamic partition inserts):</p>
<p style="background:rgb(243,245,247)">INSERT OVERWRITE TABLE tablename PARTITION (partcol1[=val1], partcol2[=val2] ...) select_statement FROM from_statement
</p>
<p> </p>
<p>Insert时，from子句既可以放在select子句后，也可以放在insert子句前，下面两句是等价的</p>
<p style="background:rgb(243,245,247)">hive&gt; FROM invites a INSERT OVERWRITE TABLE events SELECT a.bar, count(*) WHERE a.foo &gt; 0 GROUP BY a.bar;</p>
<p style="background:rgb(243,245,247)">  hive&gt; INSERT OVERWRITE TABLE events SELECT a.bar, count(*) FROM invites a WHERE a.foo &gt; 0 GROUP BY a.bar;</p>
<p>hive<span style="font-family:宋体">没有直接插入一条数据的</span><span style="font-family:Calibri">sql</span><span style="font-family:宋体">，不过可以通过其他方法实现：</span><br>
<span style="font-family:宋体">假设有一张表</span>B<span style="font-family:宋体">至少有一条数据，我们想向表</span><span style="font-family:Calibri">A</span><span style="font-family:宋体">（</span><span style="font-family:Calibri">int</span><span style="font-family:宋体">，</span><span style="font-family:Calibri">string</span><span style="font-family:宋体">）中插入一条数据，可以用下面的方法实现：</span><br>
from B<br>
insert table A select  1<span style="font-family:宋体">，</span><span style="font-family:Calibri">‘abc’ limit 1</span><span style="font-family:宋体">；</span></p>
<p> </p>
<p><span style="font-family:宋体">我觉得</span>hive<span style="font-family:宋体">好像不能够插入一个记录，因为每次你写</span><span style="font-family:Calibri">insert</span><span style="font-family:宋体">语句的时候都是要将整个表的值</span><span style="font-family:Calibri">overwrite</span><span style="font-family:宋体">。我想这个应该是与</span><span style="font-family:Calibri">hive</span><span style="font-family:宋体">的</span><span style="font-family:Calibri">storage
 layer</span><span style="font-family:宋体">是有关系的，因为它的存储层是</span><span style="font-family:Calibri">HDFS</span><span style="font-family:宋体">，插入一个数据要全表扫描，还不如用整个表的替换来的快些。</span></p>
<p> </p>
<p>Hive<span style="font-family:宋体">不支持一条一条的用</span><span style="font-family:Calibri">insert</span><span style="font-family:宋体">语句进行插入操作，也不支持</span><span style="font-family:Calibri">update</span><span style="font-family:宋体">的操作。数据是以</span><span style="font-family:Calibri">load</span><span style="font-family:宋体">的方式，加载到建立好的表中。数据一旦导入，则不可修改。要么</span><span style="font-family:Calibri">drop</span><span style="font-family:宋体">掉整个表，要么建立新的表，导入新的数据。</span></p>
<h3><a target="_blank" name="_Toc280791025"></a>2.6.2 <strong>Writing data into filesystem from queries</strong></h3>
<p style="background:rgb(243,245,247)">Standard syntax:</p>
<p style="background:rgb(243,245,247)">INSERT OVERWRITE [LOCAL] DIRECTORY directory1 SELECT ... FROM ...</p>
<p style="background:rgb(243,245,247)"> </p>
<p style="background:rgb(243,245,247)">Hive extension (multiple inserts):</p>
<p style="background:rgb(243,245,247)">FROM from_statement</p>
<p style="background:rgb(243,245,247)">INSERT OVERWRITE [LOCAL] DIRECTORY directory1 select_statement1</p>
<p style="background:rgb(243,245,247)">[INSERT OVERWRITE [LOCAL] DIRECTORY directory2 select_statement2] ...</p>
<p> </p>
<p>导出文件到本地</p>
<p style="background:rgb(243,245,247)">INSERT OVERWRITE LOCAL DIRECTORY '/tmp/local_out' SELECT a.* FROM pokes a;</p>
<p> </p>
<p><span style="font-family:宋体">导出文件到</span>HDFS</p>
<p style="background:rgb(243,245,247)">INSERT OVERWRITE DIRECTORY '/user/admin/SqlldrDat/CnClickstat/20101101/19/clickstat_gp_fatdt0/0' SELECT a.* FROM c02_clickstat_fatdt1 a WHERE dt=’20101201’;</p>
<p> </p>
<p><span style="font-family:宋体">一个源可以同时插入到多个目标表或目标文件，多目标</span>insert可以用一句话来完成</p>
<p style="background:rgb(243,245,247)">FROM src</p>
<p style="background:rgb(243,245,247)">  INSERT OVERWRITE TABLE dest1 SELECT src.* WHERE src.key &lt; 100</p>
<p style="background:rgb(243,245,247)">  INSERT OVERWRITE TABLE dest2 SELECT src.key, src.value WHERE src.key &gt;= 100 and src.key &lt; 200</p>
<p style="background:rgb(243,245,247)">  INSERT OVERWRITE TABLE dest3 PARTITION(ds='2008-04-08', hr='12') SELECT src.key WHERE src.key &gt;= 200 and src.key &lt; 300</p>
<p style="background:rgb(243,245,247)">  INSERT OVERWRITE LOCAL DIRECTORY '/tmp/dest4.out' SELECT src.value WHERE src.key &gt;= 300;</p>
<p>Eg:</p>
<p>from xi  </p>
<p>insert overwrite  table test2 select  '1,2,3' limit 1 </p>
<p>insert overwrite  table d select  '4,5,6' limit 1;</p>
<h2><a target="_blank" name="_Toc280791026"></a>2.7 <strong>Cli</strong></h2>
<h3><a target="_blank" name="_Toc280791027"></a>2.7.1 <strong>Hive Command line Options</strong></h3>
<p>$HIVE_HOME/bin/hive<span style="font-family:宋体">是一个</span>shell工具，它可以用来运行于交互或批处理方式配置单元查询。</p>
<p>语法：</p>
<p style="background:rgb(243,245,247)">  Usage: hive [-hiveconf x=y]* [&lt;-i filename&gt;]* [&lt;-f filename&gt;|&lt;-e query-string&gt;] [-S]</p>
<p style="background:rgb(243,245,247)"> </p>
<p style="background:rgb(243,245,247)">  -i &lt;filename&gt;             Initialization Sql from file (executed automatically and silently before any other commands)</p>
<p style="background:rgb(243,245,247)">  -e 'quoted query string'  Sql from command line</p>
<p style="background:rgb(243,245,247)">  -f &lt;filename&gt;             Sql from file</p>
<p style="background:rgb(243,245,247)">  -S                        Silent mode in interactive shell where only data is emitted</p>
<p style="background:rgb(243,245,247)">  -hiveconf x=y             Use this to set hive/hadoop configuration variables.
</p>
<p style="background:rgb(243,245,247)">  </p>
<p style="background:rgb(243,245,247)">   -e and -f cannot be specified together. In the absence of these options, interactive shell is started.  </p>
<p style="background:rgb(243,245,247)">   However, -i can be used with any other options.  Multiple instances of -i can be used to execute multiple init scripts.</p>
<p style="background:rgb(243,245,247)"> </p>
<p style="background:rgb(243,245,247)">   To see this usage help, run hive -h</p>
<p> </p>
<p>运行一个查询： </p>
<p style="background:rgb(243,245,247)">$HIVE_HOME/bin/ hive -e 'select count(*) from c02_clickstat_fatdt1'</p>
<p>Example of setting hive configuration variables </p>
<p style="background:rgb(243,245,247)">$HIVE_HOME/bin/hive -e 'select a.col from tab1 a' -hiveconf hive.exec.scratchdir=/home/my/hive_scratch  -hiveconf mapred.reduce.tasks=32</p>
<p><span style="font-family:宋体">将查询结果导出到一个文件</span> </p>
<p style="background:rgb(243,245,247)">HIVE_HOME/bin/hive -S -e ' select count(*) from c02_clickstat_fatdt1' &gt; a.txt</p>
<p><span style="font-family:宋体">运行一个脚本</span> </p>
<p style="background:rgb(243,245,247)">HIVE_HOME/bin/hive -f /home/my/hive-script.sql</p>
<p>Example of running an initialization script before entering interactive mode </p>
<p style="background:rgb(243,245,247)">HIVE_HOME/bin/hive -i /home/my/hive-init.sql</p>
<p> </p>
<h3><a target="_blank" name="_Toc280791028"></a>2.7.2 <strong>Hive interactive Shell Command</strong></h3>
<table>
<tbody>
<tr>
<td valign="center">
<p><strong>Command </strong></p>
</td>
<td valign="center">
<p><strong>Description</strong></p>
</td>
</tr>
<tr>
<td valign="center">
<p>quit</p>
</td>
<td valign="center">
<p>使用 quit or exit 退出</p>
</td>
</tr>
<tr>
<td valign="center">
<p>set &lt;key&gt;=&lt;value&gt;</p>
</td>
<td valign="center">
<p>使用这个方式来设置特定的配置变量的值。有一点需要注意的是，如果你拼错了变量名，CLI将不会显示错误。</p>
</td>
</tr>
<tr>
<td valign="center">
<p>set</p>
</td>
<td valign="center">
<p>这将打印的配置变量，如果没有指定变量则由显示HIVE和用户变量。如set I 则显示i的值,set则显示hive内部变量值</p>
</td>
</tr>
<tr>
<td valign="center">
<p>set -v</p>
</td>
<td valign="center">
<p>This will give all possible hadoop/hive configuration variables.</p>
</td>
</tr>
<tr>
<td valign="center">
<p>add FILE &lt;value&gt; &lt;value&gt;*</p>
</td>
<td valign="center">
<p>Adds a file to the list of resources.</p>
</td>
</tr>
<tr>
<td valign="center">
<p>list FILE</p>
</td>
<td valign="center">
<p>list all the resources already added</p>
</td>
</tr>
<tr>
<td valign="center">
<p>list FILE &lt;value&gt;*</p>
</td>
<td valign="center">
<p>Check given resources are already added or not.</p>
</td>
</tr>
<tr>
<td valign="center">
<p>! &lt;cmd&gt;</p>
</td>
<td valign="center">
<p>execute a shell command from hive shell</p>
</td>
</tr>
<tr>
<td valign="center">
<p>dfs &lt;dfs command&gt;</p>
</td>
<td valign="center">
<p>execute dfs command command from hive shell</p>
</td>
</tr>
<tr>
<td valign="center">
<p>&lt;query string&gt; </p>
</td>
<td valign="center">
<p>executes hive query and prints results to stdout</p>
</td>
</tr>
</tbody>
</table>
<p>Eg:</p>
<p style="background:rgb(243,245,247)">  hive&gt; set  i=32;</p>
<p style="background:rgb(243,245,247)">  hive&gt; set i;</p>
<p style="background:rgb(243,245,247)">  hive&gt; select a.* from htduan a;</p>
<p style="background:rgb(243,245,247)">  hive&gt; !ls;</p>
<p style="background:rgb(243,245,247)">  hive&gt; dfs -ls;</p>
<p> </p>
<p>还可以这样用</p>
<p>hive&gt; set $i='121.61.99.14.128160791368.5';</p>
<p>hive&gt; select count(*) from c02_clickstat_fatdt1 where cookie_id=$i;</p>
<p>11</p>
<h3><a target="_blank" name="_Toc280791029"></a>2.7.3 <strong>Hive Resources</strong></h3>
<p>Hive can manage the addition of resources to a session where those resources need to be made available at query execution time. Any locally accessible file can be added to the session. Once a file is added to a session, hive query can refer to this file
 by its name (in map/reduce/transform clauses) and this file is available locally at execution time on the entire hadoop cluster. Hive uses Hadoop's Distributed Cache to distribute the added files to all the machines in the cluster at query execution time.
</p>
<p>Usage: </p>
<p style="background:rgb(243,245,247)">·    ADD { FILE[S] | JAR[S] | ARCHIVE[S] } &lt;filepath1&gt; [&lt;filepath2&gt;]*</p>
<p style="background:rgb(243,245,247)">·    LIST { FILE[S] | JAR[S] | ARCHIVE[S] } [&lt;filepath1&gt; &lt;filepath2&gt; ..]</p>
<p style="background:rgb(243,245,247)">·    DELETE { FILE[S] | JAR[S] | ARCHIVE[S] } [&lt;filepath1&gt; &lt;filepath2&gt; ..]</p>
<p>· FILE resources are just added to the distributed cache. Typically, this might be something like a transform script to be executed.
</p>
<p>· JAR resources are also added to the Java classpath. This is required in order to reference objects they contain such as UDF's.
</p>
<p>· ARCHIVE resources are automatically unarchived as part of distributing them.
</p>
<p>Example: </p>
<p style="background:rgb(243,245,247)">·   hive&gt; add FILE /tmp/tt.py;</p>
<p style="background:rgb(243,245,247)">·   hive&gt; list FILES;</p>
<p style="background:rgb(243,245,247)">·   /tmp/tt.py</p>
<p style="background:rgb(243,245,247)">·   hive&gt; from networks a  MAP a.networkid USING 'python tt.py' as nn where a.ds = '2009-01-04' limit  10;</p>
<p>It is not neccessary to add files to the session if the files used in a transform script are already available on all machines in the hadoop cluster using the same path name. For example:
</p>
<p>· ... MAP a.networkid USING 'wc -l' ...: here wc is an executable available on all machines
</p>
<p>· ... MAP a.networkid USING '/home/nfsserv1/hadoopscripts/tt.py' ...: here tt.py may be accessible via a nfs mount point that's configured identically on all the cluster nodes</p>
<p> </p>
<h3><a target="_blank" name="_Toc280791030"></a>2.7.4 <strong><span style="font-family:宋体">调用</span>python、shell等语言</strong></h3>
<p><span style="font-family:宋体">如下面这句</span>sql就是借用了weekday_mapper.py对数据进行了处理</p>
<p style="background:rgb(243,245,247)">CREATE TABLE u_data_new (</p>
<p style="background:rgb(243,245,247)">  userid INT,</p>
<p style="background:rgb(243,245,247)">  movieid INT,</p>
<p style="background:rgb(243,245,247)">  rating INT,</p>
<p style="background:rgb(243,245,247)">  weekday INT)</p>
<p style="background:rgb(243,245,247)">ROW FORMAT DELIMITED</p>
<p style="background:rgb(243,245,247)">FIELDS TERMINATED BY '\t';</p>
<p style="background:rgb(243,245,247)"> </p>
<p style="background:rgb(243,245,247)">add FILE weekday_mapper.py;</p>
<p style="background:rgb(243,245,247)"> </p>
<p style="background:rgb(243,245,247)">INSERT OVERWRITE TABLE u_data_new</p>
<p style="background:rgb(243,245,247)"><span style="color:rgb(224,106,9)">SELECT</span></p>
<p style="background:rgb(243,245,247)"><span style="color:rgb(224,106,9)">  TRANSFORM
</span><span style="color:rgb(224,106,9)">(userid, movieid, rating, unixtime)</span></p>
<p style="background:rgb(243,245,247)"><span style="color:rgb(224,106,9)">  USING 'python weekday_mapper.py'</span></p>
<p style="background:rgb(243,245,247)"><span style="color:rgb(224,106,9)">  AS (userid, movieid, rating, weekday)</span></p>
<p style="background:rgb(243,245,247)">FROM u_data;</p>
<p><span style="font-family:宋体">，其中</span>weekday_mapper.py内容如下</p>
<p style="background:rgb(243,245,247)">import sys</p>
<p style="background:rgb(243,245,247)">import datetime</p>
<p style="background:rgb(243,245,247)"> </p>
<p style="background:rgb(243,245,247)">for line in sys.stdin:</p>
<p style="background:rgb(243,245,247)">  line = line.strip()</p>
<p style="background:rgb(243,245,247)">  userid, movieid, rating, unixtime = line.split('\t')</p>
<p style="background:rgb(243,245,247)">  weekday = datetime.datetime.fromtimestamp(float(unixtime)).isoweekday()</p>
<p style="background:rgb(243,245,247)">  print '\t'.join([userid, movieid, rating, str(weekday)])</p>
<p> </p>
<p><span style="font-family:宋体">如下面的例子则是使用了</span>shell的cat命令来处理数据</p>
<p style="background:rgb(243,245,247)">FROM invites a INSERT OVERWRITE TABLE events
<span style="color:rgb(224,106,9)">SELECT TRANSFORM(a.foo, a.bar) AS (oof, rab) USING '/bin/cat'</span> WHERE a.ds &gt; '2008-08-09';</p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<h2><a target="_blank" name="_Toc280791031"></a>2.8 <strong>DROP</strong></h2>
<p>删除一个内部表的同时会同时删除表的元数据和数据。删除一个外部表，只删除元数据而保留数据。</p>
<p> </p>
<h2><a target="_blank" name="_Toc280791032"></a>2.9 <strong>其它</strong></h2>
<h3><a target="_blank" name="_Toc280791033"></a>2.9.1 <strong>Limit</strong></h3>
<p>Limit 可以限制查询的记录数。查询的结果是随机选择的。下面的查询语句从 t1 表中随机查询5条记录：</p>
<p>SELECT * FROM t1 LIMIT 5</p>
<h3><a target="_blank" name="_Toc280791034"></a>2.9.2 <strong>Top k</strong></h3>
<p><span style="font-family:宋体">下面的查询语句查询销售记录最大的</span> 5 个销售代表。</p>
<p>SET mapred.reduce.tasks = 1</p>
<p>  SELECT * FROM sales SORT BY amount DESC LIMIT 5</p>
<p> </p>
<h3><a target="_blank" name="_Toc280791035"></a>2.9.3 <strong>REGEX Column Specification</strong></h3>
<p>SELECT 语句可以使用正则表达式做列选择，下面的语句查询除了 ds 和 hr 之外的所有列：</p>
<p>SELECT `(ds|hr)?+.+` FROM sales</p>
<p> </p>
<h1><a target="_blank" name="_Toc280791036"></a>3. <strong>Hive Select</strong></h1>
<p>语法：</p>
<p style="background:rgb(243,245,247)">SELECT [ALL | DISTINCT] select_expr, select_expr, ...</p>
<p style="background:rgb(243,245,247)">FROM table_reference</p>
<p style="background:rgb(243,245,247)">[WHERE where_condition] </p>
<p style="background:rgb(243,245,247)">[GROUP BY col_list]</p>
<p style="background:rgb(243,245,247)">[   CLUSTER BY col_list</p>
<p style="background:rgb(243,245,247)">  | [DISTRIBUTE BY col_list] [SORT BY col_list]</p>
<p style="background:rgb(243,245,247)">]</p>
<p style="background:rgb(243,245,247)">[LIMIT number]</p>
<p> </p>
<h2><a target="_blank" name="_Toc280791037"></a>3.1 <strong>Group By</strong></h2>
<p>基本语法：</p>
<p style="background:rgb(243,245,247)">groupByClause: GROUP BY groupByExpression (, groupByExpression)*</p>
<p style="background:rgb(243,245,247)"> </p>
<p style="background:rgb(243,245,247)">groupByExpression: expression</p>
<p style="background:rgb(243,245,247)"> </p>
<p style="background:rgb(243,245,247)">groupByQuery: SELECT expression (, expression)* FROM src groupByClause?</p>
<p> </p>
<p>高级特性：</p>
<p>l <span style="font-family:宋体">聚合可进一步分为多个表，甚至发送到</span>Hadoop的DFS的文件（可以进行操作，然后使用HDFS的utilitites）。例如我们可以根据性别划分，需要找到独特的页面浏览量按年龄划分。如下面的例子：</p>
<p style="background:rgb(243,245,247)">  FROM pv_users </p>
<p style="background:rgb(243,245,247)">  INSERT OVERWRITE TABLE pv_gender_sum</p>
<p style="background:rgb(243,245,247)">    SELECT pv_users.gender, count(DISTINCT pv_users.userid)
</p>
<p style="background:rgb(243,245,247)">    GROUP BY pv_users.gender </p>
<p style="background:rgb(243,245,247)">  INSERT OVERWRITE DIRECTORY '/user/facebook/tmp/pv_age_sum'</p>
<p style="background:rgb(243,245,247)">    SELECT pv_users.age, count(DISTINCT pv_users.userid)
</p>
<p style="background:rgb(243,245,247)">    GROUP BY pv_users.age; </p>
<p> </p>
<p>l hive.map.aggr可以控制怎么进行汇总。默认为为true，配置单元会做的第一级聚合直接在MAP上的任务。这通常提供更好的效率，但可能需要更多的内存来运行成功。</p>
<p style="background:rgb(243,245,247)"> set hive.map.aggr=true;</p>
<p style="background:rgb(243,245,247)">SELECT COUNT(*) FROM table2;</p>
<p>PS:在要特定的场合使用可能会加效率。不过我试了一下，比直接使用False慢很多。</p>
<h2><a target="_blank" name="_Toc280791038"></a>3.2 <strong>Order /Sort By</strong></h2>
<p>Order by 语法：</p>
<p style="background:rgb(243,245,247)">colOrder: ( ASC | DESC )</p>
<p style="background:rgb(243,245,247)">orderBy: ORDER BY colName colOrder? (',' colName colOrder?)*</p>
<p style="background:rgb(243,245,247)">query: SELECT expression (',' expression)* FROM src orderBy</p>
<p> </p>
<p>Sort By 语法：</p>
<p>Sort顺序将根据列类型而定。如果数字类型的列，则排序顺序也以数字顺序。如果字符串类型的列，则排序顺序将字典顺序。 </p>
<p style="background:rgb(243,245,247)">colOrder: ( ASC | DESC )</p>
<p style="background:rgb(243,245,247)">sortBy: SORT BY colName colOrder? (',' colName colOrder?)*</p>
<p style="background:rgb(243,245,247)">query: SELECT expression (',' expression)* FROM src sortBy</p>
<p> </p>
<h1><a target="_blank" name="_Toc280791039"></a>4. <strong>Hive Join</strong></h1>
<p>语法</p>
<p style="background:rgb(243,245,247)">join_table:</p>
<p style="background:rgb(243,245,247)">    table_reference JOIN table_factor [join_condition]</p>
<p style="background:rgb(243,245,247)">  | table_reference {LEFT|RIGHT|FULL} [OUTER] JOIN table_reference join_condition</p>
<p style="background:rgb(243,245,247)">  | table_reference LEFT SEMI JOIN table_reference join_condition</p>
<p style="background:rgb(243,245,247)"> </p>
<p style="background:rgb(243,245,247)">table_reference:</p>
<p style="background:rgb(243,245,247)">    table_factor</p>
<p style="background:rgb(243,245,247)">  | join_table</p>
<p style="background:rgb(243,245,247)"> </p>
<p style="background:rgb(243,245,247)">table_factor:</p>
<p style="background:rgb(243,245,247)">    tbl_name [alias]</p>
<p style="background:rgb(243,245,247)">  | table_subquery alias</p>
<p style="background:rgb(243,245,247)">  | ( table_references )</p>
<p style="background:rgb(243,245,247)"> </p>
<p style="background:rgb(243,245,247)">join_condition:</p>
<p style="background:rgb(243,245,247)">    ON equality_expression ( AND equality_expression )*</p>
<p style="background:rgb(243,245,247)"> </p>
<p style="background:rgb(243,245,247)">equality_expression:</p>
<p style="background:rgb(243,245,247)">    expression = expression</p>
<p>Hive 只支持等值连接（equality joins）、外连接（outer joins）和（left/right joins）。Hive 不支持所有非等值的连接，因为非等值连接非常难转化到 map/reduce 任务。另外，Hive 支持多于 2 个表的连接。</p>
<p><span style="font-family:宋体">写</span> join 查询时，需要注意几个关键点：</p>
<p>1、只支持等值join</p>
<p><span style="font-family:宋体">例如：</span> </p>
<p>  SELECT a.* FROM a JOIN b ON (a.id = b.id)</p>
<p>  SELECT a.* FROM a JOIN b</p>
<p>    ON (a.id = b.id AND a.department = b.department)</p>
<p><span style="font-family:宋体">是正确的，然而</span>:</p>
<p>  SELECT a.* FROM a JOIN b ON (a.id  b.id)</p>
<p>是错误的。</p>
<p> </p>
<p>1. <span style="font-family:宋体">可以</span> join 多于 2 个表。</p>
<p>例如</p>
<p>  SELECT a.val, b.val, c.val FROM a JOIN b</p>
<p>    ON (a.key = b.key1) JOIN c ON (c.key = b.key2)</p>
<p><span style="font-family:宋体">如果</span>join中多个表的 join key 是同一个，则 join 会被转化为单个 map/reduce 任务，例如：</p>
<p>  SELECT a.val, b.val, c.val FROM a JOIN b</p>
<p>    ON (a.key = b.key1) JOIN c</p>
<p>    ON (c.key = b.key1)</p>
<p><span style="font-family:宋体">被转化为单个</span> map/reduce 任务，因为 join 中只使用了 b.key1 作为 join key。</p>
<p>SELECT a.val, b.val, c.val FROM a JOIN b ON (a.key = b.key1)</p>
<p>  JOIN c ON (c.key = b.key2)</p>
<p><span style="font-family:宋体">而这一</span> join 被转化为 2 个 map/reduce 任务。因为 b.key1 用于第一次 join 条件，而 b.key2 用于第二次 join。</p>
<p>   </p>
<p>3．join 时，每次 map/reduce 任务的逻辑：</p>
<p>    reducer 会缓存 join 序列中除了最后一个表的所有表的记录，再通过最后一个表将结果序列化到文件系统。这一实现有助于在 reduce 端减少内存的使用量。实践中，应该把最大的那个表写在最后（否则会因为缓存浪费大量内存）。例如：</p>
<p> SELECT a.val, b.val, c.val FROM a</p>
<p>    JOIN b ON (a.key = b.key1) JOIN c ON (c.key = b.key1)</p>
<p><span style="font-family:宋体">所有表都使用同一个</span> join key（使用 1 次 map/reduce 任务计算）。Reduce 端会缓存 a 表和 b 表的记录，然后每次取得一个 c 表的记录就计算一次 join 结果，类似的还有：</p>
<p>  SELECT a.val, b.val, c.val FROM a</p>
<p>    JOIN b ON (a.key = b.key1) JOIN c ON (c.key = b.key2)</p>
<p><span style="font-family:宋体">这里用了</span> 2 次 map/reduce 任务。第一次缓存 a 表，用 b 表序列化<span style="font-family:宋体">；第二次缓存第一次</span> map/reduce 任务的结果，然后用 c 表序列化。</p>
<p> </p>
<p>4．LEFT，RIGHT 和 FULL OUTER 关键字用于处理 join 中空记录的情况。</p>
<p>例如：</p>
<p>  SELECT a.val, b.val FROM a LEFT OUTER</p>
<p>    JOIN b ON (a.key=b.key)</p>
<p><span style="font-family:宋体">对应所有</span> a 表中的记录都有一条记录输出。输出的结果应该是 a.val, b.val，当 a.key=b.key 时，而当 b.key 中找不到等值的 a.key 记录时也会输出 a.val, NULL。“FROM a LEFT OUTER JOIN b”这句一定要写在同一行——意思是 a 表在 b 表的<strong>左边</strong><span style="font-family:宋体">，所以</span> a 表中的所有记录都被保留了；“a
 RIGHT OUTER JOIN b”会保留所有 b 表的记录。OUTER JOIN 语义应该是遵循标准 SQL spec的。</p>
<p>Join 发生在 WHERE 子句<strong>之前</strong><span style="font-family:宋体">。如果你想限制</span> join 的输出，应该在 WHERE 子句中写过滤条件——或是在 join 子句中写。这里面一个容易混淆的问题是表分区的情况：</p>
<p>  SELECT a.val, b.val FROM a</p>
<p>  LEFT OUTER JOIN b ON (a.key=b.key)</p>
<p>  WHERE a.ds='2009-07-07' AND b.ds='2009-07-07'</p>
<p><span style="font-family:宋体">会</span> join a 表到 b 表（OUTER JOIN），列出 a.val 和 b.val 的记录。WHERE 从句中可以使用其他列作为过滤条件。但是，如前所述，如果 b 表中找不到对应 a 表的记录，b 表的所有列都会列出 NULL，<strong><span style="font-family:宋体">包括</span> ds 列</strong><span style="font-family:宋体">。也就是说，</span>join
 会过滤 b 表中不能找到匹配 a 表 join key 的所有记录。这样的话，LEFT OUTER 就使得查询结果与 WHERE 子句无关了。解决的办法是在 OUTER JOIN 时使用以下语法：</p>
<p>  SELECT a.val, b.val FROM a LEFT OUTER JOIN b</p>
<p>  ON (a.key=b.key AND</p>
<p>      b.ds='2009-07-07' AND</p>
<p>      a.ds='2009-07-07')</p>
<p><span style="font-family:宋体">这一查询的结果是预先在</span> join 阶段过滤过的，所以不会存在上述问题。这一逻辑也可以应用于 RIGHT 和 FULL 类型的 join 中。</p>
<p>Join 是不能交换位置的。无论是 LEFT 还是 RIGHT join，都是左连接的。</p>
<p>  SELECT a.val1, a.val2, b.val, c.val</p>
<p>  FROM a</p>
<p>  JOIN b ON (a.key = b.key)</p>
<p>  LEFT OUTER JOIN c ON (a.key = c.key)</p>
<p><span style="font-family:宋体">先</span> join a 表到 b 表，丢弃掉所有 join key 中不匹配的记录，然后用这一中间结果和 c 表做 join。这一表述有一个不太明显的问题，就是当一个 key 在 a 表和 c 表都存在，但是 b 表中不存在的时候：整个记录在第一次 join，即 a JOIN b 的时候都被丢掉了（包括a.val1，a.val2和a.key），然后我们再和 c 表 join 的时候，如果 c.key 与 a.key 或 b.key 相等，就会得到这样的结果：NULL,
 NULL, NULL, c.val。</p>
<p> </p>
<p>5．LEFT SEMI JOIN <span style="font-family:宋体">是</span> IN/EXISTS 子查询的一种更高效的实现。Hive 当前没有实现 IN/EXISTS 子查询，所以你可以用 LEFT SEMI JOIN 重写你的子查询语句。LEFT SEMI JOIN 的限制是， JOIN 子句中右边的表只能在 ON 子句中设置过滤条件，在 WHERE 子句、SELECT 子句或其他地方过滤都不行。</p>
<p>  SELECT a.key, a.value</p>
<p>  FROM a</p>
<p>  WHERE a.key in</p>
<p>   (SELECT b.key</p>
<p>    FROM B);</p>
<p>可以被重写为：</p>
<p>   SELECT a.key, a.val</p>
<p>   FROM a LEFT SEMI JOIN b on (a.key = b.key)</p>
<p> </p>
<h1><a target="_blank" name="_Toc280791040"></a>5. <strong>HIVE<span style="font-family:宋体">参数设置</span></strong></h1>
<p>    <span style="font-family:宋体">开发</span>Hive<span style="font-family:宋体">应用时，不可避免地需要设定</span>Hive<span style="font-family:宋体">的参数。设定</span>Hive<span style="font-family:宋体">的参数可以调优</span>HQL<span style="font-family:宋体">代码的执行效率，或帮助定位问题。然而实践中经常遇到的一个问题是，为什么设定的参数没有起作用？</span></p>
<p><span style="font-family:宋体">这通常是错误的设定方式导致的。</span></p>
<p><strong><span style="color:rgb(192,0,0)"><span style="font-family:宋体">对于一般参数，有以下三种设定方式：</span></span></strong></p>
<p><span style="color:rgb(192,0,0)">· </span><strong><span style="color:rgb(192,0,0)"><span style="font-family:宋体">配置文件</span></span><span style="color:rgb(192,0,0)"> </span></strong></p>
<p><span style="color:rgb(192,0,0)">· </span><strong><span style="color:rgb(192,0,0)"><span style="font-family:宋体">命令行参数</span></span><span style="color:rgb(192,0,0)"> </span></strong></p>
<p><span style="color:rgb(192,0,0)">· </span><strong><span style="color:rgb(192,0,0)"><span style="font-family:宋体">参数声明</span></span><span style="color:rgb(192,0,0)"> </span></strong></p>
<p><strong><span style="font-family:宋体">配置文件</span></strong><span style="font-family:宋体">：</span>Hive<span style="font-family:宋体">的配置文件包括</span></p>
<p>· <span style="font-family:宋体">用户自定义配置文件：</span>$HIVE_CONF_DIR/hive-site.xml </p>
<p>· <span style="font-family:宋体">默认配置文件：</span>$HIVE_CONF_DIR/hive-default.xml </p>
<p><span style="font-family:宋体">用户自定义配置会覆盖默认配置。另外，</span>Hive<span style="font-family:宋体">也会读入</span>Hadoop<span style="font-family:宋体">的配置，因为</span>Hive<span style="font-family:宋体">是作为</span>Hadoop<span style="font-family:宋体">的客户端启动的，</span>Hadoop<span style="font-family:宋体">的配置文件包括</span></p>
<p>· $HADOOP_CONF_DIR/hive-site.xml </p>
<p>· $HADOOP_CONF_DIR/hive-default.xml </p>
<p>Hive<span style="font-family:宋体">的配置会覆盖</span>Hadoop<span style="font-family:宋体">的配置。</span></p>
<p><span style="font-family:宋体">配置文件的设定对本机启动的所有</span>Hive<span style="font-family:宋体">进程都有效。</span></p>
<p><strong><span style="font-family:宋体">命令行参数</span></strong><span style="font-family:宋体">：启动</span>Hive<span style="font-family:宋体">（客户端或</span>Server<span style="font-family:宋体">方式）时，可以在命令行添加</span>-hiveconf param=value<span style="font-family:宋体">来设定参数，例如：</span></p>
<p>bin/hive -hiveconf hive.root.logger=INFO,console</p>
<p><span style="font-family:宋体">这一设定对本次启动的</span>Session<span style="font-family:宋体">（对于</span>Server<span style="font-family:宋体">方式启动，则是所有请求的</span>Sessions<span style="font-family:宋体">）有效。</span></p>
<p><strong><span style="font-family:宋体">参数声明</span></strong><span style="font-family:宋体">：可以在</span>HQL<span style="font-family:宋体">中使用</span>SET<span style="font-family:宋体">关键字设定参数，例如：</span></p>
<p>set mapred.reduce.tasks=100;</p>
<p><span style="font-family:宋体">这一设定的作用域也是</span>Session<span style="font-family:宋体">级的。</span></p>
<p><span style="font-family:宋体">上述三种设定方式的优先级依次递增。即参数声明覆盖命令行参数，命令行参数覆盖配置文件设定。注意某些系统级的参数，例如</span>log4j<span style="font-family:宋体">相关的设定，必须用前两种方式设定，因为那些参数的读取在</span>Session<span style="font-family:宋体">建立以前已经完成了。</span></p>
<p><span style="font-family:宋体">另外，</span>SerDe<span style="font-family:宋体">参数</span><span style="font-family:宋体">必须写在</span>DDL<span style="font-family:宋体">（建表）语句中。例如：</span></p>
<p>create table if not exists t_dummy(</p>
<p>dummy string</p>
<p>)</p>
<p>ROW FORMAT SERDE 'org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe'</p>
<p>WITH SERDEPROPERTIES (</p>
<p>'field.delim'='\t',</p>
<p>'escape.delim'='\\',</p>
<p>'serialization.null.format'=' '</p>
<p>) STORED AS TEXTFILE;</p>
<p><span style="font-family:宋体">类似</span>serialization.null.format<span style="font-family:宋体">这样的参数，必须和某个表或分区关联。在</span>DDL<span style="font-family:宋体">外部声明将不起作用。</span></p>
<p> </p>
<h1><a target="_blank" name="_Toc280791041"></a>6. <strong>HIVE UDF</strong></h1>
<h2><a target="_blank" name="_Toc280791042"></a>6.1 <strong>基本函数</strong></h2>
<p style="background:rgb(243,245,247)">SHOW FUNCTIONS;</p>
<p style="background:rgb(243,245,247)">DESCRIBE FUNCTION &lt;function_name&gt;;</p>
<h3><a target="_blank" name="_Toc280791043"></a>6.1.1 <strong>关系操作符</strong></h3>
<table>
<tbody>
<tr>
<td valign="center">
<p><strong>Operator</strong> </p>
</td>
<td valign="center">
<p><strong>Operand types</strong> </p>
</td>
<td valign="center">
<p><strong>Description</strong> </p>
</td>
</tr>
<tr>
<td valign="center">
<p>A = B </p>
</td>
<td valign="center">
<p>All primitive types </p>
</td>
<td valign="center">
<p>TRUE if expression A is equal to expression B otherwise FALSE </p>
</td>
</tr>
<tr>
<td valign="center">
<p>A == B </p>
</td>
<td valign="center">
<p>None! </p>
</td>
<td valign="center">
<p>Fails because of invalid syntax. SQL uses =, not == </p>
</td>
</tr>
<tr>
<td valign="center">
<p>A &lt;&gt; B </p>
</td>
<td valign="center">
<p>All primitive types </p>
</td>
<td valign="center">
<p>NULL if A or B is NULL, TRUE if expression A is NOT equal to expression B otherwise FALSE
</p>
</td>
</tr>
<tr>
<td valign="center">
<p>A &lt; B </p>
</td>
<td valign="center">
<p>All primitive types </p>
</td>
<td valign="center">
<p>NULL if A or B is NULL, TRUE if expression A is less than expression B otherwise FALSE
</p>
</td>
</tr>
<tr>
<td valign="center">
<p>A &lt;= B </p>
</td>
<td valign="center">
<p>All primitive types </p>
</td>
<td valign="center">
<p>NULL if A or B is NULL, TRUE if expression A is less than or equal to expression B otherwise FALSE
</p>
</td>
</tr>
<tr>
<td valign="center">
<p>A &gt; B </p>
</td>
<td valign="center">
<p>All primitive types </p>
</td>
<td valign="center">
<p>NULL if A or B is NULL, TRUE if expression A is greater than expression B otherwise FALSE
</p>
</td>
</tr>
<tr>
<td valign="center">
<p>A &gt;= B </p>
</td>
<td valign="center">
<p>All primitive types </p>
</td>
<td valign="center">
<p>NULL if A or B is NULL, TRUE if expression A is greater than or equal to expression B otherwise FALSE
</p>
</td>
</tr>
<tr>
<td valign="center">
<p>A IS NULL </p>
</td>
<td valign="center">
<p>all types </p>
</td>
<td valign="center">
<p>TRUE if expression A evaluates to NULL otherwise FALSE </p>
</td>
</tr>
<tr>
<td valign="center">
<p>A IS NOT NULL </p>
</td>
<td valign="center">
<p>All types </p>
</td>
<td valign="center">
<p>TRUE if expression A evaluates to NULL otherwise FALSE </p>
</td>
</tr>
<tr>
<td valign="center">
<p>A LIKE B </p>
</td>
<td valign="center">
<p>strings </p>
</td>
<td valign="center">
<p>NULL if A or B is NULL, TRUE if string A matches the SQL simple regular expression B, otherwise FALSE. The comparison is done character by character. The _ character in B matches any character in A(similar to . in posix regular expressions) while the % character
 in B matches an arbitrary number of characters in A(similar to .* in posix regular expressions) e.g. 'foobar' like 'foo' evaluates to FALSE where as 'foobar' like 'foo_ _ _' evaluates to TRUE and so does 'foobar' like 'foo%'
</p>
</td>
</tr>
<tr>
<td valign="center">
<p>A RLIKE B </p>
</td>
<td valign="center">
<p>strings </p>
</td>
<td valign="center">
<p>NULL if A or B is NULL, TRUE if string A matches the Java regular expression B(See Java regular expressions syntax), otherwise FALSE e.g. 'foobar' rlike 'foo' evaluates to FALSE where as 'foobar' rlike '^f.*r$' evaluates to TRUE
</p>
</td>
</tr>
<tr>
<td valign="center">
<p>A REGEXP B </p>
</td>
<td valign="center">
<p>strings </p>
</td>
<td valign="center">
<p>Same as RLIKE </p>
</td>
</tr>
</tbody>
</table>
<h3><a target="_blank" name="_Toc280791044"></a>6.1.2 <strong>代数操作符</strong></h3>
<p><span style="font-family:宋体">返回数字类型，如果任意一个操作符为</span>NULL<span style="font-family:宋体">，则结果为</span><span style="font-family:Arial">NULL</span></p>
<table>
<tbody>
<tr>
<td valign="center">
<p><strong>Operator</strong> </p>
</td>
<td valign="center">
<p><strong>Operand types</strong> </p>
</td>
<td valign="center">
<p><strong>Description</strong> </p>
</td>
</tr>
<tr>
<td valign="center">
<p>A + B </p>
</td>
<td valign="center">
<p>All number types </p>
</td>
<td valign="center">
<p>Gives the result of adding A and B. The type of the result is the same as the common parent(in the type hierarchy) of the types of the operands. e.g. since every integer is a float, therefore float is a containing type of integer so the + operator on a float
 and an int will result in a float. </p>
</td>
</tr>
<tr>
<td valign="center">
<p>A - B </p>
</td>
<td valign="center">
<p>All number types </p>
</td>
<td valign="center">
<p>Gives the result of subtracting B from A. The type of the result is the same as the common parent(in the type hierarchy) of the types of the operands.
</p>
</td>
</tr>
<tr>
<td valign="center">
<p>A * B </p>
</td>
<td valign="center">
<p>All number types </p>
</td>
<td valign="center">
<p>Gives the result of multiplying A and B. The type of the result is the same as the common parent(in the type hierarchy) of the types of the operands. Note that if the multiplication causing overflow, you will have to cast one of the operators to a type higher
 in the type hierarchy. </p>
</td>
</tr>
<tr>
<td valign="center">
<p>A / B </p>
</td>
<td valign="center">
<p>All number types </p>
</td>
<td valign="center">
<p>Gives the result of dividing B from A. The result is a double type. </p>
</td>
</tr>
<tr>
<td valign="center">
<p>A % B </p>
</td>
<td valign="center">
<p>All number types </p>
</td>
<td valign="center">
<p>Gives the reminder resulting from dividing A by B. The type of the result is the same as the common parent(in the type hierarchy) of the types of the operands.
</p>
</td>
</tr>
<tr>
<td valign="center">
<p>A &amp; B </p>
</td>
<td valign="center">
<p>All number types </p>
</td>
<td valign="center">
<p>Gives the result of bitwise AND of A and B. The type of the result is the same as the common parent(in the type hierarchy) of the types of the operands.
</p>
</td>
</tr>
<tr>
<td valign="center">
<p>A | B </p>
</td>
<td valign="center">
<p>All number types </p>
</td>
<td valign="center">
<p>Gives the result of bitwise OR of A and B. The type of the result is the same as the common parent(in the type hierarchy) of the types of the operands.
</p>
</td>
</tr>
<tr>
<td valign="center">
<p>A ^ B </p>
</td>
<td valign="center">
<p>All number types </p>
</td>
<td valign="center">
<p>Gives the result of bitwise XOR of A and B. The type of the result is the same as the common parent(in the type hierarchy) of the types of the operands.
</p>
</td>
</tr>
<tr>
<td valign="center">
<p>~A </p>
</td>
<td valign="center">
<p>All number types </p>
</td>
<td valign="center">
<p>Gives the result of bitwise NOT of A. The type of the result is the same as the type of A.
</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<h3><a target="_blank" name="_Toc280791045"></a>6.1.3 <strong><span style="font-family:宋体">逻辑操作符</span></strong></h3>
<h3><a target="_blank" name="_Toc280791046"></a>6.1.4 <strong>复杂类型操作符</strong></h3>
<table>
<tbody>
<tr>
<td valign="center">
<p>Constructor Function </p>
</td>
<td valign="center">
<p>Operands </p>
</td>
<td valign="center">
<p>Description </p>
</td>
</tr>
<tr>
<td valign="center">
<p>Map</p>
</td>
<td valign="center">
<p>(key1, value1, key2, value2, ...)</p>
</td>
<td valign="center">
<p>Creates a map with the given key/value pairs</p>
</td>
</tr>
<tr>
<td valign="center">
<p>Struct</p>
</td>
<td valign="center">
<p>(val1, val2, val3, ...)</p>
</td>
<td valign="center">
<p>Creates a struct with the given field values. Struct field names will be col1, col2, ...</p>
</td>
</tr>
<tr>
<td valign="center">
<p>Array</p>
</td>
<td valign="center">
<p>(val1, val2, ...)</p>
</td>
<td valign="center">
<p>Creates an array with the given elements</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<h3><a target="_blank" name="_Toc280791047"></a>6.1.5 <strong><span style="font-family:宋体">内建函数</span></strong></h3>
<h3><a target="_blank" name="_Toc280791048"></a>6.1.6 <strong><span style="font-family:宋体">数学函数</span> </strong></h3>
<h3><a target="_blank" name="_Toc280791049"></a>6.1.7 <strong><span style="font-family:宋体">集合函数</span></strong></h3>
<h3><a target="_blank" name="_Toc280791050"></a>6.1.8 <strong><span style="font-family:宋体">类型转换</span></strong></h3>
<p> </p>
<h3><a target="_blank" name="_Toc280791051"></a>6.1.9 <strong><span style="font-family:宋体">日期函数</span></strong></h3>
<table>
<tbody>
<tr>
<td valign="center">
<p>返回值类型 </p>
</td>
<td valign="center">
<p>名称 </p>
</td>
<td valign="center">
<p>描述 </p>
</td>
</tr>
<tr>
<td valign="center">
<p>string </p>
</td>
<td valign="center">
<p>from_unixtime(int unixtime) </p>
</td>
<td valign="center">
<p>将时间戳（unix epoch秒数）转换为日期时间字符串，例如from_unixtime(0)="1970-01-01 00:00:00" </p>
</td>
</tr>
<tr>
<td valign="center">
<p>bigint </p>
</td>
<td valign="center">
<p>unix_timestamp() </p>
</td>
<td valign="center">
<p>获得当前时间戳 </p>
</td>
</tr>
<tr>
<td valign="center">
<p>bigint </p>
</td>
<td valign="center">
<p>unix_timestamp(string date) </p>
</td>
<td valign="center">
<p>获得date表示的时间戳 </p>
</td>
</tr>
<tr>
<td valign="center">
<p>bigint </p>
</td>
<td valign="center">
<p>to_date(string timestamp) </p>
</td>
<td valign="center">
<p>返回日期字符串，例如to_date("1970-01-01 00:00:00") = "1970-01-01" </p>
</td>
</tr>
<tr>
<td valign="center">
<p>string </p>
</td>
<td valign="center">
<p>year(string date) </p>
</td>
<td valign="center">
<p>返回年，例如year("1970-01-01 00:00:00") = 1970，year("1970-01-01") = 1970 </p>
</td>
</tr>
<tr>
<td valign="center">
<p>int </p>
</td>
<td valign="center">
<p>month(string date) </p>
</td>
<td valign="center">
<p>　</p>
</td>
</tr>
<tr>
<td valign="center">
<p>int </p>
</td>
<td valign="center">
<p>day(string date) dayofmonth(date)</p>
</td>
<td valign="center">
<p>　</p>
</td>
</tr>
<tr>
<td valign="center">
<p>int </p>
</td>
<td valign="center">
<p>hour(string date) </p>
</td>
<td valign="center">
<p>　</p>
</td>
</tr>
<tr>
<td valign="center">
<p>int </p>
</td>
<td valign="center">
<p>minute(string date) </p>
</td>
<td valign="center">
<p>　</p>
</td>
</tr>
<tr>
<td valign="center">
<p>int </p>
</td>
<td valign="center">
<p>second(string date) </p>
</td>
<td valign="center">
<p>　</p>
</td>
</tr>
<tr>
<td valign="center">
<p>int </p>
</td>
<td valign="center">
<p>weekofyear(string date) </p>
</td>
<td valign="center">
<p>　</p>
</td>
</tr>
<tr>
<td valign="center">
<p>int </p>
</td>
<td valign="center">
<p>datediff(string enddate, string startdate) </p>
</td>
<td valign="center">
<p>返回enddate和startdate的天数的差，例如datediff('2009-03-01', '2009-02-27') = 2 </p>
</td>
</tr>
<tr>
<td valign="center">
<p>int </p>
</td>
<td valign="center">
<p>date_add(string startdate, int days) </p>
</td>
<td valign="center">
<p>加days天数到startdate: date_add('2008-12-31', 1) = '2009-01-01' </p>
</td>
</tr>
<tr>
<td valign="center">
<p>int </p>
</td>
<td valign="center">
<p>date_sub(string startdate, int days) </p>
</td>
<td valign="center">
<p>减days天数到startdate: date_sub('2008-12-31', 1) = '2008-12-30' </p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<h3><a target="_blank" name=".E6.9D.A1.E4.BB.B6.E5.87.BD.E6.95.B0"></a>6.1.10 <strong><a target="_blank" name="_Toc280791052"><span style="font-family:宋体">条件函数</span></a> </strong></h3>
<table>
<tbody>
<tr>
<td valign="center">
<p>返回值类型 </p>
</td>
<td valign="center">
<p>名称 </p>
</td>
<td valign="center">
<p>描述 </p>
</td>
</tr>
<tr>
<td valign="center">
<p>- </p>
</td>
<td valign="center">
<p>if(boolean testCondition, T valueTrue, T valueFalseOrNull) </p>
</td>
<td valign="center">
<p>当testCondition为真时返回valueTrue，testCondition为假或NULL时返回valueFalseOrNull </p>
</td>
</tr>
<tr>
<td valign="center">
<p>- </p>
</td>
<td valign="center">
<p>COALESCE(T v1, T v2, ...) </p>
</td>
<td valign="center">
<p>返回列表中的第一个非空元素，如果列表元素都为空则返回NULL </p>
</td>
</tr>
<tr>
<td valign="center">
<p>- </p>
</td>
<td valign="center">
<p>CASE a WHEN b THEN c [WHEN d THEN e]* [ELSE f] END </p>
</td>
<td valign="center">
<p>a = b，返回c；a = d，返回e；否则返回f </p>
</td>
</tr>
<tr>
<td valign="center">
<p>- </p>
</td>
<td valign="center">
<p>CASE WHEN a THEN b [WHEN c THEN d]* [ELSE e] END </p>
</td>
<td valign="center">
<p>a 为真，返回b；c为真，返回d；否则e </p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<h3><a target="_blank" name=".E5.AD.97.E7.AC.A6.E4.B8.B2.E5.87.BD.E6."></a>6.1.11 <strong><a target="_blank" name="_Toc280791053"><span style="font-family:宋体">字符串函数</span></a> </strong></h3>
<p>The following are built-in String functions are supported in hive: </p>
<table>
<tbody>
<tr>
<td valign="top">
<p>返回值类型</p>
</td>
<td valign="top">
<p>名称<span style="font-family:Times New Roman"> </span></p>
</td>
<td valign="top">
<p><strong>描述</strong></p>
</td>
</tr>
<tr>
<td valign="top">
<p>Int</p>
</td>
<td valign="top">
<p>length(string A)</p>
</td>
<td valign="top">
<p>返回字符串长度</p>
</td>
</tr>
<tr>
<td valign="top">
<p>String</p>
</td>
<td valign="top">
<p>reverse(string A)</p>
</td>
<td valign="top">
<p>反转字符串</p>
</td>
</tr>
<tr>
<td valign="top">
<p>String</p>
</td>
<td valign="top">
<p>concat(string A, string B...)</p>
</td>
<td valign="top">
<p>合并字符串，例如<span style="font-family:Times New Roman">concat('foo', 'bar')='foobar'</span><span style="font-family:宋体">。注意这一函数可以接受任意个数的参数</span></p>
</td>
</tr>
<tr>
<td valign="top">
<p>String</p>
</td>
<td valign="top">
<p>substr(string A, int start) substring(string A, int start)</p>
</td>
<td valign="top">
<p>返回子串，例如<span style="font-family:Times New Roman">substr('foobar', 4)='bar'</span></p>
</td>
</tr>
<tr>
<td valign="top">
<p>String</p>
</td>
<td valign="top">
<p>substr(string A, int start, int len) substring(string A, int start, int len)</p>
</td>
<td valign="top">
<p>返回限定长度的子串，例如<span style="font-family:Times New Roman">substr('foobar', 4, 1)='b'</span></p>
</td>
</tr>
<tr>
<td valign="top">
<p>String</p>
</td>
<td valign="top">
<p>upper(string A) ucase(string A)</p>
</td>
<td valign="top">
<p>转换为大写</p>
</td>
</tr>
<tr>
<td valign="top">
<p>String</p>
</td>
<td valign="top">
<p>lower(string A) lcase(string A)</p>
</td>
<td valign="top">
<p>转换为小写</p>
</td>
</tr>
<tr>
<td valign="top">
<p>String</p>
</td>
<td valign="top">
<p>trim(string A)</p>
</td>
<td valign="top">
<p>　</p>
</td>
</tr>
<tr>
<td valign="top">
<p>String</p>
</td>
<td valign="top">
<p>ltrim(string A)</p>
</td>
<td valign="top">
<p>　</p>
</td>
</tr>
<tr>
<td valign="top">
<p>String</p>
</td>
<td valign="top">
<p>rtrim(string A)</p>
</td>
<td valign="top">
<p>　</p>
</td>
</tr>
<tr>
<td valign="top">
<p>String</p>
</td>
<td valign="top">
<p>regexp_replace(string A, string B, string C)</p>
</td>
<td valign="top">
<p>Returns the string resulting from replacing all substrings in B that match the Java regular expression syntax(See Java regular expressions syntax) with C e.g. regexp_replace("foobar", "oo|ar", "") returns 'fb.' Note that some care is necessary in using predefined
 character classes: using '\s' as the second argument will match the letter s; '\\s' is necessary to match whitespace, etc.</p>
</td>
</tr>
<tr>
<td valign="top">
<p>String</p>
</td>
<td valign="top">
<p>regexp_extract(string subject, string pattern, int intex)</p>
</td>
<td valign="top">
<p>返回使用正则表达式提取的子字串。例如，<span style="font-family:Times New Roman">regexp_extract('foothebar', 'foo(.*?)(bar)', 2)='bar'</span><span style="font-family:宋体">。注意使用特殊字符的规则：使用</span><span style="font-family:Times New Roman">'\s'</span><span style="font-family:宋体">代表的是字符</span><span style="font-family:Times New Roman">'s'</span><span style="font-family:宋体">；空白字符需要使用</span><span style="font-family:Times New Roman">'\\s'</span><span style="font-family:宋体">，以此类推。</span></p>
</td>
</tr>
<tr>
<td valign="top" rowspan="9">
<p>String</p>
</td>
<td valign="top" rowspan="9">
<p>parse_url(string urlString, string partToExtract)</p>
</td>
<td valign="top">
<p>解析<span style="font-family:Times New Roman">URL</span><span style="font-family:宋体">字符串，</span><span style="font-family:Times New Roman">partToExtract</span><span style="font-family:宋体">的可选项有：</span><span style="font-family:Times New Roman">HOST, PATH, QUERY,
 REF, PROTOCOL, FILE, AUTHORITY, USERINFO</span><span style="font-family:宋体">。</span></p>
</td>
</tr>
<tr>
<td valign="top">
<p>例如，</p>
</td>
</tr>
<tr>
<td valign="top">
<p>parse_url('http://facebook.com/path/p1.php?query=1', 'HOST')='facebook.com'</p>
</td>
</tr>
<tr>
<td valign="top">
<p>parse_url('http://facebook.com/path/p1.php?query=1', 'PATH')='/path/p1.php'</p>
</td>
</tr>
<tr>
<td valign="top">
<p>parse_url('http://facebook.com/path/p1.php?query=1', 'QUERY')='query=1'<span style="font-family:宋体">，可以指定</span><span style="font-family:Times New Roman">key</span><span style="font-family:宋体">来返回特定参数，</span><span style="font-family:Times New Roman">key</span><span style="font-family:宋体">的格式是</span><span style="font-family:Times New Roman">QUERY:&lt;KEY_NAME&gt;</span><span style="font-family:宋体">，例如</span><span style="font-family:Times New Roman">QUERY:k1</span></p>
</td>
</tr>
<tr>
<td valign="top">
<p>parse_url('http://facebook.com/path/p1.php?query=1&amp;field=2','QUERY','query')='1'<span style="font-family:宋体">可以用来取出外部渲染参数</span><span style="font-family:Times New Roman">key</span><span style="font-family:宋体">对应的</span><span style="font-family:Times New Roman">value</span><span style="font-family:宋体">值</span></p>
</td>
</tr>
<tr>
<td valign="top">
<p>parse_url('http://facebook.com/path/p1.php?query=1&amp;field=2','QUERY','field')='2'</p>
</td>
</tr>
<tr>
<td valign="top">
<p>parse_url('http://facebook.com/path/p1.php?query=1#Ref', 'REF')='Ref'</p>
</td>
</tr>
<tr>
<td valign="top">
<p>parse_url('http://facebook.com/path/p1.php?query=1#Ref', 'PROTOCOL')='http'</p>
</td>
</tr>
<tr>
<td valign="top" rowspan="5">
<p>String</p>
</td>
<td valign="top" rowspan="5">
<p>get_json_object(string json_string, string path)</p>
</td>
<td valign="top">
<p>解析<span style="font-family:Times New Roman">json</span><span style="font-family:宋体">字符串。若源</span><span style="font-family:Times New Roman">json</span><span style="font-family:宋体">字符串非法则返回</span><span style="font-family:Times New Roman">NULL</span><span style="font-family:宋体">。</span><span style="font-family:Times New Roman">path</span><span style="font-family:宋体">参数支持</span><span style="font-family:Times New Roman">JSONPath</span><span style="font-family:宋体">的一个子集，包括以下标记：</span></p>
</td>
</tr>
<tr>
<td valign="top">
<p>$: Root object</p>
</td>
</tr>
<tr>
<td valign="top">
<p>[]: Subscript operator for array</p>
</td>
</tr>
<tr>
<td valign="top">
<p>&amp;: Wildcard for []</p>
</td>
</tr>
<tr>
<td valign="top">
<p>.: Child operator</p>
</td>
</tr>
<tr>
<td valign="top">
<p>String</p>
</td>
<td valign="top">
<p>space(int n)</p>
</td>
<td valign="top">
<p>返回一个包含<span style="font-family:Times New Roman">n</span><span style="font-family:宋体">个空格的字符串</span></p>
</td>
</tr>
<tr>
<td valign="top">
<p>String</p>
</td>
<td valign="top">
<p>repeat(string str, int n)</p>
</td>
<td valign="top">
<p>重复<span style="font-family:Times New Roman">str</span><span style="font-family:宋体">字符串</span><span style="font-family:Times New Roman">n</span><span style="font-family:宋体">遍</span></p>
</td>
</tr>
<tr>
<td valign="top">
<p>String</p>
</td>
<td valign="top">
<p>ascii(string str)</p>
</td>
<td valign="top">
<p>返回<span style="font-family:Times New Roman">str</span><span style="font-family:宋体">中第一个字符的</span><span style="font-family:Times New Roman">ascii</span><span style="font-family:宋体">码</span></p>
</td>
</tr>
<tr>
<td valign="top">
<p>String</p>
</td>
<td valign="top">
<p>lpad(string str, int len, string pad)</p>
</td>
<td valign="top">
<p>左端补齐<span style="font-family:Times New Roman">str</span><span style="font-family:宋体">到长度为</span><span style="font-family:Times New Roman">len</span><span style="font-family:宋体">。补齐的字符串由</span><span style="font-family:Times New Roman">pad</span><span style="font-family:宋体">指定。</span></p>
</td>
</tr>
<tr>
<td valign="top">
<p>String</p>
</td>
<td valign="top">
<p>rpad(string str, int len, string pad)</p>
</td>
<td valign="top">
<p>右端补齐<span style="font-family:Times New Roman">str</span><span style="font-family:宋体">到长度为</span><span style="font-family:Times New Roman">len</span><span style="font-family:宋体">。补齐的字符串由</span><span style="font-family:Times New Roman">pad</span><span style="font-family:宋体">指定。</span></p>
</td>
</tr>
<tr>
<td valign="top">
<p>Array</p>
</td>
<td valign="top">
<p><span style="background:rgb(255,255,0)">split(string str, string pat)</span></p>
</td>
<td valign="top">
<p><span style="background:rgb(255,255,0)">返回使用<span style="font-family:Times New Roman">pat</span><span style="font-family:宋体">作为正则表达式分割</span><span style="font-family:Times New Roman">str</span><span style="font-family:宋体">字符串的列表。例如，</span><span style="font-family:Times New Roman">split('foobar',
 'o')[2] = 'bar'</span><span style="font-family:宋体">。？不是很明白这个结果</span></span></p>
</td>
</tr>
<tr>
<td valign="top">
<p>Int</p>
</td>
<td valign="top">
<p>find_in_set(string str, string strList)</p>
</td>
<td valign="top">
<p>Returns the first occurance of str in strList where strList is a comma-delimited string. Returns null if either argument is null. Returns 0 if the first argument contains any commas. e.g. find_in_set('ab', 'abc,b,ab,c,def') returns 3</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<h2><a target="_blank" name="_Toc280791054"></a>6.2 <strong>UDTF</strong></h2>
<p>UDTF<span style="font-family:宋体">即</span>Built-in Table-Generating Functions</p>
<p><span style="font-family:宋体">使用这些</span>UDTF<span style="font-family:宋体">函数有一些限制</span>:
</p>
<p>1<span style="font-family:宋体">、</span>SELECT<span style="font-family:宋体">里面不能有其它字段</span></p>
<p>如：SELECT pageid, explode(adid_list) AS myCol... </p>
<p>2<span style="font-family:宋体">、</span><span style="font-family:宋体">不能嵌套</span> </p>
<p>如：SELECT explode(explode(adid_list)) AS myCol...<span style="font-family:宋体">不支持</span></p>
<p>3<span style="font-family:宋体">、</span><span style="font-family:宋体">不支持</span>GROUP BY / CLUSTER BY / DISTRIBUTE BY / SORT BY
</p>
<p>如：SELECT explode(adid_list) AS myCol ... GROUP BY myCol </p>
<p> </p>
<h3><a target="_blank" name="_Toc280791055"></a>6.2.1 <strong>Explode</strong></h3>
<p>将数组进行转置</p>
<p>例如：</p>
<p>1<span style="font-family:宋体">、</span>create table test2(mycol array&lt;int&gt;);</p>
<p>2<span style="font-family:宋体">、</span>insert OVERWRITE table test2 select * from (select array(1,2,3) from a union all select array(7,8,9)  from d)c;</p>
<p>3<span style="font-family:宋体">、</span>hive&gt; select * from test2;</p>
<p>OK</p>
<p>[1,2,3]</p>
<p>[7,8,9]</p>
<p>3、 hive&gt; SELECT explode(myCol) AS myNewCol FROM test2;</p>
<p>OK</p>
<p>1</p>
<p>2</p>
<p>3</p>
<p>7</p>
<p>8</p>
<p>9</p>
<p><br clear="all">
</p>
<p> </p>
<h1><a target="_blank" name="_Toc280791056"></a>7. <strong>HIVE <span style="font-family:宋体">
的</span><span style="font-family:Calibri">MAP/REDUCE</span></strong></h1>
<h2><a target="_blank" name="_Toc280791057"></a>7.1 JOIN <strong></strong></h2>
<p><span style="font-family:宋体">对于</span> JOIN 操作： </p>
<table>
<tbody>
<tr>
<td valign="center" style="background:rgb(255,250,205)">
<p>INSERT OVERWRITE TABLE pv_users </p>
<p>SELECT pv.pageid, u.age FROM page_view pv JOIN user u ON (pv.userid = u.userid);
</p>
</td>
</tr>
</tbody>
</table>
<p><span style="font-family:宋体">实现过程为：</span> </p>
<p>· Map<span style="font-family:宋体">： </span></p>
<p>o <span style="font-family:宋体">以</span> JOIN ON <span style="font-family:宋体">条件中的列作为
</span><span style="font-family:Calibri">Key</span><span style="font-family:宋体">，如果有多个列，则
</span><span style="font-family:Calibri">Key </span><span style="font-family:宋体">是这些列的组合
</span></p>
<p>o <span style="font-family:宋体">以</span> JOIN <span style="font-family:宋体">之后所关心的列作为
</span><span style="font-family:Calibri">Value</span><span style="font-family:宋体">，当有多个列时，</span><span style="font-family:Calibri">Value
</span><span style="font-family:宋体">是这些列的组合。在 </span><span style="font-family:Calibri">Value
</span><span style="font-family:宋体">中还会包含表的 </span><span style="font-family:Calibri">Tag
</span><span style="font-family:宋体">信息，用于标明此 </span><span style="font-family:Calibri">Value
</span><span style="font-family:宋体">对应于哪个表。 </span></p>
<p>o <span style="font-family:宋体">按照</span> Key <span style="font-family:宋体">进行排序。
</span></p>
<p>· Shuffle<span style="font-family:宋体">： </span></p>
<p>o <span style="font-family:宋体">根据</span> Key <span style="font-family:宋体">的值进行
</span><span style="font-family:Calibri">Hash</span><span style="font-family:宋体">，并将
</span><span style="font-family:Calibri">Key/Value </span><span style="font-family:宋体">对按照
</span><span style="font-family:Calibri">Hash </span><span style="font-family:宋体">值推至不同对
</span><span style="font-family:Calibri">Reduce </span><span style="font-family:宋体">中。
</span></p>
<p>· Reduce<span style="font-family:宋体">： </span></p>
<p>o Reducer <span style="font-family:宋体">根据 </span><span style="font-family:Calibri">Key
</span><span style="font-family:宋体">值进行 </span><span style="font-family:Calibri">Join
</span><span style="font-family:宋体">操作，并且通过 </span><span style="font-family:Calibri">Tag
</span><span style="font-family:宋体">来识别不同的表中的数据。 </span></p>
<p><span style="font-family:宋体">具体实现过程如图：</span> </p>
<p> </p>
<h2><a target="_blank" name="GROUP_BY"></a>7.2 <a target="_blank" name="_Toc280791058">GROUP BY</a> <strong></strong></h2>
<table>
<tbody>
<tr>
<td valign="center" style="background:rgb(255,250,205)">
<p>SELECT pageid, age, count(1) FROM pv_users GROUP BY pageid, age; </p>
</td>
</tr>
</tbody>
</table>
<p><span style="font-family:宋体">具体实现过程如图：</span> </p>
<p> </p>
<h2><a target="_blank" name="DISTINCT"></a>7.3 <a target="_blank" name="_Toc280791059">DISTINCT</a> <strong></strong></h2>
<table>
<tbody>
<tr>
<td valign="center" style="background:rgb(255,250,205)">
<p>SELECT age, count(distinct pageid) FROM pv_users GROUP BY age; </p>
</td>
</tr>
</tbody>
</table>
<p><span style="font-family:宋体">实现过程如图：</span> </p>
<p> </p>
<p> </p>
<h1><a target="_blank" name="_Toc280791060"></a>8. <strong><span style="font-family:宋体">使用</span>HIVE<span style="font-family:宋体">注意点</span></strong></h1>
<h2><a target="_blank" name="_Toc280791061"></a>8.1 <strong>字符集</strong></h2>
<p>Hadoop和Hive都是用UTF-8编码的，所以, 所有中文必须是UTF-8编码, 才能正常使用</p>
<p><span style="font-family:宋体">备注：中文数据</span>load到表里面, 如果字符集不同，很有可能全是乱码需要做转码的, 但是hive本身没有函数来做这个</p>
<p> </p>
<h2><a target="_blank" name="_Toc280791062"></a>8.2 <strong>压缩</strong></h2>
<p>hive.exec.compress.output 这个参数, 默认是 false，但是很多时候貌似要单独显式设置一遍</p>
<p><span style="font-family:宋体">否则会对结果做压缩的，如果你的这个文件后面还要在</span>hadoop下直接操作, 那么就不能压缩了</p>
<p> </p>
<h2><a target="_blank" name="_Toc280791063"></a>8.3 <strong>count(distinct)</strong></h2>
<p><span style="font-family:宋体">当前的</span> Hive <span style="font-family:宋体">不支持在一条查询语句中有多</span> Distinct<span style="font-family:宋体">。如果要在</span> Hive
<span style="font-family:宋体">查询语句中实现多</span>Distinct<span style="font-family:宋体">，需要使用至少</span> n+1
<span style="font-family:宋体">条查询语句（</span>n<span style="font-family:宋体">为</span>distinct<span style="font-family:宋体">的数目），前</span> n
<span style="font-family:宋体">条查询分</span> <span style="font-family:宋体">别对</span> n
<span style="font-family:宋体">个列去重，最后一条查询语句对</span> n <span style="font-family:宋体">
个去重之后的列做</span> Join <span style="font-family:宋体">操作，得到最终结果。</span></p>
<p> </p>
<h2><a target="_blank" name="_Toc280791064"></a>8.4 <strong>JOIN</strong></h2>
<p>只支持等值连接</p>
<p> </p>
<h2><a target="_blank" name="_Toc280791065"></a>8.5 <strong>DML操作</strong></h2>
<p><span style="font-family:宋体">只支持</span>INSERT/LOAD<span style="font-family:宋体">操作，无</span><span style="font-family:Calibri">UPDATE</span><span style="font-family:宋体">和</span><span style="font-family:Calibri">DELTE</span></p>
<h2><a target="_blank" name="_Toc280791066"></a>8.6 <strong>HAVING</strong></h2>
<p><span style="font-family:宋体">不支持</span>HAVING<span style="font-family:宋体">操作。如果需要这个功能要嵌套一个子查询用</span><span style="font-family:Calibri">where</span><span style="font-family:宋体">限制</span> <span style="font-family:宋体">（此处错误，现在版本支持</span>having<span style="font-family:宋体">）</span></p>
<h2><a target="_blank" name="_Toc280791067"></a>8.7 <strong>子查询</strong></h2>
<p>Hive<span style="font-family:宋体">不支持</span><span style="font-family:Calibri">where</span><span style="font-family:宋体">子句中的子查询</span>（此处错误，现在版本支持）</p>
<p> </p>
<h2><a target="_blank" name="_Toc280791068"></a>8.8 <strong>Join中处理null值的语义区别</strong></h2>
<p>SQL<span style="font-family:宋体">标准中，任何对</span><span style="font-family:Calibri">null</span><span style="font-family:宋体">的操作（数值比较，字符串操作等）结果都为</span><span style="font-family:Calibri">null</span><span style="font-family:宋体">。</span><span style="font-family:Calibri">Hive</span><span style="font-family:宋体">对</span><span style="font-family:Calibri">null</span><span style="font-family:宋体">值处理的逻辑和标准基本一致，除了</span><span style="font-family:Calibri">Join</span><span style="font-family:宋体">时的特殊逻辑。</span></p>
<p><span style="font-family:宋体">这里的特殊逻辑指的是，</span>Hive<span style="font-family:宋体">的</span><span style="font-family:Calibri">Join</span><span style="font-family:宋体">中，作为</span><span style="font-family:Calibri">Join key</span><span style="font-family:宋体">的字段比较，</span><span style="font-family:Calibri">null=null</span><span style="font-family:宋体">是有意义的，且返回值为</span><span style="font-family:Calibri">true</span><span style="font-family:宋体">。检查以下查询：</span></p>
<p>select u.uid, count(u.uid) </p>
<p>from t_weblog l join t_user u on (l.uid = u.uid) group by u.uid;</p>
<p><span style="font-family:宋体">查询中，</span>t_weblog<span style="font-family:宋体">表中</span><span style="font-family:Calibri">uid</span><span style="font-family:宋体">为空的记录将和</span><span style="font-family:Calibri">t_user</span><span style="font-family:宋体">表中</span><span style="font-family:Calibri">uid</span><span style="font-family:宋体">为空的记录做连接，即</span><span style="font-family:Calibri">l.uid
 = u.uid=null</span><span style="font-family:宋体">成立。</span></p>
<p><span style="font-family:宋体">如果需要与标准一致的语义，我们需要改写查询手动过滤</span>null<span style="font-family:宋体">值的情况：</span></p>
<p>select u.uid, count(u.uid) </p>
<p>from t_weblog l join t_user u </p>
<p>on (l.uid = u.uid and l.uid is not null and u.uid is not null)</p>
<p>group by u.uid;</p>
<p>实践中，这一语义区别也是经常导致数据倾斜的原因之一。</p>
<p> </p>
<h2>8.9 <strong>分号字符</strong></h2>
<p><span style="font-family:宋体">分号是</span>SQL<span style="font-family:宋体">语句结束标记，在</span><span style="font-family:Calibri">HiveQL</span><span style="font-family:宋体">中也是，但是在</span><span style="font-family:Calibri">HiveQL</span><span style="font-family:宋体">中，对分号的识别没有那么智慧，例如：</span></p>
<p>select concat(cookie_id,concat(';',’zoo’)) from c02_clickstat_fatdt1 limit 2;</p>
<p>FAILED: Parse Error: line 0:-1 cannot recognize input '&lt;EOF&gt;' in function specification</p>
<p><span style="font-family:宋体">可以推断，</span>Hive解析语句的时候，只要遇到分号就认为语句结束，而无论是否用引号包含起来。</p>
<p><span style="font-family:宋体">解决的办法是，使用分号的八进制的</span>ASCII码进行转义，那么上述语句应写成： </p>
<p>select concat(cookie_id,concat('\073','zoo')) from c02_clickstat_fatdt1 limit 2;</p>
<p>为什么是<span style="font-family:宋体">八进制</span>ASCII码？</p>
<p>我<span style="font-family:宋体">尝试用十六进制的</span>ASCII码，但Hive会将其视为字符串处理并未转义，好像<span style="font-family:宋体">仅支持八进制，原因不详。这个规则也适用于其他非</span>SELECT语句，如CREATE TABLE中需要定义分隔符，那么对不可见字符做分隔符就需要用八进制的ASCII码来转义。
</p>
<p> </p>
<h2>8.10 <strong>Insert</strong></h2>
<h3>8.10.1 <strong>新增数据</strong></h3>
<p><span style="font-family:宋体">根据语法</span>Insert必须加“OVERWRITE”关键字，也就是说每一次插入都是一次重写。那如何实现表中新增数据呢？</p>
<p><span style="font-family:宋体">假设</span>Hive中有表htduan1, </p>
<p>hive&gt; DESCRIBE htduan1;</p>
<p>OK</p>
<p>id int</p>
<p>value int</p>
<p>hive&gt; SELECT * FROM htduan1;</p>
<p>OK</p>
<p>3 4</p>
<p>1 2</p>
<p>2 3</p>
<p><span style="font-family:宋体">现增加一条记录</span>: </p>
<p>hive&gt; INSERT OVERWRITE TABLE htduan1 </p>
<p>SELECT id, value FROM (</p>
<p>SELECT id, value FROM htduan1 </p>
<p>UNION ALL </p>
<p>SELECT 4 AS id, 5 AS value FROM htduan1 limit 1</p>
<p>) u;</p>
<p><span style="font-family:宋体">结果是</span>: </p>
<p>hive&gt;SELECT * FROM p1; </p>
<p>OK</p>
<p>3 4</p>
<p>4 5</p>
<p>2 3</p>
<p>1 2</p>
<p><span style="font-family:宋体">其中的关键在于</span>, 关键字UNION ALL的应用, 即将原有数据集和新增数据集进行结合, 然后重写表.</p>
<p> </p>
<h3>8.10.2 <strong><span style="font-family:宋体">插入次序</span> </strong></h3>
<p> </p>
<p>INSERT OVERWRITE TABLE<span style="font-family:宋体">在插入数据时</span><span style="font-family:Calibri">,</span><span style="font-family:宋体">是按照后面的</span><span style="font-family:Calibri">SELECT</span><span style="font-family:宋体">语句中的字段顺序插入的</span><span style="font-family:Calibri">.
</span><span style="font-family:宋体">也就说</span><span style="font-family:Calibri">,
</span><span style="font-family:宋体">当</span><span style="font-family:Calibri">id </span>
<span style="font-family:宋体">和</span><span style="font-family:Calibri">value </span>
<span style="font-family:宋体">的位置互换</span><span style="font-family:Calibri">, </span>
<span style="font-family:宋体">那么</span><span style="font-family:Calibri">value</span><span style="font-family:宋体">将被写入</span><span style="font-family:Calibri">id,
</span><span style="font-family:宋体">同</span><span style="font-family:Calibri">id</span><span style="font-family:宋体">被写入</span><span style="font-family:Calibri">value.</span></p>
<h3>8.10.3 <strong><span style="font-family:宋体">初始值</span> </strong></h3>
<p>INSERT OVERWRITE TABLE<span style="font-family:宋体">在插入数据时</span><span style="font-family:Calibri">,
</span><span style="font-family:宋体">后面的字段的初始值应注意与表定义中的一致性</span><span style="font-family:Calibri">.
</span><span style="font-family:宋体">例如</span><span style="font-family:Calibri">, </span>
<span style="font-family:宋体">当为一个</span><span style="font-family:Calibri">STRING</span><span style="font-family:宋体">类型字段初始为</span><span style="font-family:Calibri">NULL</span><span style="font-family:宋体">时</span><span style="font-family:Calibri">:
</span></p>
<p>NULL AS field_name // <span style="font-family:宋体">这可能会被提示定义类型为</span><span style="font-family:Calibri">STRING,
</span><span style="font-family:宋体">但这里是</span><span style="font-family:Calibri">void
</span></p>
<p>CAST(NULL AS STRING) AS field_name // <span style="font-family:宋体">这样是正确的 </span>
</p>
<p><span style="font-family:宋体">又如</span>, <span style="font-family:宋体">为一个</span><span style="font-family:Calibri">BIGINT</span><span style="font-family:宋体">类型的字段初始为</span><span style="font-family:Calibri">0</span><span style="font-family:宋体">时</span><span style="font-family:Calibri">:
</span></p>
<p>CAST(0 AS BIGINT) AS field_name </p>
<p> </p>
<h1><a target="_blank" name="_Toc280791069"></a>9. <strong>优化</strong></h1>
<h2>9.1 <strong>HADOOP<span style="font-family:宋体">计算框架特性</span></strong></h2>
<p>· <span style="font-family:宋体">数据量大不是问题，数据倾斜是个问题。</span> </p>
<p>· jobs数比较多的作业运行效率相对比较低，比如即使有几百行的表，如果多次关联多次汇总，产生十几个jobs，耗时很长。原因是map reduce作业初始化的时间是比较长的。
</p>
<p>· sum,count,max,min等UDAF，不怕数据倾斜问题,hadoop在map端的汇总合并优化，使数据倾斜不成问题。 </p>
<p>· count(distinct ),在数据量大的情况下，效率较低，如果是多count(distinct )效率更低，因为count(distinct)是按group by 字段分组，按distinct字段排序，一般这种分布方式是很倾斜的，比如男uv,女uv，淘宝一天30亿的pv，如果按性别分组，分配2个reduce,每个reduce处理15亿数据。</p>
<h2>9.2 <span style="font-family:宋体">优化的常用手段</span> <strong></strong></h2>
<p>· <span style="font-family:宋体">好的模型设计事半功倍。</span> </p>
<p>· <span style="font-family:宋体">解决数据倾斜问题。</span> </p>
<p>· <span style="font-family:宋体">减少</span>job<span style="font-family:宋体">数。 </span>
</p>
<p>· <span style="font-family:宋体">设置合理的</span>map reduce<span style="font-family:宋体">的</span><span style="font-family:Calibri">task</span><span style="font-family:宋体">数，能有效提升性能。</span><span style="font-family:Calibri">(</span><span style="font-family:宋体">比如，</span><span style="font-family:Calibri">10w+</span><span style="font-family:宋体">级别的计算，用</span><span style="font-family:Calibri">160</span><span style="font-family:宋体">个</span><span style="font-family:Calibri">reduce</span><span style="font-family:宋体">，那是相当的浪费，</span><span style="font-family:Calibri">1</span><span style="font-family:宋体">个足够</span><span style="font-family:Calibri">)</span><span style="font-family:宋体">。
</span></p>
<p>· <span style="font-family:宋体">了解数据分布，自己动手解决数据倾斜问题是个不错的选择。</span>set hive.groupby.skewindata=true;<span style="font-family:宋体">这是通用的算法优化，但算法优化有时不能适应特定业务背景，开发人员了解业务，了解数据，可以通过业务逻辑精确有效的解决数据倾斜问题。
</span></p>
<p>· <span style="font-family:宋体">数据量较大的情况下，慎用</span>count(distinct)<span style="font-family:宋体">，</span><span style="font-family:Calibri">count(distinct)</span><span style="font-family:宋体">容易产生倾斜问题。
</span></p>
<p>· <span style="font-family:宋体">对小文件进行合并，是行至有效的提高调度效率的方法，假如所有的作业设置合理的文件数，对云梯的整体调度效率也会产生积极的正向影响。</span>
</p>
<p>· <span style="font-family:宋体">优化时把握整体，单个作业最优不如整体最优。</span></p>
<p>    </p>
<h2><a target="_blank" name="_Toc280791070"></a>9.3 <strong>全排序</strong></h2>
<p>Hive的排序关键字是SORT BY，它有意区别于传统数据库的ORDER BY也是为了强调两者的区别–SORT BY只能在单机范围内排序。</p>
<h3><a target="_blank" name="_Toc280791071"></a>9.3.1 <strong><span style="font-family:宋体">例</span>1</strong></h3>
<p>set mapred.reduce.tasks=2;</p>
<p>原值</p>
<p>select cookie_id,page_id,id from c02_clickstat_fatdt1 </p>
<p>where cookie_id IN('1.193.131.218.1288611279693.0','1.193.148.164.1288609861509.2')
</p>
<p>1.193.148.164.1288609861509.2   113181412886099008861288609901078194082403      684000005</p>
<p>1.193.148.164.1288609861509.2   127001128860563972141288609859828580660473      684000015</p>
<p>1.193.148.164.1288609861509.2   113181412886099165721288609915890452725326      684000018</p>
<p>1.193.131.218.1288611279693.0   01c183da6e4bc50712881288611540109914561053      684000114</p>
<p>1.193.131.218.1288611279693.0   01c183da6e4bc22412881288611414343558274174      684000118</p>
<p>1.193.131.218.1288611279693.0   01c183da6e4bc50712881288611511781996667988      684000121</p>
<p>1.193.131.218.1288611279693.0   01c183da6e4bc22412881288611523640691739999      684000126</p>
<p>1.193.131.218.1288611279693.0   01c183da6e4bc50712881288611540109914561053      684000128</p>
<p> </p>
<p> </p>
<p>hive&gt; select cookie_id,page_id,id from c02_clickstat_fatdt1 where </p>
<p>cookie_id IN('1.193.131.218.1288611279693.0','1.193.148.164.1288609861509.2') </p>
<p>SORT BY COOKIE_ID,PAGE_ID;</p>
<p>SORT排序后的值</p>
<p>1.193.131.218.1288611279693.0           684000118       01c183da6e4bc22412881288611414343558274174      684000118</p>
<p>1.193.131.218.1288611279693.0           684000114       01c183da6e4bc50712881288611540109914561053      684000114</p>
<p>1.193.131.218.1288611279693.0           684000128       01c183da6e4bc50712881288611540109914561053      684000128</p>
<p>1.193.148.164.1288609861509.2           684000005       113181412886099008861288609901078194082403      684000005</p>
<p>1.193.148.164.1288609861509.2           684000018       113181412886099165721288609915890452725326      684000018</p>
<p>1.193.131.218.1288611279693.0           684000126       01c183da6e4bc22412881288611523640691739999      684000126</p>
<p>1.193.131.218.1288611279693.0           684000121       01c183da6e4bc50712881288611511781996667988      684000121</p>
<p>1.193.148.164.1288609861509.2           684000015       127001128860563972141288609859828580660473      684000015</p>
<p> </p>
<p>select cookie_id,page_id,id from c02_clickstat_fatdt1 </p>
<p>where cookie_id IN('1.193.131.218.1288611279693.0','1.193.148.164.1288609861509.2')
</p>
<p>ORDER BY PAGE_ID,COOKIE_ID;</p>
<p>1.193.131.218.1288611279693.0           684000118       01c183da6e4bc22412881288611414343558274174      684000118</p>
<p>1.193.131.218.1288611279693.0           684000126       01c183da6e4bc22412881288611523640691739999      684000126</p>
<p>1.193.131.218.1288611279693.0           684000121       01c183da6e4bc50712881288611511781996667988      684000121</p>
<p>1.193.131.218.1288611279693.0           684000114       01c183da6e4bc50712881288611540109914561053      684000114</p>
<p>1.193.131.218.1288611279693.0           684000128       01c183da6e4bc50712881288611540109914561053      684000128</p>
<p>1.193.148.164.1288609861509.2           684000005       113181412886099008861288609901078194082403      684000005</p>
<p>1.193.148.164.1288609861509.2           684000018       113181412886099165721288609915890452725326      684000018</p>
<p>1.193.148.164.1288609861509.2           684000015       127001128860563972141288609859828580660473      684000015</p>
<p><span style="font-family:宋体">可以看到</span>SORT和ORDER排序出来的值不一样。一开始我指定了2个reduce进行数据分发(各自进行排序)。结果不一样的主要原因是<span style="font-family:宋体">上述查询没有</span>reduce key，hive会生成随机数作为reduce key。这样的话输入记录也随机地被分发到不同reducer机器上去了。为了保证reducer之间没有重复的cookie_id记录，可以使用DISTRIBUTE BY关键字指定分发key为cookie_id。</p>
<p>select cookie_id,country,id,page_id,id from c02_clickstat_fatdt1 where cookie_id IN('1.193.131.218.1288611279693.0','1.193.148.164.1288609861509.2')  distribute by cookie_id SORT BY COOKIE_ID,page_id;</p>
<p>1.193.131.218.1288611279693.0           684000118       01c183da6e4bc22412881288611414343558274174      684000118</p>
<p>1.193.131.218.1288611279693.0           684000126       01c183da6e4bc22412881288611523640691739999      684000126</p>
<p>1.193.131.218.1288611279693.0           684000121       01c183da6e4bc50712881288611511781996667988      684000121</p>
<p>1.193.131.218.1288611279693.0           684000114       01c183da6e4bc50712881288611540109914561053      684000114</p>
<p>1.193.131.218.1288611279693.0           684000128       01c183da6e4bc50712881288611540109914561053      684000128</p>
<p>1.193.148.164.1288609861509.2           684000005       113181412886099008861288609901078194082403      684000005</p>
<p>1.193.148.164.1288609861509.2           684000018       113181412886099165721288609915890452725326      684000018</p>
<p>1.193.148.164.1288609861509.2           684000015       127001128860563972141288609859828580660473      684000015</p>
<h3><a target="_blank" name="_Toc280791072"></a>9.3.2 <strong><span style="font-family:宋体">例</span>2</strong></h3>
<p>CREATE TABLE if not exists t_order(</p>
<p> </p>
<p>id int, -- 订单编号</p>
<p> </p>
<p>sale_id int, -- 销售ID</p>
<p> </p>
<p>customer_id int, -- 客户ID</p>
<p> </p>
<p>product _id int, -- 产品ID</p>
<p> </p>
<p>amount int -- 数量</p>
<p> </p>
<p>) PARTITIONED BY (ds STRING);</p>
<p><span style="font-family:宋体">在表中查询所有销售记录，并按照销售</span>ID和数量排序：</p>
<p>set mapred.reduce.tasks=2;</p>
<p> </p>
<p>Select sale_id, amount from t_order</p>
<p> </p>
<p>Sort by sale_id, amount;</p>
<p><span style="font-family:宋体">这一查询可能得到非期望的排序。指定的</span>2个reducer分发到的数据可能是（各自排序）：</p>
<p>Reducer1：</p>
<p>Sale_id | amount</p>
<p> </p>
<p>0 | 100</p>
<p> </p>
<p>1 | 30</p>
<p> </p>
<p>1 | 50</p>
<p> </p>
<p>2 | 20</p>
<p>Reducer2：</p>
<p>Sale_id | amount</p>
<p> </p>
<p>0 | 110</p>
<p> </p>
<p>0 | 120</p>
<p> </p>
<p>3 | 50</p>
<p> </p>
<p>4 | 20</p>
<p><span style="font-family:宋体">使用</span>DISTRIBUTE BY关键字指定分发key为sale_id。改造后的HQL如下：</p>
<p>set mapred.reduce.tasks=2;</p>
<p> </p>
<p>Select sale_id, amount from t_order</p>
<p> </p>
<p>Distribute by sale_id</p>
<p> </p>
<p>Sort by sale_id, amount;</p>
<p><span style="font-family:宋体">这样能够保证查询的销售记录集合中，销售</span>ID对应的数量是正确排序的，但是销售ID不能正确排序，原因是hive使用hadoop默认的HashPartitioner分发数据。</p>
<p>这就涉及到一个全排序的问题。解决的办法无外乎两种：</p>
<p>1.) 不分发数据，使用单个reducer：</p>
<p>set mapred.reduce.tasks=1;</p>
<p><span style="font-family:宋体">这一方法的缺陷在于</span>reduce端成为了性能瓶颈，而且在数据量大的情况下一般都无法得到结果。但是实践中这仍然是最常用的方法，原因是通常排序的查询是为了得到排名靠前的若干结果，因此可以用limit子句大大减少数据量。使用limit n后，传输到reduce端（单机）的数据记录数就减少到n* （map个数）。</p>
<p>2.) 修改Partitioner，这种方法可以做到全排序。这里可以使用Hadoop自带的TotalOrderPartitioner（来自于Yahoo!的TeraSort项目），这是一个为了支持跨reducer分发有序数据开发的Partitioner，它需要一个SequenceFile格式的文件指定分发的数据区间。如果我们已经生成了这一文件（存储在/tmp/range_key_list，分成100个reducer），可以将上述查询改写为</p>
<p>set mapred.reduce.tasks=100;</p>
<p> </p>
<p>set hive.mapred.partitioner=org.apache.hadoop.mapred.lib.TotalOrderPartitioner;</p>
<p> </p>
<p>set total.order.partitioner.path=/tmp/ range_key_list;</p>
<p> </p>
<p>Select sale_id, amount from t_order</p>
<p> </p>
<p>Cluster by sale_id</p>
<p> </p>
<p>Sort by amount;</p>
<p><span style="font-family:宋体">有很多种方法生成这一区间文件（例如</span>hadoop自带的o.a.h.mapreduce.lib.partition.InputSampler工具）。这里介绍用Hive生成的方法，例如有一个按id有序的t_sale表：</p>
<p>CREATE TABLE if not exists t_sale (</p>
<p> </p>
<p>id int,</p>
<p> </p>
<p>name string,</p>
<p> </p>
<p>loc string</p>
<p> </p>
<p>);</p>
<p><span style="font-family:宋体">则生成按</span>sale_id分发的区间文件的方法是：</p>
<p>create external table range_keys(sale_id int)</p>
<p> </p>
<p>row format serde</p>
<p> </p>
<p>'org.apache.hadoop.hive.serde2.binarysortable.BinarySortableSerDe'</p>
<p> </p>
<p>stored as</p>
<p> </p>
<p>inputformat</p>
<p> </p>
<p>'org.apache.hadoop.mapred.TextInputFormat'</p>
<p> </p>
<p>outputformat</p>
<p> </p>
<p>'org.apache.hadoop.hive.ql.io.HiveNullValueSequenceFileOutputFormat'</p>
<p> </p>
<p>location '/tmp/range_key_list';</p>
<p> </p>
<p> </p>
<p> </p>
<p>insert overwrite table range_keys</p>
<p> </p>
<p>select distinct sale_id</p>
<p> </p>
<p>from source t_sale sampletable(BUCKET 100 OUT OF 100 ON rand()) s</p>
<p> </p>
<p>sort by sale_id;</p>
<p><span style="font-family:宋体">生成的文件（</span>/tmp/range_key_list目录下）可以让TotalOrderPartitioner按sale_id有序地分发reduce处理的数据。区间文件需要考虑的主要问题是数据分发的均衡性，这有赖于对数据深入的理解。</p>
<h2><a target="_blank" name="_Toc280791073"></a>9.4 <strong>怎样做笛卡尔积</strong></h2>
<p><span style="font-family:宋体">当</span>Hive设定为严格模式（hive.mapred.mode=strict）时，不允许在HQL语句中出现笛卡尔积，这实际说明了Hive对笛卡尔积支持较弱。因为找不到Join key，Hive只能使用1个reducer来完成笛卡尔积。</p>
<p><span style="font-family:宋体">当然也可以用上面说的</span>limit的办法来减少某个表参与join的数据量，但对于需要笛卡尔积语义的需求来说，经常是一个大表和一个小表的Join操作，结果仍然很大（以至于无法用单机处理），这时MapJoin才是最好的解决办法。</p>
<p>MapJoin，顾名思义，会在Map端完成Join操作。这需要将Join操作的一个或多个表完全读入内存。</p>
<p>MapJoin的用法是在查询/子查询的SELECT关键字后面添加/*+ MAPJOIN(tablelist) */提示优化器转化为MapJoin（目前Hive的优化器不能自动优化MapJoin）。其中tablelist可以是一个表，或以逗号连接的表的列表。tablelist中的表将会读入内存，应该将小表写在这里。</p>
<p>PS：有用户说MapJoin在子查询中可能出现未知BUG。在大表和小表做笛卡尔积时，规避笛卡尔积的方法是，给Join添加一个Join key，原理很简单：将小表扩充一列join key，并将小表的条目复制数倍，join key各不相同；将大表扩充一列join key为随机数。</p>
<h2><a target="_blank" name="_Toc280791074"></a>9.5 <strong><span style="font-family:宋体">怎样写</span>exist/in子句</strong></h2>
<p>Hive不支持where子句中的子查询，SQL常用的exist in子句需要改写。这一改写相对简单。考虑以下SQL查询语句：</p>
<p>SELECT a.key, a.value</p>
<p> </p>
<p>FROM a</p>
<p> </p>
<p>WHERE a.key in</p>
<p> </p>
<p>(SELECT b.key</p>
<p> </p>
<p>FROM B);</p>
<p>可以改写为</p>
<p>SELECT a.key, a.value</p>
<p> </p>
<p>FROM a LEFT OUTER JOIN b ON (a.key = b.key)</p>
<p> </p>
<p>WHERE b.key &lt;&gt; NULL;</p>
<p><span style="font-family:宋体">一个更高效的实现是利用</span>left semi join改写为：</p>
<p>SELECT a.key, a.val</p>
<p> </p>
<p>FROM a LEFT SEMI JOIN b on (a.key = b.key);</p>
<p>left semi join是0.5.0以上版本的特性。</p>
<h2><a target="_blank" name="_Toc280791075"></a>9.6 <strong><span style="font-family:宋体">怎样决定</span>reducer个数</strong></h2>
<p>Hadoop MapReduce程序中，reducer个数的设定极大影响执行效率，这使得Hive怎样决定reducer个数成为一个关键问题。遗憾的是Hive的估计机制很弱，不指定reducer个数的情况下，Hive会猜测确定一个reducer个数，基于以下两个设定：</p>
<p>1. hive.exec.reducers.bytes.per.reducer（默认为1000^3）</p>
<p>2. hive.exec.reducers.max（默认为999）</p>
<p><span style="font-family:宋体">计算</span>reducer数的公式很简单：</p>
<p>N=min(参数2，总输入数据量/参数1)</p>
<p><span style="font-family:宋体">通常情况下，有必要手动指定</span>reducer个数。考虑到map阶段的输出数据量通常会比输入有大幅减少，因此即使不设定reducer个数，重设参数2还是必要的。依据Hadoop的经验，可以将参数2设定为0.95*(集群中TaskTracker个数)。</p>
<h2><a target="_blank" name="_Toc280791076"></a>9.7 <strong><span style="font-family:宋体">合并</span>MapReduce操作</strong></h2>
<p><strong>Multi-group by </strong></p>
<p>Multi-group by是Hive的一个非常好的特性，它使得Hive中利用中间结果变得非常方便。例如，</p>
<p>FROM (SELECT a.status, b.school, b.gender</p>
<p> </p>
<p>FROM status_updates a JOIN profiles b</p>
<p> </p>
<p>ON (a.userid = b.userid and</p>
<p> </p>
<p>a.ds='2009-03-20' )</p>
<p> </p>
<p>) subq1</p>
<p> </p>
<p>INSERT OVERWRITE TABLE gender_summary</p>
<p> </p>
<p>PARTITION(ds='2009-03-20')</p>
<p> </p>
<p>SELECT subq1.gender, COUNT(1) GROUP BY subq1.gender</p>
<p> </p>
<p>INSERT OVERWRITE TABLE school_summary</p>
<p> </p>
<p>PARTITION(ds='2009-03-20')</p>
<p> </p>
<p>SELECT subq1.school, COUNT(1) GROUP BY subq1.school</p>
<p><span style="font-family:宋体">上述查询语句使用了</span>Multi-group by特性连续group by了2次数据，使用不同的group by key。这一特性可以减少一次MapReduce操作。</p>
<p><strong>Multi-distinct </strong></p>
<p>Multi-distinct是淘宝开发的另一个multi-xxx特性，使用Multi-distinct可以在同一查询/子查询中使用多个distinct，这同样减少了多次MapReduce操作</p>
<p> </p>
<h2><a target="_blank" name="_Toc280791077"></a>9.8 <em>Bucket <span style="font-family:宋体">
与 </span><span style="font-family:Cambria">sampling</span></em></h2>
<p>Bucket是指将数据以指定列的值为key进行hash，hash到指定数目的桶中。这样就可以支持高效采样了。</p>
<p><span style="font-family:宋体">如下例就是以</span>userid这一列为bucket的依据，共设置32个buckets</p>
<p style="background:rgb(243,245,247)">CREATE TABLE page_view(viewTime INT, userid BIGINT,</p>
<p style="background:rgb(243,245,247)">                    page_url STRING, referrer_url STRING,</p>
<p style="background:rgb(243,245,247)">                    ip STRING COMMENT 'IP Address of the User')</p>
<p style="background:rgb(243,245,247)">    COMMENT 'This is the page view table'</p>
<p style="background:rgb(243,245,247)">    PARTITIONED BY(dt STRING, country STRING)</p>
<p style="background:rgb(243,245,247)">   <span style="color:rgb(255,0,0)"> CLUSTERED BY(userid) SORTED BY(viewTime) INTO 32 BUCKETS</span></p>
<p style="background:rgb(243,245,247)">    ROW FORMAT DELIMITED</p>
<p style="background:rgb(243,245,247)">            FIELDS TERMINATED BY '1'</p>
<p style="background:rgb(243,245,247)">            COLLECTION ITEMS TERMINATED BY '2'</p>
<p style="background:rgb(243,245,247)">            MAP KEYS TERMINATED BY '3'</p>
<p style="background:rgb(243,245,247)">    STORED AS SEQUENCEFILE;</p>
<p>Sampling可以在全体数据上进行采样，这样效率自然就低，它还是要去访问所有数据。而如果一个表已经对某一列制作了bucket，就可以采样所有桶中指定序号的某个桶，这就减少了访问量。</p>
<p><span style="font-family:宋体">如下例所示就是采样了</span>page_view中32个桶中的第三个桶。</p>
<p style="background:rgb(243,245,247)">SELECT * FROM page_view <span style="color:rgb(255,0,0)">
TABLESAMPLE(BUCKET 3 OUT OF 32)</span>;</p>
<p> </p>
<h2><a target="_blank" name="_Toc280791078"></a>9.9 <strong>Partition</strong></h2>
<p>Partition就是分区。分区通过在创建表时启用partition by实现，用来partition的维度并不是实际数据的某一列，具体分区的标志是由插入内容时给定的。当要查询某一分区的内容时可以采用where语句，形似where tablename.partition_key &gt; a来实现。</p>
<p>创建含分区的表</p>
<p style="background:rgb(243,245,247)">    CREATE TABLE page_view(viewTime INT, userid BIGINT,</p>
<p style="background:rgb(243,245,247)">                    page_url STRING, referrer_url STRING,</p>
<p style="background:rgb(243,245,247)">                    ip STRING COMMENT 'IP Address of the User')</p>
<p style="background:rgb(243,245,247)">    <span style="color:rgb(255,0,0)">PARTITIONED BY(date STRING, country STRING)</span></p>
<p style="background:rgb(243,245,247)">    ROW FORMAT DELIMITED</p>
<p style="background:rgb(243,245,247)">            FIELDS TERMINATED BY '1'</p>
<p style="background:rgb(243,245,247)">    STORED AS TEXTFILE;</p>
<p>载入内容，并指定分区标志</p>
<p style="background:rgb(243,245,247)">LOAD DATA LOCAL INPATH `/tmp/pv_2008-06-08_us.txt` INTO TABLE page_view
<span style="color:rgb(255,0,0)">PARTITION(date='2008-06-08', country='US')</span>;</p>
<p>查询指定标志的分区内容</p>
<p style="background:rgb(243,245,247)">SELECT page_views.*</p>
<p style="background:rgb(243,245,247)">    FROM page_views</p>
<p style="background:rgb(243,245,247)">    WHERE <span style="color:rgb(255,0,0)">
page_views.date &gt;= '2008-03-01' AND page_views.date &lt;= '2008-03-31'</span> AND page_views.referrer_url like '%xyz.com';</p>
<p> </p>
<h2><a target="_blank" name="_Toc280791079"></a>9.10 <strong>JOIN</strong></h2>
<h3><a target="_blank" name="_Toc280791080"></a>9.10.1 <strong>JOIN<span style="font-family:宋体">原则</span></strong></h3>
<p><span style="font-family:宋体">在使用写有</span> Join 操作的查询语句时有一条原则：应该将条目少的表/子查询放在 Join 操作符的左边。原因是在 Join 操作的 Reduce 阶段，位于 Join 操作符左边的表的内容会被加载进内存，将条目少的表放在左边，可以有效减少发生 OOM 错误的几率。对于一条语句中有多个 Join 的情况，如果 Join 的条件相同，比如查询：
</p>
<table>
<tbody>
<tr>
<td valign="center" style="background:rgb(255,250,205)">
<p>INSERT OVERWRITE TABLE pv_users </p>
<p> SELECT pv.pageid, u.age FROM page_view p </p>
<p> JOIN user u ON (pv.userid = u.userid) </p>
<p> JOIN newuser x ON (u.userid = x.userid);  </p>
</td>
</tr>
</tbody>
</table>
<p>· <span style="font-family:宋体">如果</span> Join <span style="font-family:宋体">的 </span>
<span style="font-family:Calibri">key </span><span style="font-family:宋体">相同，不管有多少个表，都会则会合并为一个
</span><span style="font-family:Calibri">Map-Reduce </span></p>
<p>· <span style="font-family:宋体">一个</span> Map-Reduce <span style="font-family:宋体">
任务，而不是 </span><span style="font-family:Calibri">‘n’ </span><span style="font-family:宋体">个
</span></p>
<p>· <span style="font-family:宋体">在做</span> OUTER JOIN <span style="font-family:宋体">
的时候也是一样 </span></p>
<p><span style="font-family:宋体">如果</span> Join 的条件不相同，比如： </p>
<table>
<tbody>
<tr>
<td valign="center" style="background:rgb(255,250,205)">
<p>INSERT OVERWRITE TABLE pv_users </p>
<p>   SELECT pv.pageid, u.age FROM page_view p </p>
<p>   JOIN user u ON (pv.userid = u.userid) </p>
<p>   JOIN newuser x on (u.age = x.age);   </p>
</td>
</tr>
</tbody>
</table>
<p>Map-Reduce 的任务数目和 Join 操作的数目是对应的，上述查询和以下查询是等价的： </p>
<table>
<tbody>
<tr>
<td valign="center" style="background:rgb(255,250,205)">
<p>INSERT OVERWRITE TABLE tmptable </p>
<p>   SELECT * FROM page_view p JOIN user u </p>
<p>   ON (pv.userid = u.userid);</p>
<p> INSERT OVERWRITE TABLE pv_users </p>
<p>   SELECT x.pageid, x.age FROM tmptable x </p>
<p>   JOIN newuser y ON (x.age = y.age);    </p>
</td>
</tr>
</tbody>
</table>
<h3><a target="_blank" name="Map_Join"></a>9.10.2 <a target="_blank" name="_Toc280791081">Map Join</a> <strong></strong></h3>
<p>Join 操作在 Map 阶段完成，不再需要Reduce，前提条件是需要的数据在 Map 的过程中可以访问到。比如查询： </p>
<table>
<tbody>
<tr>
<td valign="center" style="background:rgb(255,250,205)">
<p>INSERT OVERWRITE TABLE pv_users </p>
<p>   SELECT /*+ MAPJOIN(pv) */ pv.pageid, u.age </p>
<p>   FROM page_view pv </p>
<p>     JOIN user u ON (pv.userid = u.userid);    </p>
</td>
</tr>
</tbody>
</table>
<p><span style="font-family:宋体">可以在</span> Map 阶段完成 Join，如图所示： </p>
<p> </p>
<p><span style="font-family:宋体">相关的参数为：</span> </p>
<p>· <strong>hive.join.emit.interval = 1000</strong> How many rows in the right-most join operand Hive should buffer before emitting the join result.
</p>
<p>· <strong>hive.mapjoin.size.key = 10000</strong> </p>
<p>· <strong>hive.mapjoin.cache.numrows = 10000</strong> </p>
<p> </p>
<h2>9.11 <strong>数据倾斜</strong></h2>
<h3>9.11.1 <strong>空值数据倾斜</strong></h3>
<p><strong><span style="font-family:宋体">场景：</span></strong><span style="font-family:宋体">如日志中，常会有信息丢失的问题，比如全网日志中的</span>user_id<span style="font-family:宋体">，如果取其中的</span><span style="font-family:Calibri">user_id</span><span style="font-family:宋体">和</span><span style="font-family:Calibri">bmw_users</span><span style="font-family:宋体">关联，会碰到数据倾斜的问题。</span></p>
<p><strong><span style="font-family:宋体">解决方法</span>1<span style="font-family:宋体">：</span></strong> user_id<span style="font-family:宋体">为空的不参与关联</span></p>
<p>Select * From log a </p>
<p>Join bmw_users b</p>
<p>On a.user_id is not null</p>
<p>And a.user_id = b.user_id</p>
<p>Union all</p>
<p>Select * from log a</p>
<p>where a.user_id is null;</p>
<p><strong><span style="font-family:宋体">解决方法</span>2 <span style="font-family:宋体">
：</span></strong><span style="font-family:宋体">赋与空值分新的</span>key<span style="font-family:宋体">值</span></p>
<p>Select *  </p>
<p>from log a </p>
<p>left outer join bmw_users b </p>
<p><strong>on case when a.user_id is null then concat(‘dp_hive’,rand() ) else a.user_id end = b.user_id; </strong></p>
<p><strong><span style="font-family:宋体">结论：</span></strong><span style="font-family:宋体">方法</span>2<span style="font-family:宋体">比方法效率更好，不但</span><span style="font-family:Calibri">io</span><span style="font-family:宋体">少了，而且作业数也少了。方法</span><span style="font-family:Calibri">1
 log</span><span style="font-family:宋体">读取两次，</span><span style="font-family:Calibri">jobs</span><span style="font-family:宋体">是</span><span style="font-family:Calibri">2</span><span style="font-family:宋体">。方法</span><span style="font-family:Calibri">2 job</span><span style="font-family:宋体">数是</span><span style="font-family:Calibri">1
</span><span style="font-family:宋体">。这个优化适合无效</span><span style="font-family:Calibri">id(</span><span style="font-family:宋体">比如</span><span style="font-family:Calibri">-99,’’,null</span><span style="font-family:宋体">等</span><span style="font-family:Calibri">)</span><span style="font-family:宋体">产生的倾斜问题。把空值的</span><span style="font-family:Calibri">key</span><span style="font-family:宋体">变成一个字符串加上随机数，就能把倾斜的数据分到不同的</span><span style="font-family:Calibri">reduce</span><span style="font-family:宋体">上
</span><span style="font-family:Calibri">,</span><span style="font-family:宋体">解决数据倾斜问题。附上</span><span style="font-family:Calibri">hadoop</span><span style="font-family:宋体">通用关联的实现方法（关联通过二次排序实现的，关联的列为</span><span style="font-family:Calibri">parition key,</span><span style="font-family:宋体">关联的列</span><span style="font-family:Calibri">c1</span><span style="font-family:宋体">和表的</span><span style="font-family:Calibri">tag</span><span style="font-family:宋体">组成排序的</span><span style="font-family:Calibri">group
 key,</span><span style="font-family:宋体">根据</span><span style="font-family:Calibri">parition key</span><span style="font-family:宋体">分配</span><span style="font-family:Calibri">reduce</span><span style="font-family:宋体">。同一</span><span style="font-family:Calibri">reduce</span><span style="font-family:宋体">内根据</span><span style="font-family:Calibri">group
 key</span><span style="font-family:宋体">排序）</span></p>
<p> </p>
<h3>9.11.2 <span style="font-family:宋体">不同数据类型关联产生数据倾斜</span> <strong></strong></h3>
<p><strong>场景：</strong><span style="font-family:宋体">一张表</span>s8的日志，每个商品一条记录，要和商品表关联。但关联却碰到倾斜的问题。s8的日志中有字符串商品id,也有数字的商品id,类型是string的，但商品中的数字id是bigint的。猜测问题的原因是把s8的商品id转成数字id做hash来分配reduce，所以字符串id的s8日志，都到一个reduce上了，解决的方法验证了这个猜测。</p>
<p><strong>解决方法：</strong>把数字类型转换成字符串类型</p>
<p>Select * from s8_log a</p>
<p>Left outer join r_auction_auctions b</p>
<p>On a.auction_id = cast(b.auction_id as string);</p>
<h3><a target="_blank" name="_Toc280791082"></a>9.11.3 <strong><span style="font-family:宋体">大表</span>Join<span style="font-family:宋体">的数据偏斜</span></strong></h3>
<p>MapReduce<span style="font-family:宋体">编程模型下开发代码需要考虑数据偏斜的问题，</span><span style="font-family:Calibri">Hive</span><span style="font-family:宋体">代码也是一样。数据偏斜的原因包括以下两点：</span></p>
<p>1. Map<span style="font-family:宋体">输出</span><span style="font-family:Calibri">key</span><span style="font-family:宋体">数量极少，导致</span><span style="font-family:Calibri">reduce</span><span style="font-family:宋体">端退化为单机作业。</span></p>
<p>2. Map<span style="font-family:宋体">输出</span><span style="font-family:Calibri">key</span><span style="font-family:宋体">分布不均，少量</span><span style="font-family:Calibri">key</span><span style="font-family:宋体">对应大量</span><span style="font-family:Calibri">value</span><span style="font-family:宋体">，导致</span><span style="font-family:Calibri">reduce</span><span style="font-family:宋体">端单机瓶颈。</span></p>
<p>Hive<span style="font-family:宋体">中我们使用</span><span style="font-family:Calibri">MapJoin</span><span style="font-family:宋体">解决数据偏斜的问题，即将其中的某个表（全量）分发到所有</span><span style="font-family:Calibri">Map</span><span style="font-family:宋体">端进行</span><span style="font-family:Calibri">Join</span><span style="font-family:宋体">，从而避免了</span><span style="font-family:Calibri">reduce</span><span style="font-family:宋体">。这要求分发的表可以被全量载入内存。</span></p>
<p><span style="font-family:宋体">极限情况下，</span>Join<span style="font-family:宋体">两边的表都是大表，就无法使用</span><span style="font-family:Calibri">MapJoin</span><span style="font-family:宋体">。</span></p>
<p>这种问题最为棘手，目前已知的解决思路有两种：</p>
<p> </p>
<p>1. <span style="font-family:宋体">如果是上述情况</span><span style="font-family:Calibri">1</span><span style="font-family:宋体">，考虑先对</span><span style="font-family:Calibri">Join</span><span style="font-family:宋体">中的一个表去重，以此结果过滤无用信息。这样一般会将其中一个大表转化为小表，再使用</span><span style="font-family:Calibri">MapJoin </span><span style="font-family:宋体">。</span></p>
<p><span style="font-family:宋体">一个实例是广告投放效果分析，例如将广告投放者信息表</span>i<span style="font-family:宋体">中的信息填充到广告曝光日志表</span><span style="font-family:Calibri">w</span><span style="font-family:宋体">中，使用投放者</span><span style="font-family:Calibri">id</span><span style="font-family:宋体">关联。因为实际广告投放者数量很少（但是投放者信息表</span><span style="font-family:Calibri">i</span><span style="font-family:宋体">很大），因此可以考虑先在</span><span style="font-family:Calibri">w</span><span style="font-family:宋体">表中去重查询所有实际广告投放者</span><span style="font-family:Calibri">id</span><span style="font-family:宋体">列表，以此</span><span style="font-family:Calibri">Join</span><span style="font-family:宋体">过滤表</span><span style="font-family:Calibri">i</span><span style="font-family:宋体">，这一结果必然是一个小表，就可以使用</span><span style="font-family:Calibri">MapJoin</span><span style="font-family:宋体">。</span></p>
<p> </p>
<p>2. <span style="font-family:宋体">如果是上述情况</span><span style="font-family:Calibri">2</span><span style="font-family:宋体">，考虑切分</span><span style="font-family:Calibri">Join</span><span style="font-family:宋体">中的一个表为多片，以便将切片全部载入内存，然后采用多次</span><span style="font-family:Calibri">MapJoin</span><span style="font-family:宋体">得到结果。</span></p>
<p><span style="font-family:宋体">一个实例是商品浏览日志分析，例如将商品信息表</span>i<span style="font-family:宋体">中的信息填充到商品浏览日志表</span><span style="font-family:Calibri">w</span><span style="font-family:宋体">中，使用商品</span><span style="font-family:Calibri">id</span><span style="font-family:宋体">关联。但是某些热卖商品浏览量很大，造成数据偏斜。例如，以下语句实现了一个</span><span style="font-family:Calibri">inner
 join</span><span style="font-family:宋体">逻辑，将商品信息表拆分成</span><span style="font-family:Calibri">2</span><span style="font-family:宋体">个表：</span></p>
<p>select * from</p>
<p>(</p>
<p>select w.id, w.time, w.amount, i1.name, i1.loc, i1.cat</p>
<p>from w left outer join i sampletable(1 out of 2 on id) i1</p>
<p>)</p>
<p>union all</p>
<p>(</p>
<p>select w.id, w.time, w.amount, i2.name, i2.loc, i2.cat</p>
<p>from w left outer join i sampletable(1 out of 2 on id) i2</p>
<p>)</p>
<p>);</p>
<p><span style="font-family:宋体">以下语句实现了</span>left outer join<span style="font-family:宋体">逻辑：</span></p>
<p>select t1.id, t1.time, t1.amount,</p>
<p>    coalease(t1.name, t2.name), </p>
<p>    coalease(t1.loc, t2.loc), </p>
<p>    coalease(t1.cat, t2.cat) </p>
<p>from (  </p>
<p>    select w.id, w.time, w.amount, i1.name, i1.loc, i1.cat </p>
<p>    from w left outer join i sampletable(1 out of 2 on id) i1 </p>
<p>) t1 left outer join i sampletable(2 out of 2 on id) t2;</p>
<p><span style="font-family:宋体">上述语句使用</span>Hive<span style="font-family:宋体">的</span><span style="font-family:Calibri">sample table</span><span style="font-family:宋体">特性对表做切分。</span></p>
<p> </p>
<h2><a target="_blank" name="_Toc280791083"></a>9.12 <span style="font-family:宋体">合并小文件</span><strong></strong></h2>
<p><span style="font-family:宋体">文件数目过多，会给</span> HDFS 带来压力，并且会影响处理效率，可以通过合并 Map 和 Reduce 的结果文件来消除这样的影响：
</p>
<p>hive.merge.mapfiles = true <span style="font-family:宋体">是否和并</span> Map 输出文件，默认为 True
</p>
<p>hive.merge.mapredfiles = false <span style="font-family:宋体">是否合并</span> Reduce 输出文件，默认为 False
</p>
<p>hive.merge.size.per.task = 256*1000*1000 <span style="font-family:宋体">合并文件的大小</span>
</p>
<p> </p>
<h2><a target="_blank" name="_Toc280791084"></a>9.13 Group By <strong></strong></h2>
<p>· Map <span style="font-family:宋体">端部分聚合： </span></p>
<p>     <span style="font-family:宋体">并不是所有的聚合操作都需要在</span> Reduce <span style="font-family:宋体">
端完成，很多聚合操作都可以先在 </span><span style="font-family:Calibri">Map </span><span style="font-family:宋体">端进行部分聚合，最后在
</span><span style="font-family:Calibri">Reduce </span><span style="font-family:宋体">端得出最终结果。
</span></p>
<p>      <span style="font-family:宋体">基于</span> Hash </p>
<p>      <span style="font-family:宋体">参数包括：</span> </p>
<p>§ hive.map.aggr = true <span style="font-family:宋体">是否在</span> Map <span style="font-family:宋体">
端进行聚合，默认为 </span><span style="font-family:Calibri">True </span></p>
<p>§ hive.groupby.mapaggr.checkinterval = 100000 <span style="font-family:宋体">在</span> Map
<span style="font-family:宋体">端进行聚合操作的条目数目 </span></p>
<p>· <span style="font-family:宋体">有数据倾斜的时候进行负载均衡</span> </p>
<p>      hive.groupby.skewindata = false </p>
<p>     <span style="font-family:宋体">当选项设定为</span> true<span style="font-family:宋体">，生成的查询计划会有两个
</span><span style="font-family:Calibri">MR Job</span><span style="font-family:宋体">。第一个
</span><span style="font-family:Calibri">MR Job </span><span style="font-family:宋体">中，</span><span style="font-family:Calibri">Map
</span><span style="font-family:宋体">的输出结果集合会随机分布到 </span><span style="font-family:Calibri">Reduce
</span><span style="font-family:宋体">中，每个 </span><span style="font-family:Calibri">Reduce
</span><span style="font-family:宋体">做部分聚合操作，并输出结果，这样处理的结果是相同的 </span><span style="font-family:Calibri">Group By Key
</span><span style="font-family:宋体">有可能被分发到不同的 </span><span style="font-family:Calibri">Reduce
</span><span style="font-family:宋体">中，从而达到负载均衡的目的；第二个 </span><span style="font-family:Calibri">MR Job
</span><span style="font-family:宋体">再根据预处理的数据结果按照 </span><span style="font-family:Calibri">Group By Key
</span><span style="font-family:宋体">分布到 </span><span style="font-family:Calibri">Reduce
</span><span style="font-family:宋体">中（这个过程可以保证相同的 </span><span style="font-family:Calibri">Group By Key
</span><span style="font-family:宋体">被分布到同一个 </span><span style="font-family:Calibri">Reduce
</span><span style="font-family:宋体">中），最后完成最终的聚合操作。 </span></p>
<p> </p>
<h1><a target="_blank" name="_Toc280791085"></a>10. <strong>HIVE FAQ</strong></h1>
<p>1、 [admin@hadoop1 ~]$ hive</p>
<p>Cannot find hadoop installation: $HADOOP_HOME must be set or hadoop must be in the path</p>
<p><span style="font-family:宋体">原因：</span>HADOOP路径没有在环境变量中定义</p>
<p><span style="font-family:宋体">解决方法：</span>admin@hadoop1 ~]$ export HADOOP_HOME=$HOME/hadoop-0.19.2</p>
<p> </p>
<p>2、FAILED: Execution Error, return code 1 from org.apache.hadoop.hive.ql.exec.DDLTask</p>
<p><span style="font-family:宋体">解决方案：</span>Hive<span style="font-family:宋体">的元数据库</span><span style="font-family:Calibri">derby</span><span style="font-family:宋体">服务没有启动</span></p>
<p><span style="font-family:宋体">进入到</span>hive<span style="font-family:宋体">的安装目录</span></p>
<p>/home/admin/caona/hive/build/dist/db-derby-10.4.1.3-bin/bin</p>
<p>运行startNetworkServer -h 0.0.0.0</p>
<p> </p>
<p>3、[admin@hadoop1 conf]$ hive</p>
<p>Unable to create log directory ${build.dir}/tmp</p>
<p>原因：存放日志文件的目录被人删除了。</p>
<p>解决方法：进行到${build.dir}<span style="font-family:宋体">下面，创建一个</span>tmp目录。</p>
<p>如：[admin@hadoop1 build]$ pwd</p>
<p>/home/admin/caona/hive/build</p>
<p>[admin@hadoop1 build]$ mkdir tmp</p>
<p> </p>
<h1>11. <strong>常用参考资料路径</strong></h1>
<p>Hive<span style="font-family:宋体">地址</span></p>
<p><a target="_blank" href="http://wiki.apache.org/hadoop/Hive" rel="nofollow" title="阿里旺旺无法确定该链接的安全性"><u><span style="color:rgb(0,0,255)">http://wiki.apache.org/hadoop/Hive</span></u></a></p>
<p>http://hive.apache.org/</p>
<p>Velocity<span style="font-family:宋体">地址</span></p>
<p><a target="_blank" href="http://velocity.apache.org/engine/releases/velocity-1.7/user-guide.html" rel="nofollow" title="阿里旺旺无法确定该链接的安全性"><u><span style="color:rgb(0,0,255)">http://velocity.apache.org/engine/releases/velocity-1.7/user-guide.html</span></u></a></p>
<p>Hadoop地址</p>
<p><a target="_blank" href="http://hadoop.apache.org/" rel="nofollow"><u><span style="color:rgb(0,0,255)">http://hadoop.apache.org/</span></u></a></p>
<p><a target="_blank" href="http://www.cloudera.com/" rel="nofollow"><u><span style="color:rgb(128,0,128)">http://www.cloudera.com/</span></u></a></p>
<p>Hadoop<span style="font-family:宋体">中文文档地址</span></p>
<p><a target="_blank" href="http://hadoop.apache.org/common/docs/r0.18.2/cn/commands_manual.html" rel="nofollow" title="阿里旺旺无法确定该链接的安全性"><u><span style="color:rgb(0,0,255)">http://hadoop.apache.org/common/docs/r0.18.2/cn/commands_manual.html</span></u></a></p>
            </div>
                </div>